/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/babel-loader/lib/index.js?!./resources/assets/vendor/MediaManager/js/webworkers/audio.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js?!./resources/assets/vendor/MediaManager/js/webworkers/audio.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4-0!./resources/assets/vendor/MediaManager/js/webworkers/audio.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var musicMetadata = __webpack_require__(/*! music-metadata-browser */ \"./node_modules/music-metadata-browser/lib/index.js\");\n\nself.addEventListener('message', function (e) {\n  var url = e.data;\n  musicMetadata.fetchFromUrl(url).then(function (val) {\n    var res = val.common;\n    var picture = res.picture;\n    self.postMessage({\n      artist: res.artist,\n      title: res.title,\n      album: res.album,\n      track: res.track.no,\n      track_total: res.track.of,\n      year: res.year,\n      genre: res.genre ? res.genre[0] : null,\n      cover: picture ? URL.createObjectURL(new Blob([picture[0].data.buffer])) : null\n    });\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9NZWRpYU1hbmFnZXIvanMvd2Vid29ya2Vycy9hdWRpby5qcz8wYzBmIl0sIm5hbWVzIjpbIm11c2ljTWV0YWRhdGEiLCJyZXF1aXJlIiwic2VsZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwidXJsIiwiZGF0YSIsImZldGNoRnJvbVVybCIsInRoZW4iLCJ2YWwiLCJyZXMiLCJjb21tb24iLCJwaWN0dXJlIiwicG9zdE1lc3NhZ2UiLCJhcnRpc3QiLCJ0aXRsZSIsImFsYnVtIiwidHJhY2siLCJubyIsInRyYWNrX3RvdGFsIiwib2YiLCJ5ZWFyIiwiZ2VucmUiLCJjb3ZlciIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJidWZmZXIiXSwibWFwcGluZ3MiOiJBQUFBLElBQU1BLGFBQWEsR0FBR0MsbUJBQU8sQ0FBQyxrRkFBRCxDQUE3Qjs7QUFFQUMsSUFBSSxDQUFDQyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFDQyxDQUFELEVBQU87QUFDcEMsTUFBSUMsR0FBRyxHQUFHRCxDQUFDLENBQUNFLElBQVo7QUFFQU4sZUFBYSxDQUFDTyxZQUFkLENBQTJCRixHQUEzQixFQUNLRyxJQURMLENBQ1UsVUFBQ0MsR0FBRCxFQUFTO0FBQ1gsUUFBSUMsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE1BQWQ7QUFDQSxRQUFJQyxPQUFPLEdBQUdGLEdBQUcsQ0FBQ0UsT0FBbEI7QUFFQVYsUUFBSSxDQUFDVyxXQUFMLENBQWlCO0FBQ2JDLFlBQU0sRUFBRUosR0FBRyxDQUFDSSxNQURDO0FBRWJDLFdBQUssRUFBRUwsR0FBRyxDQUFDSyxLQUZFO0FBR2JDLFdBQUssRUFBRU4sR0FBRyxDQUFDTSxLQUhFO0FBSWJDLFdBQUssRUFBRVAsR0FBRyxDQUFDTyxLQUFKLENBQVVDLEVBSko7QUFLYkMsaUJBQVcsRUFBRVQsR0FBRyxDQUFDTyxLQUFKLENBQVVHLEVBTFY7QUFNYkMsVUFBSSxFQUFFWCxHQUFHLENBQUNXLElBTkc7QUFPYkMsV0FBSyxFQUFFWixHQUFHLENBQUNZLEtBQUosR0FBWVosR0FBRyxDQUFDWSxLQUFKLENBQVUsQ0FBVixDQUFaLEdBQTJCLElBUHJCO0FBUWJDLFdBQUssRUFBRVgsT0FBTyxHQUNSWSxHQUFHLENBQUNDLGVBQUosQ0FBb0IsSUFBSUMsSUFBSixDQUFTLENBQUNkLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV04sSUFBWCxDQUFnQnFCLE1BQWpCLENBQVQsQ0FBcEIsQ0FEUSxHQUVSO0FBVk8sS0FBakI7QUFZSCxHQWpCTDtBQWtCSCxDQXJCRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL01lZGlhTWFuYWdlci9qcy93ZWJ3b3JrZXJzL2F1ZGlvLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbXVzaWNNZXRhZGF0YSA9IHJlcXVpcmUoJ211c2ljLW1ldGFkYXRhLWJyb3dzZXInKVxuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZSkgPT4ge1xuICAgIGxldCB1cmwgPSBlLmRhdGFcblxuICAgIG11c2ljTWV0YWRhdGEuZmV0Y2hGcm9tVXJsKHVybClcbiAgICAgICAgLnRoZW4oKHZhbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcyA9IHZhbC5jb21tb25cbiAgICAgICAgICAgIGxldCBwaWN0dXJlID0gcmVzLnBpY3R1cmVcblxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYXJ0aXN0OiByZXMuYXJ0aXN0LFxuICAgICAgICAgICAgICAgIHRpdGxlOiByZXMudGl0bGUsXG4gICAgICAgICAgICAgICAgYWxidW06IHJlcy5hbGJ1bSxcbiAgICAgICAgICAgICAgICB0cmFjazogcmVzLnRyYWNrLm5vLFxuICAgICAgICAgICAgICAgIHRyYWNrX3RvdGFsOiByZXMudHJhY2sub2YsXG4gICAgICAgICAgICAgICAgeWVhcjogcmVzLnllYXIsXG4gICAgICAgICAgICAgICAgZ2VucmU6IHJlcy5nZW5yZSA/IHJlcy5nZW5yZVswXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgY292ZXI6IHBpY3R1cmVcbiAgICAgICAgICAgICAgICAgICAgPyBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtwaWN0dXJlWzBdLmRhdGEuYnVmZmVyXSkpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js?!./resources/assets/vendor/MediaManager/js/webworkers/audio.js\n");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/content-type/index.js":
/*!********************************************!*\
  !*** ./node_modules/content-type/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29udGVudC10eXBlL2luZGV4LmpzP2I0MGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvbnRlbnQtdHlwZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY29udGVudC10eXBlXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoICooIFwiO1wiIHBhcmFtZXRlciApIGluIFJGQyA3MjMxIHNlYyAzLjEuMS4xXG4gKlxuICogcGFyYW1ldGVyICAgICA9IHRva2VuIFwiPVwiICggdG9rZW4gLyBxdW90ZWQtc3RyaW5nIClcbiAqIHRva2VuICAgICAgICAgPSAxKnRjaGFyXG4gKiB0Y2hhciAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCJcbiAqICAgICAgICAgICAgICAgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcInxcIiAvIFwiflwiXG4gKiAgICAgICAgICAgICAgIC8gRElHSVQgLyBBTFBIQVxuICogICAgICAgICAgICAgICA7IGFueSBWQ0hBUiwgZXhjZXB0IGRlbGltaXRlcnNcbiAqIHF1b3RlZC1zdHJpbmcgPSBEUVVPVEUgKiggcWR0ZXh0IC8gcXVvdGVkLXBhaXIgKSBEUVVPVEVcbiAqIHFkdGV4dCAgICAgICAgPSBIVEFCIC8gU1AgLyAleDIxIC8gJXgyMy01QiAvICV4NUQtN0UgLyBvYnMtdGV4dFxuICogb2JzLXRleHQgICAgICA9ICV4ODAtRkZcbiAqIHF1b3RlZC1wYWlyICAgPSBcIlxcXCIgKCBIVEFCIC8gU1AgLyBWQ0hBUiAvIG9icy10ZXh0IClcbiAqL1xudmFyIFBBUkFNX1JFR0VYUCA9IC87ICooWyEjJCUmJyorLl5fYHx+MC05QS1aYS16LV0rKSAqPSAqKFwiKD86W1xcdTAwMGJcXHUwMDIwXFx1MDAyMVxcdTAwMjMtXFx1MDA1YlxcdTAwNWQtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl18XFxcXFtcXHUwMDBiXFx1MDAyMC1cXHUwMGZmXSkqXCJ8WyEjJCUmJyorLl5fYHx+MC05QS1aYS16LV0rKSAqL2dcbnZhciBURVhUX1JFR0VYUCA9IC9eW1xcdTAwMGJcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdKyQvXG52YXIgVE9LRU5fUkVHRVhQID0gL15bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXSskL1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBxdW90ZWQtcGFpciBpbiBSRkMgNzIzMCBzZWMgMy4yLjZcbiAqXG4gKiBxdW90ZWQtcGFpciA9IFwiXFxcIiAoIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICogb2JzLXRleHQgICAgPSAleDgwLUZGXG4gKi9cbnZhciBRRVNDX1JFR0VYUCA9IC9cXFxcKFtcXHUwMDBiXFx1MDAyMC1cXHUwMGZmXSkvZ1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBjaGFycyB0aGF0IG11c3QgYmUgcXVvdGVkLXBhaXIgaW4gUkZDIDcyMzAgc2VjIDMuMi42XG4gKi9cbnZhciBRVU9URV9SRUdFWFAgPSAvKFtcXFxcXCJdKS9nXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHR5cGUgaW4gUkZDIDcyMzEgc2VjIDMuMS4xLjFcbiAqXG4gKiBtZWRpYS10eXBlID0gdHlwZSBcIi9cIiBzdWJ0eXBlXG4gKiB0eXBlICAgICAgID0gdG9rZW5cbiAqIHN1YnR5cGUgICAgPSB0b2tlblxuICovXG52YXIgVFlQRV9SRUdFWFAgPSAvXlshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dK1xcL1shIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKyQvXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuXG4vKipcbiAqIEZvcm1hdCBvYmplY3QgdG8gbWVkaWEgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHBhcmFtZXRlcnMgPSBvYmoucGFyYW1ldGVyc1xuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgaWYgKCF0eXBlIHx8ICFUWVBFX1JFR0VYUC50ZXN0KHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB0eXBlJylcbiAgfVxuXG4gIHZhciBzdHJpbmcgPSB0eXBlXG5cbiAgLy8gYXBwZW5kIHBhcmFtZXRlcnNcbiAgaWYgKHBhcmFtZXRlcnMgJiYgdHlwZW9mIHBhcmFtZXRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHBhcmFtXG4gICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLnNvcnQoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmFtID0gcGFyYW1zW2ldXG5cbiAgICAgIGlmICghVE9LRU5fUkVHRVhQLnRlc3QocGFyYW0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVyIG5hbWUnKVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcgKz0gJzsgJyArIHBhcmFtICsgJz0nICsgcXN0cmluZyhwYXJhbWV0ZXJzW3BhcmFtXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nXG59XG5cbi8qKlxuICogUGFyc2UgbWVkaWEgdHlwZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzdHJpbmdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZSAoc3RyaW5nKSB7XG4gIGlmICghc3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyaW5nIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIHN1cHBvcnQgcmVxL3Jlcy1saWtlIG9iamVjdHMgYXMgYXJndW1lbnRcbiAgdmFyIGhlYWRlciA9IHR5cGVvZiBzdHJpbmcgPT09ICdvYmplY3QnXG4gICAgPyBnZXRjb250ZW50dHlwZShzdHJpbmcpXG4gICAgOiBzdHJpbmdcblxuICBpZiAodHlwZW9mIGhlYWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgdmFyIGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzsnKVxuICB2YXIgdHlwZSA9IGluZGV4ICE9PSAtMVxuICAgID8gaGVhZGVyLnN1YnN0cigwLCBpbmRleCkudHJpbSgpXG4gICAgOiBoZWFkZXIudHJpbSgpXG5cbiAgaWYgKCFUWVBFX1JFR0VYUC50ZXN0KHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZWRpYSB0eXBlJylcbiAgfVxuXG4gIHZhciBvYmogPSBuZXcgQ29udGVudFR5cGUodHlwZS50b0xvd2VyQ2FzZSgpKVxuXG4gIC8vIHBhcnNlIHBhcmFtZXRlcnNcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHZhciBrZXlcbiAgICB2YXIgbWF0Y2hcbiAgICB2YXIgdmFsdWVcblxuICAgIFBBUkFNX1JFR0VYUC5sYXN0SW5kZXggPSBpbmRleFxuXG4gICAgd2hpbGUgKChtYXRjaCA9IFBBUkFNX1JFR0VYUC5leGVjKGhlYWRlcikpKSB7XG4gICAgICBpZiAobWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVyIGZvcm1hdCcpXG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAga2V5ID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKVxuICAgICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHF1b3RlcyBhbmQgZXNjYXBlc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAyKVxuICAgICAgICAgIC5yZXBsYWNlKFFFU0NfUkVHRVhQLCAnJDEnKVxuICAgICAgfVxuXG4gICAgICBvYmoucGFyYW1ldGVyc1trZXldID0gdmFsdWVcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT09IGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVyIGZvcm1hdCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEdldCBjb250ZW50LXR5cGUgZnJvbSByZXEvcmVzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldGNvbnRlbnR0eXBlIChvYmopIHtcbiAgdmFyIGhlYWRlclxuXG4gIGlmICh0eXBlb2Ygb2JqLmdldEhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHJlcy1saWtlXG4gICAgaGVhZGVyID0gb2JqLmdldEhlYWRlcignY29udGVudC10eXBlJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqLmhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gcmVxLWxpa2VcbiAgICBoZWFkZXIgPSBvYmouaGVhZGVycyAmJiBvYmouaGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgfVxuXG4gIGlmICh0eXBlb2YgaGVhZGVyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnRlbnQtdHlwZSBoZWFkZXIgaXMgbWlzc2luZyBmcm9tIG9iamVjdCcpXG4gIH1cblxuICByZXR1cm4gaGVhZGVyXG59XG5cbi8qKlxuICogUXVvdGUgYSBzdHJpbmcgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXN0cmluZyAodmFsKSB7XG4gIHZhciBzdHIgPSBTdHJpbmcodmFsKVxuXG4gIC8vIG5vIG5lZWQgdG8gcXVvdGUgdG9rZW5zXG4gIGlmIChUT0tFTl9SRUdFWFAudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0clxuICB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPiAwICYmICFURVhUX1JFR0VYUC50ZXN0KHN0cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZScpXG4gIH1cblxuICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKFFVT1RFX1JFR0VYUCwgJ1xcXFwkMScpICsgJ1wiJ1xufVxuXG4vKipcbiAqIENsYXNzIHRvIHJlcHJlc2VudCBhIGNvbnRlbnQgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvbnRlbnRUeXBlICh0eXBlKSB7XG4gIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgdGhpcy50eXBlID0gdHlwZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/content-type/index.js\n");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzPzNhN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/core-util-is/lib/util.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZXJyb3JMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgIC8vIEFkZGluZyBhbiBlcnJvciBsaXN0ZW5lciBpcyBub3Qgb3B0aW9uYWwgYmVjYXVzZVxuICAgIC8vIGlmIGFuIGVycm9yIGlzIHRocm93biBvbiBhbiBldmVudCBlbWl0dGVyIHdlIGNhbm5vdFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBhY3R1YWwgZXZlbnQgd2UgYXJlIHdhaXRpbmcgd2lsbFxuICAgIC8vIGJlIGZpcmVkLiBUaGUgcmVzdWx0IGNvdWxkIGJlIGEgc2lsZW50IHdheSB0byBjcmVhdGVcbiAgICAvLyBtZW1vcnkgb3IgZmlsZSBkZXNjcmlwdG9yIGxlYWtzLCB3aGljaCBpcyBzb21ldGhpbmdcbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQuXG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/is-typedarray/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-typedarray/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports      = isTypedArray\nisTypedArray.strict = isStrictTypedArray\nisTypedArray.loose  = isLooseTypedArray\n\nvar toString = Object.prototype.toString\nvar names = {\n    '[object Int8Array]': true\n  , '[object Int16Array]': true\n  , '[object Int32Array]': true\n  , '[object Uint8Array]': true\n  , '[object Uint8ClampedArray]': true\n  , '[object Uint16Array]': true\n  , '[object Uint32Array]': true\n  , '[object Float32Array]': true\n  , '[object Float64Array]': true\n}\n\nfunction isTypedArray(arr) {\n  return (\n       isStrictTypedArray(arr)\n    || isLooseTypedArray(arr)\n  )\n}\n\nfunction isStrictTypedArray(arr) {\n  return (\n       arr instanceof Int8Array\n    || arr instanceof Int16Array\n    || arr instanceof Int32Array\n    || arr instanceof Uint8Array\n    || arr instanceof Uint8ClampedArray\n    || arr instanceof Uint16Array\n    || arr instanceof Uint32Array\n    || arr instanceof Float32Array\n    || arr instanceof Float64Array\n  )\n}\n\nfunction isLooseTypedArray(arr) {\n  return names[toString.call(arr)]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtdHlwZWRhcnJheS9pbmRleC5qcz9hOTc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgICAgICA9IGlzVHlwZWRBcnJheVxuaXNUeXBlZEFycmF5LnN0cmljdCA9IGlzU3RyaWN0VHlwZWRBcnJheVxuaXNUeXBlZEFycmF5Lmxvb3NlICA9IGlzTG9vc2VUeXBlZEFycmF5XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBuYW1lcyA9IHtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IHRydWVcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpXG4gICAgfHwgaXNMb29zZVR5cGVkQXJyYXkoYXJyKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBhcnIgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0xvb3NlVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIG5hbWVzW3RvU3RyaW5nLmNhbGwoYXJyKV1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-typedarray/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/media-typer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/media-typer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * media-typer\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * RegExp to match type in RFC 6838\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nvar SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/\nvar TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/\nvar TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/\n\n/**\n * Module exports.\n */\n\nexports.format = format\nexports.parse = parse\nexports.test = test\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var subtype = obj.subtype\n  var suffix = obj.suffix\n  var type = obj.type\n\n  if (!type || !TYPE_NAME_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {\n    throw new TypeError('invalid subtype')\n  }\n\n  // format as type/subtype\n  var string = type + '/' + subtype\n\n  // append +suffix\n  if (suffix) {\n    if (!TYPE_NAME_REGEXP.test(suffix)) {\n      throw new TypeError('invalid suffix')\n    }\n\n    string += '+' + suffix\n  }\n\n  return string\n}\n\n/**\n * Test media type.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction test (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  return TYPE_REGEXP.test(string.toLowerCase())\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var match = TYPE_REGEXP.exec(string.toLowerCase())\n\n  if (!match) {\n    throw new TypeError('invalid media type')\n  }\n\n  var type = match[1]\n  var subtype = match[2]\n  var suffix\n\n  // suffix after last +\n  var index = subtype.lastIndexOf('+')\n  if (index !== -1) {\n    suffix = subtype.substr(index + 1)\n    subtype = subtype.substr(0, index)\n  }\n\n  return new MediaType(type, subtype, suffix)\n}\n\n/**\n * Class for MediaType object.\n * @public\n */\n\nfunction MediaType (type, subtype, suffix) {\n  this.type = type\n  this.subtype = subtype\n  this.suffix = suffix\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVkaWEtdHlwZXIvaW5kZXguanM/NjZiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0EsMkRBQTJELE1BQU07QUFDakUsdURBQXVELE1BQU07QUFDN0QscURBQXFELE1BQU0sb0NBQW9DLE1BQU07O0FBRXJHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL21lZGlhLXR5cGVyL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtZWRpYS10eXBlclxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHR5cGUgaW4gUkZDIDY4MzhcbiAqXG4gKiB0eXBlLW5hbWUgPSByZXN0cmljdGVkLW5hbWVcbiAqIHN1YnR5cGUtbmFtZSA9IHJlc3RyaWN0ZWQtbmFtZVxuICogcmVzdHJpY3RlZC1uYW1lID0gcmVzdHJpY3RlZC1uYW1lLWZpcnN0ICoxMjZyZXN0cmljdGVkLW5hbWUtY2hhcnNcbiAqIHJlc3RyaWN0ZWQtbmFtZS1maXJzdCAgPSBBTFBIQSAvIERJR0lUXG4gKiByZXN0cmljdGVkLW5hbWUtY2hhcnMgID0gQUxQSEEgLyBESUdJVCAvIFwiIVwiIC8gXCIjXCIgL1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiJFwiIC8gXCImXCIgLyBcIi1cIiAvIFwiXlwiIC8gXCJfXCJcbiAqIHJlc3RyaWN0ZWQtbmFtZS1jaGFycyA9LyBcIi5cIiA7IENoYXJhY3RlcnMgYmVmb3JlIGZpcnN0IGRvdCBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBzcGVjaWZ5IGEgZmFjZXQgbmFtZVxuICogcmVzdHJpY3RlZC1uYW1lLWNoYXJzID0vIFwiK1wiIDsgQ2hhcmFjdGVycyBhZnRlciBsYXN0IHBsdXMgYWx3YXlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgc3BlY2lmeSBhIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeFxuICogQUxQSEEgPSAgJXg0MS01QSAvICV4NjEtN0EgICA7IEEtWiAvIGEtelxuICogRElHSVQgPSAgJXgzMC0zOSAgICAgICAgICAgICA7IDAtOVxuICovXG52YXIgU1VCVFlQRV9OQU1FX1JFR0VYUCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLi1dezAsMTI2fSQvXG52YXIgVFlQRV9OQU1FX1JFR0VYUCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9JC9cbnZhciBUWVBFX1JFR0VYUCA9IC9eICooW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9KVxcLyhbQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8uKy1dezAsMTI2fSkgKiQvXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuZXhwb3J0cy50ZXN0ID0gdGVzdFxuXG4vKipcbiAqIEZvcm1hdCBvYmplY3QgdG8gbWVkaWEgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHN1YnR5cGUgPSBvYmouc3VidHlwZVxuICB2YXIgc3VmZml4ID0gb2JqLnN1ZmZpeFxuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgaWYgKCF0eXBlIHx8ICFUWVBFX05BTUVfUkVHRVhQLnRlc3QodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICB9XG5cbiAgaWYgKCFzdWJ0eXBlIHx8ICFTVUJUWVBFX05BTUVfUkVHRVhQLnRlc3Qoc3VidHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1YnR5cGUnKVxuICB9XG5cbiAgLy8gZm9ybWF0IGFzIHR5cGUvc3VidHlwZVxuICB2YXIgc3RyaW5nID0gdHlwZSArICcvJyArIHN1YnR5cGVcblxuICAvLyBhcHBlbmQgK3N1ZmZpeFxuICBpZiAoc3VmZml4KSB7XG4gICAgaWYgKCFUWVBFX05BTUVfUkVHRVhQLnRlc3Qoc3VmZml4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWZmaXgnKVxuICAgIH1cblxuICAgIHN0cmluZyArPSAnKycgKyBzdWZmaXhcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUZXN0IG1lZGlhIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7b2JqZWN0fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHRlc3QgKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgcmV0dXJuIFRZUEVfUkVHRVhQLnRlc3Qoc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG59XG5cbi8qKlxuICogUGFyc2UgbWVkaWEgdHlwZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7b2JqZWN0fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlIChzdHJpbmcpIHtcbiAgaWYgKCFzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyaW5nIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nJylcbiAgfVxuXG4gIHZhciBtYXRjaCA9IFRZUEVfUkVHRVhQLmV4ZWMoc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbWVkaWEgdHlwZScpXG4gIH1cblxuICB2YXIgdHlwZSA9IG1hdGNoWzFdXG4gIHZhciBzdWJ0eXBlID0gbWF0Y2hbMl1cbiAgdmFyIHN1ZmZpeFxuXG4gIC8vIHN1ZmZpeCBhZnRlciBsYXN0ICtcbiAgdmFyIGluZGV4ID0gc3VidHlwZS5sYXN0SW5kZXhPZignKycpXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBzdWZmaXggPSBzdWJ0eXBlLnN1YnN0cihpbmRleCArIDEpXG4gICAgc3VidHlwZSA9IHN1YnR5cGUuc3Vic3RyKDAsIGluZGV4KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNZWRpYVR5cGUodHlwZSwgc3VidHlwZSwgc3VmZml4KVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBNZWRpYVR5cGUgb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1lZGlhVHlwZSAodHlwZSwgc3VidHlwZSwgc3VmZml4KSB7XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5zdWJ0eXBlID0gc3VidHlwZVxuICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/media-typer/index.js\n");

/***/ }),

/***/ "./node_modules/music-metadata-browser/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata-browser/lib/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata-browser/node_modules/debug/src/browser.js\");\nconst mm = __webpack_require__(/*! music-metadata/lib/core */ \"./node_modules/music-metadata/lib/core.js\");\nconst readable_web_to_node_stream_1 = __webpack_require__(/*! readable-web-to-node-stream */ \"./node_modules/readable-web-to-node-stream/lib/index.js\");\nconst toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"./node_modules/typedarray-to-buffer/index.js\");\nconst debug = initDebug('music-metadata-browser:main');\nvar core_1 = __webpack_require__(/*! music-metadata/lib/core */ \"./node_modules/music-metadata/lib/core.js\");\nObject.defineProperty(exports, \"parseBuffer\", { enumerable: true, get: function () { return core_1.parseBuffer; } });\nObject.defineProperty(exports, \"parseFromTokenizer\", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });\nObject.defineProperty(exports, \"orderTags\", { enumerable: true, get: function () { return core_1.orderTags; } });\nObject.defineProperty(exports, \"ratingToStars\", { enumerable: true, get: function () { return core_1.ratingToStars; } });\n/**\n * Parse audio Stream\n * @param stream - ReadableStream\n * @param contentType - MIME-Type\n * @param options - Parsing options\n * @returns Metadata\n */\nexports.parseNodeStream = mm.parseStream;\n/**\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n * @param stream - ReadableStream\n * @param fileInfo FileInfo object or MIME-Type\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseReadableStream(stream, fileInfo, options) {\n    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\n    const res = await exports.parseNodeStream(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);\n    await ns.close();\n    return res;\n}\nexports.parseReadableStream = parseReadableStream;\n/**\n * Parse Web API File\n * @param blob - Blob to parse\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseBlob(blob, options) {\n    const buf = await convertBlobToBuffer(blob);\n    const fileInfo = { mimeType: blob.type, size: blob.size };\n    if (blob.name) {\n        fileInfo.path = blob.name;\n    }\n    return mm.parseBuffer(buf, { mimeType: blob.type, size: blob.size }, options);\n}\nexports.parseBlob = parseBlob;\n/**\n * Parse fetched file, using the Web Fetch API\n * @param audioTrackUrl - URL to download the audio track from\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function fetchFromUrl(audioTrackUrl, options) {\n    const response = await fetch(audioTrackUrl);\n    const fileInfo = {\n        size: parseInt(response.headers.get('Content-Length'), 10),\n        mimeType: response.headers.get('Content-Type')\n    };\n    if (response.ok) {\n        if (response.body) {\n            const res = await this.parseReadableStream(response.body, fileInfo, options);\n            debug('Closing HTTP-readable-stream...');\n            if (!response.body.locked) { // Prevent error in Firefox\n                await response.body.cancel();\n            }\n            debug('HTTP-readable-stream closed.');\n            return res;\n        }\n        else {\n            // Fall back on Blob\n            return this.parseBlob(await response.blob(), options);\n        }\n    }\n    else {\n        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\n    }\n}\nexports.fetchFromUrl = fetchFromUrl;\n/**\n * Convert Web API File to Node Buffer\n * @param blob - Web API Blob\n * @returns Metadata\n */\nfunction convertBlobToBuffer(blob) {\n    return new Promise((resolve, reject) => {\n        const fileReader = new FileReader();\n        fileReader.onloadend = event => {\n            let data = event.target.result;\n            if (data instanceof ArrayBuffer) {\n                data = toBuffer(new Uint8Array(event.target.result));\n            }\n            resolve(data);\n        };\n        fileReader.onerror = error => {\n            reject(new Error(error.type));\n        };\n        fileReader.onabort = error => {\n            reject(new Error(error.type));\n        };\n        fileReader.readAsArrayBuffer(blob);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEtYnJvd3Nlci9saWIvaW5kZXguanM/Y2I5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsc0ZBQU87QUFDakMsV0FBVyxtQkFBTyxDQUFDLDBFQUF5QjtBQUM1QyxzQ0FBc0MsbUJBQU8sQ0FBQyw0RkFBNkI7QUFDM0UsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBFQUF5QjtBQUM5QywrQ0FBK0MscUNBQXFDLDJCQUEyQixFQUFFLEVBQUU7QUFDbkgsc0RBQXNELHFDQUFxQyxrQ0FBa0MsRUFBRSxFQUFFO0FBQ2pJLDZDQUE2QyxxQ0FBcUMseUJBQXlCLEVBQUUsRUFBRTtBQUMvRyxpREFBaUQscUNBQXFDLDZCQUE2QixFQUFFLEVBQUU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixxQkFBcUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCLElBQUksb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhLWJyb3dzZXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoRnJvbVVybCA9IGV4cG9ydHMucGFyc2VCbG9iID0gZXhwb3J0cy5wYXJzZVJlYWRhYmxlU3RyZWFtID0gZXhwb3J0cy5wYXJzZU5vZGVTdHJlYW0gPSBleHBvcnRzLnJhdGluZ1RvU3RhcnMgPSBleHBvcnRzLm9yZGVyVGFncyA9IGV4cG9ydHMucGFyc2VGcm9tVG9rZW5pemVyID0gZXhwb3J0cy5wYXJzZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IG1tID0gcmVxdWlyZShcIm11c2ljLW1ldGFkYXRhL2xpYi9jb3JlXCIpO1xuY29uc3QgcmVhZGFibGVfd2ViX3RvX25vZGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtd2ViLXRvLW5vZGUtc3RyZWFtXCIpO1xuY29uc3QgdG9CdWZmZXIgPSByZXF1aXJlKFwidHlwZWRhcnJheS10by1idWZmZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGluaXREZWJ1ZygnbXVzaWMtbWV0YWRhdGEtYnJvd3NlcjptYWluJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIm11c2ljLW1ldGFkYXRhL2xpYi9jb3JlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VCdWZmZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5wYXJzZUJ1ZmZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRnJvbVRva2VuaXplclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLnBhcnNlRnJvbVRva2VuaXplcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9yZGVyVGFnc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLm9yZGVyVGFnczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhdGluZ1RvU3RhcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5yYXRpbmdUb1N0YXJzOyB9IH0pO1xuLyoqXG4gKiBQYXJzZSBhdWRpbyBTdHJlYW1cbiAqIEBwYXJhbSBzdHJlYW0gLSBSZWFkYWJsZVN0cmVhbVxuICogQHBhcmFtIGNvbnRlbnRUeXBlIC0gTUlNRS1UeXBlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqL1xuZXhwb3J0cy5wYXJzZU5vZGVTdHJlYW0gPSBtbS5wYXJzZVN0cmVhbTtcbi8qKlxuICogUGFyc2UgV2ViIEFQSSBSZWFkYWJsZVN0cmVhbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtXG4gKiBAcGFyYW0gc3RyZWFtIC0gUmVhZGFibGVTdHJlYW1cbiAqIEBwYXJhbSBmaWxlSW5mbyBGaWxlSW5mbyBvYmplY3Qgb3IgTUlNRS1UeXBlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZWFkYWJsZVN0cmVhbShzdHJlYW0sIGZpbGVJbmZvLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbnMgPSBuZXcgcmVhZGFibGVfd2ViX3RvX25vZGVfc3RyZWFtXzEuUmVhZGFibGVXZWJUb05vZGVTdHJlYW0oc3RyZWFtKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBleHBvcnRzLnBhcnNlTm9kZVN0cmVhbShucywgdHlwZW9mIGZpbGVJbmZvID09PSAnc3RyaW5nJyA/IHsgbWltZVR5cGU6IGZpbGVJbmZvIH0gOiBmaWxlSW5mbywgb3B0aW9ucyk7XG4gICAgYXdhaXQgbnMuY2xvc2UoKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wYXJzZVJlYWRhYmxlU3RyZWFtID0gcGFyc2VSZWFkYWJsZVN0cmVhbTtcbi8qKlxuICogUGFyc2UgV2ViIEFQSSBGaWxlXG4gKiBAcGFyYW0gYmxvYiAtIEJsb2IgdG8gcGFyc2VcbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUJsb2IoYmxvYiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IGNvbnZlcnRCbG9iVG9CdWZmZXIoYmxvYik7XG4gICAgY29uc3QgZmlsZUluZm8gPSB7IG1pbWVUeXBlOiBibG9iLnR5cGUsIHNpemU6IGJsb2Iuc2l6ZSB9O1xuICAgIGlmIChibG9iLm5hbWUpIHtcbiAgICAgICAgZmlsZUluZm8ucGF0aCA9IGJsb2IubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG1tLnBhcnNlQnVmZmVyKGJ1ZiwgeyBtaW1lVHlwZTogYmxvYi50eXBlLCBzaXplOiBibG9iLnNpemUgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhcnNlQmxvYiA9IHBhcnNlQmxvYjtcbi8qKlxuICogUGFyc2UgZmV0Y2hlZCBmaWxlLCB1c2luZyB0aGUgV2ViIEZldGNoIEFQSVxuICogQHBhcmFtIGF1ZGlvVHJhY2tVcmwgLSBVUkwgdG8gZG93bmxvYWQgdGhlIGF1ZGlvIHRyYWNrIGZyb21cbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEZyb21VcmwoYXVkaW9UcmFja1VybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXVkaW9UcmFja1VybCk7XG4gICAgY29uc3QgZmlsZUluZm8gPSB7XG4gICAgICAgIHNpemU6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpLCAxMCksXG4gICAgICAgIG1pbWVUeXBlOiByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJylcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wYXJzZVJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLmJvZHksIGZpbGVJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlYnVnKCdDbG9zaW5nIEhUVFAtcmVhZGFibGUtc3RyZWFtLi4uJyk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkubG9ja2VkKSB7IC8vIFByZXZlbnQgZXJyb3IgaW4gRmlyZWZveFxuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3BvbnNlLmJvZHkuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZygnSFRUUC1yZWFkYWJsZS1zdHJlYW0gY2xvc2VkLicpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayBvbiBCbG9iXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2IoYXdhaXQgcmVzcG9uc2UuYmxvYigpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yIHN0YXR1cz0ke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG59XG5leHBvcnRzLmZldGNoRnJvbVVybCA9IGZldGNoRnJvbVVybDtcbi8qKlxuICogQ29udmVydCBXZWIgQVBJIEZpbGUgdG8gTm9kZSBCdWZmZXJcbiAqIEBwYXJhbSBibG9iIC0gV2ViIEFQSSBCbG9iXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxuICovXG5mdW5jdGlvbiBjb252ZXJ0QmxvYlRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgZmlsZVJlYWRlci5vbmxvYWRlbmQgPSBldmVudCA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRvQnVmZmVyKG5ldyBVaW50OEFycmF5KGV2ZW50LnRhcmdldC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IudHlwZSkpO1xuICAgICAgICB9O1xuICAgICAgICBmaWxlUmVhZGVyLm9uYWJvcnQgPSBlcnJvciA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yLnR5cGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata-browser/lib/index.js\n");

/***/ }),

/***/ "./node_modules/music-metadata-browser/node_modules/debug/src/browser.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/music-metadata-browser/node_modules/debug/src/browser.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/music-metadata-browser/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEtYnJvd3Nlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MDZkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBVTs7QUFFbkMsT0FBTyxXQUFXOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS1icm93c2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdHJldHVybiB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcblx0XHRjb25zb2xlLmxvZyAmJlxuXHRcdGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata-browser/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata-browser/node_modules/debug/src/common.js":
/*!******************************************************************************!*\
  !*** ./node_modules/music-metadata-browser/node_modules/debug/src/common.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/music-metadata-browser/node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEtYnJvd3Nlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz83NDU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBFQUFJOztBQUVwQztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEtYnJvd3Nlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cblx0Ki9cblx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRcdC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcblxuXHRcdC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata-browser/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/music-metadata-browser/node_modules/ms/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata-browser/node_modules/ms/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEtYnJvd3Nlci9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/YWVkYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS1icm93c2VyL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata-browser/node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ParserFactory.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ParserFactory.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserFactory = exports.parseHttpContentType = void 0;\nconst FileType = __webpack_require__(/*! file-type/core */ \"./node_modules/music-metadata/node_modules/file-type/core.js\");\nconst ContentType = __webpack_require__(/*! content-type */ \"./node_modules/content-type/index.js\");\nconst MimeType = __webpack_require__(/*! media-typer */ \"./node_modules/media-typer/index.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst MetadataCollector_1 = __webpack_require__(/*! ./common/MetadataCollector */ \"./node_modules/music-metadata/lib/common/MetadataCollector.js\");\nconst AiffParser_1 = __webpack_require__(/*! ./aiff/AiffParser */ \"./node_modules/music-metadata/lib/aiff/AiffParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ./apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst AsfParser_1 = __webpack_require__(/*! ./asf/AsfParser */ \"./node_modules/music-metadata/lib/asf/AsfParser.js\");\nconst FlacParser_1 = __webpack_require__(/*! ./flac/FlacParser */ \"./node_modules/music-metadata/lib/flac/FlacParser.js\");\nconst MP4Parser_1 = __webpack_require__(/*! ./mp4/MP4Parser */ \"./node_modules/music-metadata/lib/mp4/MP4Parser.js\");\nconst MpegParser_1 = __webpack_require__(/*! ./mpeg/MpegParser */ \"./node_modules/music-metadata/lib/mpeg/MpegParser.js\");\nconst musepack_1 = __webpack_require__(/*! ./musepack */ \"./node_modules/music-metadata/lib/musepack/index.js\");\nconst OggParser_1 = __webpack_require__(/*! ./ogg/OggParser */ \"./node_modules/music-metadata/lib/ogg/OggParser.js\");\nconst WaveParser_1 = __webpack_require__(/*! ./riff/WaveParser */ \"./node_modules/music-metadata/lib/riff/WaveParser.js\");\nconst WavPackParser_1 = __webpack_require__(/*! ./wavpack/WavPackParser */ \"./node_modules/music-metadata/lib/wavpack/WavPackParser.js\");\nconst DsfParser_1 = __webpack_require__(/*! ./dsf/DsfParser */ \"./node_modules/music-metadata/lib/dsf/DsfParser.js\");\nconst DsdiffParser_1 = __webpack_require__(/*! ./dsdiff/DsdiffParser */ \"./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js\");\nconst MatroskaParser_1 = __webpack_require__(/*! ./matroska/MatroskaParser */ \"./node_modules/music-metadata/lib/matroska/MatroskaParser.js\");\nconst debug = _debug('music-metadata:parser:factory');\nfunction parseHttpContentType(contentType) {\n    const type = ContentType.parse(contentType);\n    const mime = MimeType.parse(type.type);\n    return {\n        type: mime.type,\n        subtype: mime.subtype,\n        suffix: mime.suffix,\n        parameters: type.parameters\n    };\n}\nexports.parseHttpContentType = parseHttpContentType;\nclass ParserFactory {\n    /**\n     * Parse metadata from tokenizer\n     * @param tokenizer - Tokenizer\n     * @param contentType - MIME-type\n     * @param opts - Options\n     * @returns Native metadata\n     */\n    static async parseOnContentType(tokenizer, opts) {\n        const { mimeType, path, url } = await tokenizer.fileInfo;\n        // Resolve parser based on MIME-type or file extension\n        const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n        if (!parserId) {\n            debug('No parser found for MIME-type / extension: ' + mimeType);\n        }\n        return this.parse(tokenizer, parserId, opts);\n    }\n    static async parse(tokenizer, parserId, opts) {\n        if (!parserId) {\n            // Parser could not be determined on MIME-type or extension\n            debug('Guess parser on content...');\n            const buf = Buffer.alloc(4100);\n            await tokenizer.peekBuffer(buf, { mayBeLess: true });\n            if (tokenizer.fileInfo.path) {\n                parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n            }\n            if (!parserId) {\n                const guessedType = await FileType.fromBuffer(buf);\n                if (!guessedType) {\n                    throw new Error('Failed to determine audio format');\n                }\n                debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n                if (!parserId) {\n                    throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n                }\n            }\n        }\n        // Parser found, execute parser\n        return this._parse(tokenizer, parserId, opts);\n    }\n    /**\n     * @param filePath - Path, filename or extension to audio file\n     * @return Parser sub-module name\n     */\n    static getParserIdForExtension(filePath) {\n        if (!filePath)\n            return;\n        const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n        switch (extension) {\n            case '.mp2':\n            case '.mp3':\n            case '.m2a':\n            case '.aac': // Assume it is ADTS-container\n                return 'mpeg';\n            case '.ape':\n                return 'apev2';\n            case '.mp4':\n            case '.m4a':\n            case '.m4b':\n            case '.m4pa':\n            case '.m4v':\n            case '.m4r':\n            case '.3gp':\n                return 'mp4';\n            case '.wma':\n            case '.wmv':\n            case '.asf':\n                return 'asf';\n            case '.flac':\n                return 'flac';\n            case '.ogg':\n            case '.ogv':\n            case '.oga':\n            case '.ogm':\n            case '.ogx':\n            case '.opus': // recommended filename extension for Ogg Opus\n            case '.spx': // recommended filename extension for Ogg Speex\n                return 'ogg';\n            case '.aif':\n            case '.aiff':\n            case '.aifc':\n                return 'aiff';\n            case '.wav':\n                return 'riff';\n            case '.wv':\n            case '.wvp':\n                return 'wavpack';\n            case '.mpc':\n                return 'musepack';\n            case '.dsf':\n                return 'dsf';\n            case '.dff':\n                return 'dsdiff';\n            case '.mka':\n            case '.mkv':\n            case '.mk3d':\n            case '.mks':\n            case '.webm':\n                return 'matroska';\n        }\n    }\n    static async loadParser(moduleName) {\n        switch (moduleName) {\n            case 'aiff': return new AiffParser_1.AIFFParser();\n            case 'apev2': return new APEv2Parser_1.APEv2Parser();\n            case 'asf': return new AsfParser_1.AsfParser();\n            case 'dsf': return new DsfParser_1.DsfParser();\n            case 'dsdiff': return new DsdiffParser_1.DsdiffParser();\n            case 'flac': return new FlacParser_1.FlacParser();\n            case 'mp4': return new MP4Parser_1.MP4Parser();\n            case 'mpeg': return new MpegParser_1.MpegParser();\n            case 'musepack': return new musepack_1.default();\n            case 'ogg': return new OggParser_1.OggParser();\n            case 'riff': return new WaveParser_1.WaveParser();\n            case 'wavpack': return new WavPackParser_1.WavPackParser();\n            case 'matroska': return new MatroskaParser_1.MatroskaParser();\n            default:\n                throw new Error(`Unknown parser type: ${moduleName}`);\n        }\n    }\n    static async _parse(tokenizer, parserId, opts = {}) {\n        // Parser found, execute parser\n        const parser = await ParserFactory.loadParser(parserId);\n        const metadata = new MetadataCollector_1.MetadataCollector(opts);\n        await parser.init(metadata, tokenizer, opts).parse();\n        return metadata.toCommonMetadata();\n    }\n    static getExtension(fname) {\n        const i = fname.lastIndexOf('.');\n        return i === -1 ? '' : fname.slice(i);\n    }\n    /**\n     * @param httpContentType - HTTP Content-Type, extension, path or filename\n     * @returns Parser sub-module name\n     */\n    static getParserIdForMimeType(httpContentType) {\n        let mime;\n        try {\n            mime = parseHttpContentType(httpContentType);\n        }\n        catch (err) {\n            debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n            return;\n        }\n        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n        switch (mime.type) {\n            case 'audio':\n                switch (subType) {\n                    case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n                    case 'mpeg':\n                        return 'mpeg'; // ToDo: handle ID1 header as well\n                    case 'flac':\n                        return 'flac';\n                    case 'ape':\n                    case 'monkeys-audio':\n                        return 'apev2';\n                    case 'mp4':\n                    case 'aac':\n                    case 'aacp':\n                    case 'm4a':\n                        return 'mp4';\n                    case 'ogg': // RFC 7845\n                    case 'opus': // RFC 6716\n                    case 'speex': // RFC 5574\n                        return 'ogg';\n                    case 'ms-wma':\n                    case 'ms-wmv':\n                    case 'ms-asf':\n                        return 'asf';\n                    case 'aiff':\n                    case 'aif':\n                    case 'aifc':\n                        return 'aiff';\n                    case 'vnd.wave':\n                    case 'wav':\n                    case 'wave':\n                        return 'riff';\n                    case 'wavpack':\n                        return 'wavpack';\n                    case 'musepack':\n                        return 'musepack';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                    case 'dsf':\n                        return 'dsf';\n                }\n                break;\n            case 'video':\n                switch (subType) {\n                    case 'ms-asf':\n                    case 'ms-wmv':\n                        return 'asf';\n                    case 'm4v':\n                    case 'mp4':\n                        return 'mp4';\n                    case 'ogg':\n                        return 'ogg';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                }\n                break;\n            case 'application':\n                switch (subType) {\n                    case 'vnd.ms-asf':\n                        return 'asf';\n                    case 'ogg':\n                        return 'ogg';\n                }\n                break;\n        }\n    }\n}\nexports.ParserFactory = ParserFactory;\n//# sourceMappingURL=ParserFactory.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL1BhcnNlckZhY3RvcnkuanM/MmQ3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLDBEQUFjO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFhO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyw4RUFBTztBQUM5Qiw0QkFBNEIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDaEUscUJBQXFCLG1CQUFPLENBQUMsK0VBQW1CO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBaUI7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsK0VBQW1CO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLDJFQUFpQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsMkVBQWlCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLCtFQUFtQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBeUI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsMkVBQWlCO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLHVGQUF1QjtBQUN0RCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQixjQUFjLGdCQUFnQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL1BhcnNlckZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VyRmFjdG9yeSA9IGV4cG9ydHMucGFyc2VIdHRwQ29udGVudFR5cGUgPSB2b2lkIDA7XG5jb25zdCBGaWxlVHlwZSA9IHJlcXVpcmUoXCJmaWxlLXR5cGUvY29yZVwiKTtcbmNvbnN0IENvbnRlbnRUeXBlID0gcmVxdWlyZShcImNvbnRlbnQtdHlwZVwiKTtcbmNvbnN0IE1pbWVUeXBlID0gcmVxdWlyZShcIm1lZGlhLXR5cGVyXCIpO1xuY29uc3QgX2RlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgTWV0YWRhdGFDb2xsZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9NZXRhZGF0YUNvbGxlY3RvclwiKTtcbmNvbnN0IEFpZmZQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2FpZmYvQWlmZlBhcnNlclwiKTtcbmNvbnN0IEFQRXYyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IEFzZlBhcnNlcl8xID0gcmVxdWlyZShcIi4vYXNmL0FzZlBhcnNlclwiKTtcbmNvbnN0IEZsYWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2ZsYWMvRmxhY1BhcnNlclwiKTtcbmNvbnN0IE1QNFBhcnNlcl8xID0gcmVxdWlyZShcIi4vbXA0L01QNFBhcnNlclwiKTtcbmNvbnN0IE1wZWdQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL21wZWcvTXBlZ1BhcnNlclwiKTtcbmNvbnN0IG11c2VwYWNrXzEgPSByZXF1aXJlKFwiLi9tdXNlcGFja1wiKTtcbmNvbnN0IE9nZ1BhcnNlcl8xID0gcmVxdWlyZShcIi4vb2dnL09nZ1BhcnNlclwiKTtcbmNvbnN0IFdhdmVQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3JpZmYvV2F2ZVBhcnNlclwiKTtcbmNvbnN0IFdhdlBhY2tQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3dhdnBhY2svV2F2UGFja1BhcnNlclwiKTtcbmNvbnN0IERzZlBhcnNlcl8xID0gcmVxdWlyZShcIi4vZHNmL0RzZlBhcnNlclwiKTtcbmNvbnN0IERzZGlmZlBhcnNlcl8xID0gcmVxdWlyZShcIi4vZHNkaWZmL0RzZGlmZlBhcnNlclwiKTtcbmNvbnN0IE1hdHJvc2thUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9tYXRyb3NrYS9NYXRyb3NrYVBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6ZmFjdG9yeScpO1xuZnVuY3Rpb24gcGFyc2VIdHRwQ29udGVudFR5cGUoY29udGVudFR5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gQ29udGVudFR5cGUucGFyc2UoY29udGVudFR5cGUpO1xuICAgIGNvbnN0IG1pbWUgPSBNaW1lVHlwZS5wYXJzZSh0eXBlLnR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IG1pbWUudHlwZSxcbiAgICAgICAgc3VidHlwZTogbWltZS5zdWJ0eXBlLFxuICAgICAgICBzdWZmaXg6IG1pbWUuc3VmZml4LFxuICAgICAgICBwYXJhbWV0ZXJzOiB0eXBlLnBhcmFtZXRlcnNcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUh0dHBDb250ZW50VHlwZSA9IHBhcnNlSHR0cENvbnRlbnRUeXBlO1xuY2xhc3MgUGFyc2VyRmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogUGFyc2UgbWV0YWRhdGEgZnJvbSB0b2tlbml6ZXJcbiAgICAgKiBAcGFyYW0gdG9rZW5pemVyIC0gVG9rZW5pemVyXG4gICAgICogQHBhcmFtIGNvbnRlbnRUeXBlIC0gTUlNRS10eXBlXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zXG4gICAgICogQHJldHVybnMgTmF0aXZlIG1ldGFkYXRhXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHBhcnNlT25Db250ZW50VHlwZSh0b2tlbml6ZXIsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBtaW1lVHlwZSwgcGF0aCwgdXJsIH0gPSBhd2FpdCB0b2tlbml6ZXIuZmlsZUluZm87XG4gICAgICAgIC8vIFJlc29sdmUgcGFyc2VyIGJhc2VkIG9uIE1JTUUtdHlwZSBvciBmaWxlIGV4dGVuc2lvblxuICAgICAgICBjb25zdCBwYXJzZXJJZCA9IFBhcnNlckZhY3RvcnkuZ2V0UGFyc2VySWRGb3JNaW1lVHlwZShtaW1lVHlwZSkgfHwgUGFyc2VyRmFjdG9yeS5nZXRQYXJzZXJJZEZvckV4dGVuc2lvbihwYXRoKSB8fCBQYXJzZXJGYWN0b3J5LmdldFBhcnNlcklkRm9yRXh0ZW5zaW9uKHVybCk7XG4gICAgICAgIGlmICghcGFyc2VySWQpIHtcbiAgICAgICAgICAgIGRlYnVnKCdObyBwYXJzZXIgZm91bmQgZm9yIE1JTUUtdHlwZSAvIGV4dGVuc2lvbjogJyArIG1pbWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSh0b2tlbml6ZXIsIHBhcnNlcklkLCBvcHRzKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHBhcnNlKHRva2VuaXplciwgcGFyc2VySWQsIG9wdHMpIHtcbiAgICAgICAgaWYgKCFwYXJzZXJJZCkge1xuICAgICAgICAgICAgLy8gUGFyc2VyIGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkIG9uIE1JTUUtdHlwZSBvciBleHRlbnNpb25cbiAgICAgICAgICAgIGRlYnVnKCdHdWVzcyBwYXJzZXIgb24gY29udGVudC4uLicpO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDQxMDApO1xuICAgICAgICAgICAgYXdhaXQgdG9rZW5pemVyLnBlZWtCdWZmZXIoYnVmLCB7IG1heUJlTGVzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuZmlsZUluZm8ucGF0aCkge1xuICAgICAgICAgICAgICAgIHBhcnNlcklkID0gdGhpcy5nZXRQYXJzZXJJZEZvckV4dGVuc2lvbih0b2tlbml6ZXIuZmlsZUluZm8ucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlcklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3Vlc3NlZFR5cGUgPSBhd2FpdCBGaWxlVHlwZS5mcm9tQnVmZmVyKGJ1Zik7XG4gICAgICAgICAgICAgICAgaWYgKCFndWVzc2VkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZXRlcm1pbmUgYXVkaW8gZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKGBHdWVzc2VkIGZpbGUgdHlwZSBpcyBtaW1lPSR7Z3Vlc3NlZFR5cGUubWltZX0sIGV4dGVuc2lvbj0ke2d1ZXNzZWRUeXBlLmV4dH1gKTtcbiAgICAgICAgICAgICAgICBwYXJzZXJJZCA9IFBhcnNlckZhY3RvcnkuZ2V0UGFyc2VySWRGb3JNaW1lVHlwZShndWVzc2VkVHlwZS5taW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR3Vlc3NlZCBNSU1FLXR5cGUgbm90IHN1cHBvcnRlZDogJyArIGd1ZXNzZWRUeXBlLm1pbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZXIgZm91bmQsIGV4ZWN1dGUgcGFyc2VyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZSh0b2tlbml6ZXIsIHBhcnNlcklkLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIC0gUGF0aCwgZmlsZW5hbWUgb3IgZXh0ZW5zaW9uIHRvIGF1ZGlvIGZpbGVcbiAgICAgKiBAcmV0dXJuIFBhcnNlciBzdWItbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGFyc2VySWRGb3JFeHRlbnNpb24oZmlsZVBhdGgpIHtcbiAgICAgICAgaWYgKCFmaWxlUGF0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb24oZmlsZVBhdGgpLnRvTG9jYWxlTG93ZXJDYXNlKCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcubXAyJzpcbiAgICAgICAgICAgIGNhc2UgJy5tcDMnOlxuICAgICAgICAgICAgY2FzZSAnLm0yYSc6XG4gICAgICAgICAgICBjYXNlICcuYWFjJzogLy8gQXNzdW1lIGl0IGlzIEFEVFMtY29udGFpbmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdtcGVnJztcbiAgICAgICAgICAgIGNhc2UgJy5hcGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBldjInO1xuICAgICAgICAgICAgY2FzZSAnLm1wNCc6XG4gICAgICAgICAgICBjYXNlICcubTRhJzpcbiAgICAgICAgICAgIGNhc2UgJy5tNGInOlxuICAgICAgICAgICAgY2FzZSAnLm00cGEnOlxuICAgICAgICAgICAgY2FzZSAnLm00dic6XG4gICAgICAgICAgICBjYXNlICcubTRyJzpcbiAgICAgICAgICAgIGNhc2UgJy4zZ3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbXA0JztcbiAgICAgICAgICAgIGNhc2UgJy53bWEnOlxuICAgICAgICAgICAgY2FzZSAnLndtdic6XG4gICAgICAgICAgICBjYXNlICcuYXNmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FzZic7XG4gICAgICAgICAgICBjYXNlICcuZmxhYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbGFjJztcbiAgICAgICAgICAgIGNhc2UgJy5vZ2cnOlxuICAgICAgICAgICAgY2FzZSAnLm9ndic6XG4gICAgICAgICAgICBjYXNlICcub2dhJzpcbiAgICAgICAgICAgIGNhc2UgJy5vZ20nOlxuICAgICAgICAgICAgY2FzZSAnLm9neCc6XG4gICAgICAgICAgICBjYXNlICcub3B1cyc6IC8vIHJlY29tbWVuZGVkIGZpbGVuYW1lIGV4dGVuc2lvbiBmb3IgT2dnIE9wdXNcbiAgICAgICAgICAgIGNhc2UgJy5zcHgnOiAvLyByZWNvbW1lbmRlZCBmaWxlbmFtZSBleHRlbnNpb24gZm9yIE9nZyBTcGVleFxuICAgICAgICAgICAgICAgIHJldHVybiAnb2dnJztcbiAgICAgICAgICAgIGNhc2UgJy5haWYnOlxuICAgICAgICAgICAgY2FzZSAnLmFpZmYnOlxuICAgICAgICAgICAgY2FzZSAnLmFpZmMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYWlmZic7XG4gICAgICAgICAgICBjYXNlICcud2F2JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZmYnO1xuICAgICAgICAgICAgY2FzZSAnLnd2JzpcbiAgICAgICAgICAgIGNhc2UgJy53dnAnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnd2F2cGFjayc7XG4gICAgICAgICAgICBjYXNlICcubXBjJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ211c2VwYWNrJztcbiAgICAgICAgICAgIGNhc2UgJy5kc2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZHNmJztcbiAgICAgICAgICAgIGNhc2UgJy5kZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZHNkaWZmJztcbiAgICAgICAgICAgIGNhc2UgJy5ta2EnOlxuICAgICAgICAgICAgY2FzZSAnLm1rdic6XG4gICAgICAgICAgICBjYXNlICcubWszZCc6XG4gICAgICAgICAgICBjYXNlICcubWtzJzpcbiAgICAgICAgICAgIGNhc2UgJy53ZWJtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21hdHJvc2thJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbG9hZFBhcnNlcihtb2R1bGVOYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnYWlmZic6IHJldHVybiBuZXcgQWlmZlBhcnNlcl8xLkFJRkZQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwZXYyJzogcmV0dXJuIG5ldyBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdhc2YnOiByZXR1cm4gbmV3IEFzZlBhcnNlcl8xLkFzZlBhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAnZHNmJzogcmV0dXJuIG5ldyBEc2ZQYXJzZXJfMS5Ec2ZQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RzZGlmZic6IHJldHVybiBuZXcgRHNkaWZmUGFyc2VyXzEuRHNkaWZmUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdmbGFjJzogcmV0dXJuIG5ldyBGbGFjUGFyc2VyXzEuRmxhY1BhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAnbXA0JzogcmV0dXJuIG5ldyBNUDRQYXJzZXJfMS5NUDRQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ21wZWcnOiByZXR1cm4gbmV3IE1wZWdQYXJzZXJfMS5NcGVnUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdtdXNlcGFjayc6IHJldHVybiBuZXcgbXVzZXBhY2tfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICBjYXNlICdvZ2cnOiByZXR1cm4gbmV3IE9nZ1BhcnNlcl8xLk9nZ1BhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAncmlmZic6IHJldHVybiBuZXcgV2F2ZVBhcnNlcl8xLldhdmVQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3dhdnBhY2snOiByZXR1cm4gbmV3IFdhdlBhY2tQYXJzZXJfMS5XYXZQYWNrUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdtYXRyb3NrYSc6IHJldHVybiBuZXcgTWF0cm9za2FQYXJzZXJfMS5NYXRyb3NrYVBhcnNlcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyc2VyIHR5cGU6ICR7bW9kdWxlTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgX3BhcnNlKHRva2VuaXplciwgcGFyc2VySWQsIG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBQYXJzZXIgZm91bmQsIGV4ZWN1dGUgcGFyc2VyXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IFBhcnNlckZhY3RvcnkubG9hZFBhcnNlcihwYXJzZXJJZCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhQ29sbGVjdG9yXzEuTWV0YWRhdGFDb2xsZWN0b3Iob3B0cyk7XG4gICAgICAgIGF3YWl0IHBhcnNlci5pbml0KG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdHMpLnBhcnNlKCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS50b0NvbW1vbk1ldGFkYXRhKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFeHRlbnNpb24oZm5hbWUpIHtcbiAgICAgICAgY29uc3QgaSA9IGZuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/ICcnIDogZm5hbWUuc2xpY2UoaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBodHRwQ29udGVudFR5cGUgLSBIVFRQIENvbnRlbnQtVHlwZSwgZXh0ZW5zaW9uLCBwYXRoIG9yIGZpbGVuYW1lXG4gICAgICogQHJldHVybnMgUGFyc2VyIHN1Yi1tb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXJzZXJJZEZvck1pbWVUeXBlKGh0dHBDb250ZW50VHlwZSkge1xuICAgICAgICBsZXQgbWltZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1pbWUgPSBwYXJzZUh0dHBDb250ZW50VHlwZShodHRwQ29udGVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKGBJbnZhbGlkIEhUVFAgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZTogJHtodHRwQ29udGVudFR5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViVHlwZSA9IG1pbWUuc3VidHlwZS5pbmRleE9mKCd4LScpID09PSAwID8gbWltZS5zdWJ0eXBlLnN1YnN0cmluZygyKSA6IG1pbWUuc3VidHlwZTtcbiAgICAgICAgc3dpdGNoIChtaW1lLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1YlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzogLy8gSW5jb3JyZWN0IE1JTUUtdHlwZSwgQ2hyb21lLCBpbiBXZWIgQVBJIEZpbGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wZWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtcGVnJzsgLy8gVG9EbzogaGFuZGxlIElEMSBoZWFkZXIgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmbGFjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxhYyc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FwZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vbmtleXMtYXVkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcGV2Mic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wNCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FhY3AnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtNGEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtcDQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvZ2cnOiAvLyBSRkMgNzg0NVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdvcHVzJzogLy8gUkZDIDY3MTZcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BlZXgnOiAvLyBSRkMgNTU3NFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvZ2cnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcy13bWEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcy13bXYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcy1hc2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhc2YnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhaWZmJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWlmJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWlmYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FpZmYnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2bmQud2F2ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhdmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyaWZmJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2F2cGFjayc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3dhdnBhY2snO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtdXNlcGFjayc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ211c2VwYWNrJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF0cm9za2EnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWF0cm9za2EnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkc2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkc2YnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1YlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXMtYXNmJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXMtd212JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXNmJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbTR2JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXA0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbXA0JztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnb2dnJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF0cm9za2EnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWF0cm9za2EnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1YlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndm5kLm1zLWFzZic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FzZic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ29nZyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZXJGYWN0b3J5ID0gUGFyc2VyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnNlckZhY3RvcnkuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ParserFactory.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/aiff/AiffParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AIFFParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst AiffToken = __webpack_require__(/*! ./AiffToken */ \"./node_modules/music-metadata/lib/aiff/AiffToken.js\");\nconst iff = __webpack_require__(/*! ../iff */ \"./node_modules/music-metadata/lib/iff/index.js\");\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n *  http://www.onicos.com/staff/iz/formats/aiff.html\n *  http://muratnkonar.com/aiff/index.html\n *  http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(iff.Header);\n        if (header.chunkID !== 'FORM')\n            throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        switch (type) {\n            case 'AIFF':\n                this.metadata.setFormat('container', type);\n                this.isCompressed = false;\n                break;\n            case 'AIFC':\n                this.metadata.setFormat('container', 'AIFF-C');\n                this.isCompressed = true;\n                break;\n            default:\n                throw Error('Unsupported AIFF type: ' + type);\n        }\n        this.metadata.setFormat('lossless', !this.isCompressed);\n        try {\n            do {\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\n                debug(`Chunk id=${chunkHeader.chunkID}`);\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n                const bytesRead = await this.readData(chunkHeader);\n                await this.tokenizer.ignore(nextChunk - bytesRead);\n            } while (true);\n        }\n        catch (err) {\n            if (err instanceof strtok3.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async readData(header) {\n        switch (header.chunkID) {\n            case 'COMM': // The Common Chunk\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\n                this.metadata.setFormat('sampleRate', common.sampleRate);\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n                this.metadata.setFormat('codec', common.compressionName);\n                return header.chunkSize;\n            case 'ID3 ': // ID3-meta-data\n                const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                return header.chunkSize;\n            case 'SSND': // Sound Data Chunk\n                if (this.metadata.format.duration) {\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n                }\n                return 0;\n            default:\n                return 0;\n        }\n    }\n}\nexports.AIFFParser = AIFFParser;\n//# sourceMappingURL=AiffParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlBhcnNlci5qcz9kNjZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWtCO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHdFQUFhO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyw4REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYWlmZi9BaWZmUGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFJRkZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHN0cnRvazMgPSByZXF1aXJlKFwic3RydG9rMy9saWIvY29yZVwiKTtcbmNvbnN0IElEM3YyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvSUQzdjJQYXJzZXJcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBBaWZmVG9rZW4gPSByZXF1aXJlKFwiLi9BaWZmVG9rZW5cIik7XG5jb25zdCBpZmYgPSByZXF1aXJlKFwiLi4vaWZmXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjphaWZmJyk7XG4vKipcbiAqIEFJRkYgLSBBdWRpbyBJbnRlcmNoYW5nZSBGaWxlIEZvcm1hdFxuICpcbiAqIFJlZjpcbiAqICBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovZm9ybWF0cy9haWZmLmh0bWxcbiAqICBodHRwOi8vbXVyYXRua29uYXIuY29tL2FpZmYvaW5kZXguaHRtbFxuICogIGh0dHA6Ly93d3ctbW1zcC5lY2UubWNnaWxsLmNhL0RvY3VtZW50cy9BdWRpb0Zvcm1hdHMvQUlGRi9BSUZGLmh0bWxcbiAqL1xuY2xhc3MgQUlGRlBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGFzeW5jIHBhcnNlKCkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oaWZmLkhlYWRlcik7XG4gICAgICAgIGlmIChoZWFkZXIuY2h1bmtJRCAhPT0gJ0ZPUk0nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENodW5rLUlELCBleHBlY3RlZCBcXCdGT1JNXFwnJyk7IC8vIE5vdCBBSUZGIGZvcm1hdFxuICAgICAgICBjb25zdCB0eXBlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdBSUZGJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgdHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0FJRkMnOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnQUlGRi1DJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgQUlGRiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgIXRoaXMuaXNDb21wcmVzc2VkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0hlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihpZmYuSGVhZGVyKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgQ2h1bmsgaWQ9JHtjaHVua0hlYWRlci5jaHVua0lEfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaHVuayA9IDIgKiBNYXRoLnJvdW5kKGNodW5rSGVhZGVyLmNodW5rU2l6ZSAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMucmVhZERhdGEoY2h1bmtIZWFkZXIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShuZXh0Q2h1bmsgLSBieXRlc1JlYWQpO1xuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIHN0cnRvazMuRW5kT2ZTdHJlYW1FcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbmQtb2Ytc3RyZWFtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGEoaGVhZGVyKSB7XG4gICAgICAgIHN3aXRjaCAoaGVhZGVyLmNodW5rSUQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0NPTU0nOiAvLyBUaGUgQ29tbW9uIENodW5rXG4gICAgICAgICAgICAgICAgY29uc3QgY29tbW9uID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBaWZmVG9rZW4uQ29tbW9uKGhlYWRlciwgdGhpcy5pc0NvbXByZXNzZWQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIGNvbW1vbi5zYW1wbGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGNvbW1vbi5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGNvbW1vbi5udW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mU2FtcGxlcycsIGNvbW1vbi5udW1TYW1wbGVGcmFtZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGNvbW1vbi5udW1TYW1wbGVGcmFtZXMgLyBjb21tb24uc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgY29tbW9uLmNvbXByZXNzaW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5jaHVua1NpemU7XG4gICAgICAgICAgICBjYXNlICdJRDMgJzogLy8gSUQzLW1ldGEtZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkM19kYXRhID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5CdWZmZXJUeXBlKGhlYWRlci5jaHVua1NpemUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3QgPSBzdHJ0b2szLmZyb21CdWZmZXIoaWQzX2RhdGEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBJRDN2MlBhcnNlcl8xLklEM3YyUGFyc2VyKCkucGFyc2UodGhpcy5tZXRhZGF0YSwgcnN0LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICAgICAgY2FzZSAnU1NORCc6IC8vIFNvdW5kIERhdGEgQ2h1bmtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogaGVhZGVyLmNodW5rU2l6ZSAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BSUZGUGFyc2VyID0gQUlGRlBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFpZmZQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/aiff/AiffParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/aiff/AiffToken.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffToken.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Common = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nclass Common {\n    constructor(header, isAifc) {\n        this.isAifc = isAifc;\n        const minimumChunkSize = isAifc ? 22 : 18;\n        assert.ok(header.chunkSize >= minimumChunkSize, `COMMON CHUNK size should always be at least ${minimumChunkSize}`);\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value\n        const shift = buf.readUInt16BE(off + 8) - 16398;\n        const baseSampleRate = buf.readUInt16BE(off + 8 + 2);\n        const res = {\n            numChannels: buf.readUInt16BE(off),\n            numSampleFrames: buf.readUInt32BE(off + 2),\n            sampleSize: buf.readUInt16BE(off + 6),\n            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift\n        };\n        if (this.isAifc) {\n            res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18);\n            if (this.len > 22) {\n                const strLen = buf.readInt8(off + 22);\n                const padding = (strLen + 1) % 2;\n                if (23 + strLen + padding === this.len) {\n                    res.compressionName = new Token.StringType(strLen, 'binary').get(buf, off + 23);\n                }\n                else {\n                    throw new Error('Illegal pstring length');\n                }\n            }\n        }\n        else {\n            res.compressionName = 'PCM';\n        }\n        return res;\n    }\n}\nexports.Common = Common;\n//# sourceMappingURL=AiffToken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlRva2VuLmpzP2RhNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsOEVBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGlCQUFpQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlRva2VuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbiA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jbGFzcyBDb21tb24ge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlciwgaXNBaWZjKSB7XG4gICAgICAgIHRoaXMuaXNBaWZjID0gaXNBaWZjO1xuICAgICAgICBjb25zdCBtaW5pbXVtQ2h1bmtTaXplID0gaXNBaWZjID8gMjIgOiAxODtcbiAgICAgICAgYXNzZXJ0Lm9rKGhlYWRlci5jaHVua1NpemUgPj0gbWluaW11bUNodW5rU2l6ZSwgYENPTU1PTiBDSFVOSyBzaXplIHNob3VsZCBhbHdheXMgYmUgYXQgbGVhc3QgJHttaW5pbXVtQ2h1bmtTaXplfWApO1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5jaHVua1NpemU7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vY3ljbGluZzc0LmNvbS9mb3J1bXMvYWlmZnMtODAtYml0LXNhbXBsZS1yYXRlLXZhbHVlXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gYnVmLnJlYWRVSW50MTZCRShvZmYgKyA4KSAtIDE2Mzk4O1xuICAgICAgICBjb25zdCBiYXNlU2FtcGxlUmF0ZSA9IGJ1Zi5yZWFkVUludDE2QkUob2ZmICsgOCArIDIpO1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBudW1DaGFubmVsczogYnVmLnJlYWRVSW50MTZCRShvZmYpLFxuICAgICAgICAgICAgbnVtU2FtcGxlRnJhbWVzOiBidWYucmVhZFVJbnQzMkJFKG9mZiArIDIpLFxuICAgICAgICAgICAgc2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MTZCRShvZmYgKyA2KSxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNoaWZ0IDwgMCA/IGJhc2VTYW1wbGVSYXRlID4+IE1hdGguYWJzKHNoaWZ0KSA6IGJhc2VTYW1wbGVSYXRlIDw8IHNoaWZ0XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzQWlmYykge1xuICAgICAgICAgICAgcmVzLmNvbXByZXNzaW9uVHlwZSA9IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiArIDE4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbiA+IDIyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyTGVuID0gYnVmLnJlYWRJbnQ4KG9mZiArIDIyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gKHN0ckxlbiArIDEpICUgMjtcbiAgICAgICAgICAgICAgICBpZiAoMjMgKyBzdHJMZW4gKyBwYWRkaW5nID09PSB0aGlzLmxlbikge1xuICAgICAgICAgICAgICAgICAgICByZXMuY29tcHJlc3Npb25OYW1lID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoc3RyTGVuLCAnYmluYXJ5JykuZ2V0KGJ1Ziwgb2ZmICsgMjMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzLmNvbXByZXNzaW9uTmFtZSA9ICdQQ00nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tb24gPSBDb21tb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BaWZmVG9rZW4uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/aiff/AiffToken.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/apev2/APEv2Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2Parser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APEv2Parser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Token_1 = __webpack_require__(/*! ./APEv2Token */ \"./node_modules/music-metadata/lib/apev2/APEv2Token.js\");\nconst token_types_1 = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param reader\n     * @param offset\n     */\n    static async findApeFooterOffset(reader, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            debug(`APE footer header at offset=${offset}`);\n            return { footer: tagFooter, offset: offset - tagFooter.size };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n        assert.strictEqual(footer.ID, preamble, 'APEv2 Footer preamble');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n            debug(`No APEv2 header found, end-of-file reached`);\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n            return this.parseTags(footer);\n        }\n        else {\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n            if (this.tokenizer.fileInfo.size) {\n                // Try to read the APEv2 header using just the footer-header\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n                const buffer = Buffer.alloc(remaining);\n                await this.tokenizer.readBuffer(buffer);\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n            }\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n        assert.strictEqual(descriptor.ID, 'MAC ', 'descriptor.ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = Util_1.default.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 textstring\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    /*jshint loopfunc:true */\n                    for (const val of values) {\n                        this.metadata.addTag(tagFormat, key, val);\n                    }\n                    break;\n                }\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = Buffer.alloc(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = Util_1.default.findZero(picData, 0, picData.length);\n                        const description = picData.toString('utf8', 0, zero);\n                        const data = Buffer.from(picData.slice(zero + 1));\n                        this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case APEv2Token_1.DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                default:\n                    throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\nexports.APEv2Parser = APEv2Parser;\n//# sourceMappingURL=APEv2Parser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FwZXYyL0FQRXYyUGFyc2VyLmpzPzk2MTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFrQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsOEVBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdFQUFnQjtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsMkVBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsNERBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDBDQUEwQyx3QkFBd0IsU0FBUyxlQUFlO0FBQzFGLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscURBQXFEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw2QkFBNkI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hcGV2Mi9BUEV2MlBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVBFdjJQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBpbml0RGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBzdHJ0b2szID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9VdGlsXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBBUEV2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9BUEV2MlRva2VuXCIpO1xuY29uc3QgdG9rZW5fdHlwZXNfMSA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6QVBFdjInKTtcbmNvbnN0IHRhZ0Zvcm1hdCA9ICdBUEV2Mic7XG5jb25zdCBwcmVhbWJsZSA9ICdBUEVUQUdFWCc7XG5jbGFzcyBBUEV2MlBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFwZSA9IHt9O1xuICAgIH1cbiAgICBzdGF0aWMgdHJ5UGFyc2VBcGVIZWFkZXIobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcGVQYXJzZXIgPSBuZXcgQVBFdjJQYXJzZXIoKTtcbiAgICAgICAgYXBlUGFyc2VyLmluaXQobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhcGVQYXJzZXIudHJ5UGFyc2VBcGVIZWFkZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtZWRpYSBmaWxlIGR1cmF0aW9uXG4gICAgICogQHBhcmFtIGFoIEFwZUhlYWRlclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVEdXJhdGlvbihhaCkge1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBhaC50b3RhbEZyYW1lcyA+IDEgPyBhaC5ibG9ja3NQZXJGcmFtZSAqIChhaC50b3RhbEZyYW1lcyAtIDEpIDogMDtcbiAgICAgICAgZHVyYXRpb24gKz0gYWguZmluYWxGcmFtZUJsb2NrcztcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uIC8gYWguc2FtcGxlUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgQVBFdjEgLyBBUEV2MiBmaXJzdCBmaWVsZCBvZmZzZXRcbiAgICAgKiBAcGFyYW0gcmVhZGVyXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmaW5kQXBlRm9vdGVyT2Zmc2V0KHJlYWRlciwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgQVBFIGZvb3RlciBoZWFkZXIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZVxuICAgICAgICBjb25zdCBhcGVCdWYgPSBCdWZmZXIuYWxsb2MoQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5sZW4pO1xuICAgICAgICBhd2FpdCByZWFkZXIucmFuZG9tUmVhZChhcGVCdWYsIDAsIEFQRXYyVG9rZW5fMS5UYWdGb290ZXIubGVuLCBvZmZzZXQgLSBBUEV2MlRva2VuXzEuVGFnRm9vdGVyLmxlbik7XG4gICAgICAgIGNvbnN0IHRhZ0Zvb3RlciA9IEFQRXYyVG9rZW5fMS5UYWdGb290ZXIuZ2V0KGFwZUJ1ZiwgMCk7XG4gICAgICAgIGlmICh0YWdGb290ZXIuSUQgPT09ICdBUEVUQUdFWCcpIHtcbiAgICAgICAgICAgIGRlYnVnKGBBUEUgZm9vdGVyIGhlYWRlciBhdCBvZmZzZXQ9JHtvZmZzZXR9YCk7XG4gICAgICAgICAgICByZXR1cm4geyBmb290ZXI6IHRhZ0Zvb3Rlciwgb2Zmc2V0OiBvZmZzZXQgLSB0YWdGb290ZXIuc2l6ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVRhZ0Zvb3RlcihtZXRhZGF0YSwgYnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZvb3RlciA9IEFQRXYyVG9rZW5fMS5UYWdGb290ZXIuZ2V0KGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCAtIEFQRXYyVG9rZW5fMS5UYWdGb290ZXIubGVuKTtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGZvb3Rlci5JRCwgcHJlYW1ibGUsICdBUEV2MiBGb290ZXIgcHJlYW1ibGUnKTtcbiAgICAgICAgc3RydG9rMy5mcm9tQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGFwZVBhcnNlciA9IG5ldyBBUEV2MlBhcnNlcigpO1xuICAgICAgICBhcGVQYXJzZXIuaW5pdChtZXRhZGF0YSwgc3RydG9rMy5mcm9tQnVmZmVyKGJ1ZmZlciksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXBlUGFyc2VyLnBhcnNlVGFncyhmb290ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBBUEV2MSAvIEFQRXYyIGhlYWRlciBpZiBoZWFkZXIgc2lnbmF0dXJlIGZvdW5kXG4gICAgICovXG4gICAgYXN5bmMgdHJ5UGFyc2VBcGVIZWFkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplICYmIHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLnRva2VuaXplci5wb3NpdGlvbiA8IEFQRXYyVG9rZW5fMS5UYWdGb290ZXIubGVuKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgTm8gQVBFdjIgaGVhZGVyIGZvdW5kLCBlbmQtb2YtZmlsZSByZWFjaGVkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9vdGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla1Rva2VuKEFQRXYyVG9rZW5fMS5UYWdGb290ZXIpO1xuICAgICAgICBpZiAoZm9vdGVyLklEID09PSBwcmVhbWJsZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKEFQRXYyVG9rZW5fMS5UYWdGb290ZXIubGVuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGFncyhmb290ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoYEFQRXYyIGhlYWRlciBub3QgZm91bmQgYXQgb2Zmc2V0PSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259YCk7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZWFkIHRoZSBBUEV2MiBoZWFkZXIgdXNpbmcganVzdCB0aGUgZm9vdGVyLWhlYWRlclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjsgLy8gVG9EbzogdGFrZSBJRDN2MSBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQRXYyUGFyc2VyLnBhcnNlVGFnRm9vdGVyKHRoaXMubWV0YWRhdGEsIGJ1ZmZlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBUEV2MlRva2VuXzEuRGVzY3JpcHRvclBhcnNlcik7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChkZXNjcmlwdG9yLklELCAnTUFDICcsICdkZXNjcmlwdG9yLklEJyk7XG4gICAgICAgIHRoaXMuYXBlLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICAgICAgICBjb25zdCBsZW5FeHAgPSBkZXNjcmlwdG9yLmRlc2NyaXB0b3JCeXRlcyAtIEFQRXYyVG9rZW5fMS5EZXNjcmlwdG9yUGFyc2VyLmxlbjtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgKGxlbkV4cCA+IDAgPyB0aGlzLnBhcnNlRGVzY3JpcHRvckV4cGFuc2lvbihsZW5FeHApIDogdGhpcy5wYXJzZUhlYWRlcigpKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5mb3J3YXJkQnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy50cnlQYXJzZUFwZUhlYWRlcigpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVRhZ3MoZm9vdGVyKSB7XG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyNTYpOyAvLyBtYXhpbXVtIHRhZyBrZXkgbGVuZ3RoXG4gICAgICAgIGxldCBieXRlc1JlbWFpbmluZyA9IGZvb3Rlci5zaXplIC0gQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5sZW47XG4gICAgICAgIGRlYnVnKGBQYXJzZSBBUEUgdGFncyBhdCBvZmZzZXQ9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn0sIHNpemU9JHtieXRlc1JlbWFpbmluZ31gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb290ZXIuZmllbGRzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChieXRlc1JlbWFpbmluZyA8IEFQRXYyVG9rZW5fMS5UYWdJdGVtSGVhZGVyLmxlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZyhgQVBFdjIgVGFnLWhlYWRlcjogJHtmb290ZXIuZmllbGRzIC0gaX0gaXRlbXMgcmVtYWluaW5nLCBidXQgbm8gbW9yZSB0YWcgZGF0YSB0byByZWFkLmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBBUEV2MiB0YWcgaGFzIHRhZyBpdGVtIGhlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IHRhZ0l0ZW1IZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oQVBFdjJUb2tlbl8xLlRhZ0l0ZW1IZWFkZXIpO1xuICAgICAgICAgICAgYnl0ZXNSZW1haW5pbmcgLT0gQVBFdjJUb2tlbl8xLlRhZ0l0ZW1IZWFkZXIubGVuICsgdGFnSXRlbUhlYWRlci5zaXplO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla0J1ZmZlcihrZXlCdWZmZXIsIHsgbGVuZ3RoOiBNYXRoLm1pbihrZXlCdWZmZXIubGVuZ3RoLCBieXRlc1JlbWFpbmluZykgfSk7XG4gICAgICAgICAgICBsZXQgemVybyA9IFV0aWxfMS5kZWZhdWx0LmZpbmRaZXJvKGtleUJ1ZmZlciwgMCwga2V5QnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IHRva2VuX3R5cGVzXzEuU3RyaW5nVHlwZSh6ZXJvLCAnYXNjaWknKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoMSk7XG4gICAgICAgICAgICBieXRlc1JlbWFpbmluZyAtPSBrZXkubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnSXRlbUhlYWRlci5mbGFncy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQVBFdjJUb2tlbl8xLkRhdGFUeXBlLnRleHRfdXRmODogeyAvLyB1dGYtOCB0ZXh0c3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyB0b2tlbl90eXBlc18xLlN0cmluZ1R5cGUodGFnSXRlbUhlYWRlci5zaXplLCAndXRmOCcpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoL1xceDAwL2cpO1xuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcodGFnRm9ybWF0LCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQVBFdjJUb2tlbl8xLkRhdGFUeXBlLmJpbmFyeTogLy8gYmluYXJ5IChwcm9iYWJseSBhcnR3b3JrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBDb3ZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSh0YWdJdGVtSGVhZGVyLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGljRGF0YSA9IEJ1ZmZlci5hbGxvYyh0YWdJdGVtSGVhZGVyLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihwaWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHplcm8gPSBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhwaWNEYXRhLCAwLCBwaWNEYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHBpY0RhdGEudG9TdHJpbmcoJ3V0ZjgnLCAwLCB6ZXJvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShwaWNEYXRhLnNsaWNlKHplcm8gKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZyh0YWdGb3JtYXQsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQVBFdjJUb2tlbl8xLkRhdGFUeXBlLmV4dGVybmFsX2luZm86XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBJZ25vcmUgZXh0ZXJuYWwgaW5mbyAke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKHRhZ0l0ZW1IZWFkZXIuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhLXR5cGU6ICR7dGFnSXRlbUhlYWRlci5mbGFncy5kYXRhVHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZURlc2NyaXB0b3JFeHBhbnNpb24obGVuRXhwKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShsZW5FeHApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhlYWRlcigpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEFQRXYyVG9rZW5fMS5IZWFkZXIpO1xuICAgICAgICAvLyBUb0RvIGJlZm9yZVxuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsICdNb25rZXlcXCdzIEF1ZGlvJyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRzUGVyU2FtcGxlJywgaGVhZGVyLmJpdHNQZXJTYW1wbGUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGhlYWRlci5zYW1wbGVSYXRlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBoZWFkZXIuY2hhbm5lbCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIEFQRXYyUGFyc2VyLmNhbGN1bGF0ZUR1cmF0aW9uKGhlYWRlcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yd2FyZEJ5dGVzOiB0aGlzLmFwZS5kZXNjcmlwdG9yLnNlZWtUYWJsZUJ5dGVzICsgdGhpcy5hcGUuZGVzY3JpcHRvci5oZWFkZXJEYXRhQnl0ZXMgK1xuICAgICAgICAgICAgICAgIHRoaXMuYXBlLmRlc2NyaXB0b3IuYXBlRnJhbWVEYXRhQnl0ZXMgKyB0aGlzLmFwZS5kZXNjcmlwdG9yLnRlcm1pbmF0aW5nRGF0YUJ5dGVzXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5BUEV2MlBhcnNlciA9IEFQRXYyUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QVBFdjJQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/apev2/APEv2Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APEv2TagMapper = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * ID3v2.2 tag mappings\n */\nconst apev2TagMap = {\n    Title: 'title',\n    Artist: 'artist',\n    Artists: 'artists',\n    'Album Artist': 'albumartist',\n    Album: 'album',\n    Year: 'date',\n    Originalyear: 'originalyear',\n    Originaldate: 'originaldate',\n    Comment: 'comment',\n    Track: 'track',\n    Disc: 'disk',\n    DISCNUMBER: 'disk',\n    Genre: 'genre',\n    'Cover Art (Front)': 'picture',\n    'Cover Art (Back)': 'picture',\n    Composer: 'composer',\n    Lyrics: 'lyrics',\n    ALBUMSORT: 'albumsort',\n    TITLESORT: 'titlesort',\n    WORK: 'work',\n    ARTISTSORT: 'artistsort',\n    ALBUMARTISTSORT: 'albumartistsort',\n    COMPOSERSORT: 'composersort',\n    Lyricist: 'lyricist',\n    Writer: 'writer',\n    Conductor: 'conductor',\n    // 'Performer=artist (instrument)': 'performer:instrument',\n    MixArtist: 'remixer',\n    Arranger: 'arranger',\n    Engineer: 'engineer',\n    Producer: 'producer',\n    DJMixer: 'djmixer',\n    Mixer: 'mixer',\n    Label: 'label',\n    Grouping: 'grouping',\n    Subtitle: 'subtitle',\n    DiscSubtitle: 'discsubtitle',\n    Compilation: 'compilation',\n    BPM: 'bpm',\n    Mood: 'mood',\n    Media: 'media',\n    CatalogNumber: 'catalognumber',\n    MUSICBRAINZ_ALBUMSTATUS: 'releasestatus',\n    MUSICBRAINZ_ALBUMTYPE: 'releasetype',\n    RELEASECOUNTRY: 'releasecountry',\n    Script: 'script',\n    Language: 'language',\n    Copyright: 'copyright',\n    LICENSE: 'license',\n    EncodedBy: 'encodedby',\n    EncoderSettings: 'encodersettings',\n    Barcode: 'barcode',\n    ISRC: 'isrc',\n    ASIN: 'asin',\n    musicbrainz_trackid: 'musicbrainz_recordingid',\n    musicbrainz_releasetrackid: 'musicbrainz_trackid',\n    MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',\n    MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',\n    MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',\n    MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',\n    MUSICBRAINZ_WORKID: 'musicbrainz_workid',\n    MUSICBRAINZ_TRMID: 'musicbrainz_trmid',\n    MUSICBRAINZ_DISCID: 'musicbrainz_discid',\n    Acoustid_Id: 'acoustid_id',\n    ACOUSTID_FINGERPRINT: 'acoustid_fingerprint',\n    MUSICIP_PUID: 'musicip_puid',\n    Weblink: 'website',\n    REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',\n    REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',\n    MP3GAIN_MINMAX: 'replaygain_track_minmax',\n    MP3GAIN_UNDO: 'replaygain_undo'\n};\nclass APEv2TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['APEv2'], apev2TagMap);\n    }\n}\nexports.APEv2TagMapper = APEv2TagMapper;\n//# sourceMappingURL=APEv2TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FwZXYyL0FQRXYyVGFnTWFwcGVyLmpzPzE1YmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDBHQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hcGV2Mi9BUEV2MlRhZ01hcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BUEV2MlRhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIElEM3YyLjIgdGFnIG1hcHBpbmdzXG4gKi9cbmNvbnN0IGFwZXYyVGFnTWFwID0ge1xuICAgIFRpdGxlOiAndGl0bGUnLFxuICAgIEFydGlzdDogJ2FydGlzdCcsXG4gICAgQXJ0aXN0czogJ2FydGlzdHMnLFxuICAgICdBbGJ1bSBBcnRpc3QnOiAnYWxidW1hcnRpc3QnLFxuICAgIEFsYnVtOiAnYWxidW0nLFxuICAgIFllYXI6ICdkYXRlJyxcbiAgICBPcmlnaW5hbHllYXI6ICdvcmlnaW5hbHllYXInLFxuICAgIE9yaWdpbmFsZGF0ZTogJ29yaWdpbmFsZGF0ZScsXG4gICAgQ29tbWVudDogJ2NvbW1lbnQnLFxuICAgIFRyYWNrOiAndHJhY2snLFxuICAgIERpc2M6ICdkaXNrJyxcbiAgICBESVNDTlVNQkVSOiAnZGlzaycsXG4gICAgR2VucmU6ICdnZW5yZScsXG4gICAgJ0NvdmVyIEFydCAoRnJvbnQpJzogJ3BpY3R1cmUnLFxuICAgICdDb3ZlciBBcnQgKEJhY2spJzogJ3BpY3R1cmUnLFxuICAgIENvbXBvc2VyOiAnY29tcG9zZXInLFxuICAgIEx5cmljczogJ2x5cmljcycsXG4gICAgQUxCVU1TT1JUOiAnYWxidW1zb3J0JyxcbiAgICBUSVRMRVNPUlQ6ICd0aXRsZXNvcnQnLFxuICAgIFdPUks6ICd3b3JrJyxcbiAgICBBUlRJU1RTT1JUOiAnYXJ0aXN0c29ydCcsXG4gICAgQUxCVU1BUlRJU1RTT1JUOiAnYWxidW1hcnRpc3Rzb3J0JyxcbiAgICBDT01QT1NFUlNPUlQ6ICdjb21wb3NlcnNvcnQnLFxuICAgIEx5cmljaXN0OiAnbHlyaWNpc3QnLFxuICAgIFdyaXRlcjogJ3dyaXRlcicsXG4gICAgQ29uZHVjdG9yOiAnY29uZHVjdG9yJyxcbiAgICAvLyAnUGVyZm9ybWVyPWFydGlzdMKgKGluc3RydW1lbnQpJzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JyxcbiAgICBNaXhBcnRpc3Q6ICdyZW1peGVyJyxcbiAgICBBcnJhbmdlcjogJ2FycmFuZ2VyJyxcbiAgICBFbmdpbmVlcjogJ2VuZ2luZWVyJyxcbiAgICBQcm9kdWNlcjogJ3Byb2R1Y2VyJyxcbiAgICBESk1peGVyOiAnZGptaXhlcicsXG4gICAgTWl4ZXI6ICdtaXhlcicsXG4gICAgTGFiZWw6ICdsYWJlbCcsXG4gICAgR3JvdXBpbmc6ICdncm91cGluZycsXG4gICAgU3VidGl0bGU6ICdzdWJ0aXRsZScsXG4gICAgRGlzY1N1YnRpdGxlOiAnZGlzY3N1YnRpdGxlJyxcbiAgICBDb21waWxhdGlvbjogJ2NvbXBpbGF0aW9uJyxcbiAgICBCUE06ICdicG0nLFxuICAgIE1vb2Q6ICdtb29kJyxcbiAgICBNZWRpYTogJ21lZGlhJyxcbiAgICBDYXRhbG9nTnVtYmVyOiAnY2F0YWxvZ251bWJlcicsXG4gICAgTVVTSUNCUkFJTlpfQUxCVU1TVEFUVVM6ICdyZWxlYXNlc3RhdHVzJyxcbiAgICBNVVNJQ0JSQUlOWl9BTEJVTVRZUEU6ICdyZWxlYXNldHlwZScsXG4gICAgUkVMRUFTRUNPVU5UUlk6ICdyZWxlYXNlY291bnRyeScsXG4gICAgU2NyaXB0OiAnc2NyaXB0JyxcbiAgICBMYW5ndWFnZTogJ2xhbmd1YWdlJyxcbiAgICBDb3B5cmlnaHQ6ICdjb3B5cmlnaHQnLFxuICAgIExJQ0VOU0U6ICdsaWNlbnNlJyxcbiAgICBFbmNvZGVkQnk6ICdlbmNvZGVkYnknLFxuICAgIEVuY29kZXJTZXR0aW5nczogJ2VuY29kZXJzZXR0aW5ncycsXG4gICAgQmFyY29kZTogJ2JhcmNvZGUnLFxuICAgIElTUkM6ICdpc3JjJyxcbiAgICBBU0lOOiAnYXNpbicsXG4gICAgbXVzaWNicmFpbnpfdHJhY2tpZDogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICBtdXNpY2JyYWluel9yZWxlYXNldHJhY2tpZDogJ211c2ljYnJhaW56X3RyYWNraWQnLFxuICAgIE1VU0lDQlJBSU5aX0FMQlVNSUQ6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICBNVVNJQ0JSQUlOWl9BUlRJU1RJRDogJ211c2ljYnJhaW56X2FydGlzdGlkJyxcbiAgICBNVVNJQ0JSQUlOWl9BTEJVTUFSVElTVElEOiAnbXVzaWNicmFpbnpfYWxidW1hcnRpc3RpZCcsXG4gICAgTVVTSUNCUkFJTlpfUkVMRUFTRUdST1VQSUQ6ICdtdXNpY2JyYWluel9yZWxlYXNlZ3JvdXBpZCcsXG4gICAgTVVTSUNCUkFJTlpfV09SS0lEOiAnbXVzaWNicmFpbnpfd29ya2lkJyxcbiAgICBNVVNJQ0JSQUlOWl9UUk1JRDogJ211c2ljYnJhaW56X3RybWlkJyxcbiAgICBNVVNJQ0JSQUlOWl9ESVNDSUQ6ICdtdXNpY2JyYWluel9kaXNjaWQnLFxuICAgIEFjb3VzdGlkX0lkOiAnYWNvdXN0aWRfaWQnLFxuICAgIEFDT1VTVElEX0ZJTkdFUlBSSU5UOiAnYWNvdXN0aWRfZmluZ2VycHJpbnQnLFxuICAgIE1VU0lDSVBfUFVJRDogJ211c2ljaXBfcHVpZCcsXG4gICAgV2VibGluazogJ3dlYnNpdGUnLFxuICAgIFJFUExBWUdBSU5fVFJBQ0tfR0FJTjogJ3JlcGxheWdhaW5fdHJhY2tfZ2FpbicsXG4gICAgUkVQTEFZR0FJTl9UUkFDS19QRUFLOiAncmVwbGF5Z2Fpbl90cmFja19wZWFrJyxcbiAgICBNUDNHQUlOX01JTk1BWDogJ3JlcGxheWdhaW5fdHJhY2tfbWlubWF4JyxcbiAgICBNUDNHQUlOX1VORE86ICdyZXBsYXlnYWluX3VuZG8nXG59O1xuY2xhc3MgQVBFdjJUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0FQRXYyJ10sIGFwZXYyVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkFQRXYyVGFnTWFwcGVyID0gQVBFdjJUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BUEV2MlRhZ01hcHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/apev2/APEv2Token.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2Token.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexports.DescriptorParser = {\n    len: 52,\n    get: (buf, off) => {\n        return {\n            // should equal 'MAC '\n            ID: FourCC_1.FourCcToken.get(buf, off),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n            // the number of descriptor bytes (allows later expansion of this header)\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n            // the number of header APE_HEADER bytes\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\n            // the number of header APE_HEADER bytes\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n            // the number of header data bytes (from original file)\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n            // the number of bytes of APE frame data\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n            // the high order number of APE frame data bytes\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n            // the terminating data of the file (not including tag data)\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Token.BufferType(16).get(buf, off + 36)\n        };\n    }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexports.Header = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n            compressionLevel: Token.UINT16_LE.get(buf, off),\n            // any format flags (for future use)\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\n            // the number of audio blocks in one frame\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n            // the number of audio blocks in the final frame\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n            // the total number of frames\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\n            // the bits per sample (typically 16)\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n            // the number of channels (1 or 2)\n            channel: Token.UINT16_LE.get(buf, off + 18),\n            // the sample rate (typically 44100)\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\n        };\n    }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexports.TagFooter = {\n    len: 32,\n    get: (buf, off) => {\n        return {\n            // should equal 'APETAGEX'\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\n            // equals CURRENT_APE_TAG_VERSION\n            version: Token.UINT32_LE.get(buf, off + 8),\n            // the complete size of the tag, including this footer (excludes header)\n            size: Token.UINT32_LE.get(buf, off + 12),\n            // the number of fields in the tag\n            fields: Token.UINT32_LE.get(buf, off + 16),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n        };\n    }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexports.TagItemHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Length of assigned value in bytes\n            size: Token.UINT32_LE.get(buf, off),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n        };\n    }\n};\nexports.TagField = footer => {\n    return new Token.BufferType(footer.size - exports.TagFooter.len);\n};\nfunction parseTagFlags(flags) {\n    return {\n        containsHeader: isBitSet(flags, 31),\n        containsFooter: isBitSet(flags, 30),\n        isHeader: isBitSet(flags, 31),\n        readOnly: isBitSet(flags, 0),\n        dataType: (flags & 6) >> 1\n    };\n}\nexports.parseTagFlags = parseTagFlags;\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nfunction isBitSet(num, bit) {\n    return (num & 1 << bit) !== 0;\n}\nexports.isBitSet = isBitSet;\n//# sourceMappingURL=APEv2Token.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FwZXYyL0FQRXYyVG9rZW4uanM/MWQ1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVEQUF1RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZLFFBQVEsa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXBldjIvQVBFdjJUb2tlbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0JpdFNldCA9IGV4cG9ydHMucGFyc2VUYWdGbGFncyA9IGV4cG9ydHMuVGFnRmllbGQgPSBleHBvcnRzLlRhZ0l0ZW1IZWFkZXIgPSBleHBvcnRzLlRhZ0Zvb3RlciA9IGV4cG9ydHMuSGVhZGVyID0gZXhwb3J0cy5EZXNjcmlwdG9yUGFyc2VyID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcInRleHRfdXRmOFwiXSA9IDBdID0gXCJ0ZXh0X3V0ZjhcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcImJpbmFyeVwiXSA9IDFdID0gXCJiaW5hcnlcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcImV4dGVybmFsX2luZm9cIl0gPSAyXSA9IFwiZXh0ZXJuYWxfaW5mb1wiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wicmVzZXJ2ZWRcIl0gPSAzXSA9IFwicmVzZXJ2ZWRcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG4vKipcbiAqIEFQRV9ERVNDUklQVE9SOiBkZWZpbmVzIHRoZSBzaXplcyAoYW5kIG9mZnNldHMpIG9mIGFsbCB0aGUgcGllY2VzLCBhcyB3ZWxsIGFzIHRoZSBNRDUgY2hlY2tzdW1cbiAqL1xuZXhwb3J0cy5EZXNjcmlwdG9yUGFyc2VyID0ge1xuICAgIGxlbjogNTIsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBlcXVhbCAnTUFDICdcbiAgICAgICAgICAgIElEOiBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gdmVyc2lvbkluZGV4IG51bWJlciAqIDEwMDAgKDMuODEgPSAzODEwKSAocmVtZW1iZXIgdGhhdCA0LWJ5dGUgYWxpZ25tZW50IGNhdXNlcyB0aGlzIHRvIHRha2UgNC1ieXRlcylcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA0KSAvIDEwMDAsXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGRlc2NyaXB0b3IgYnl0ZXMgKGFsbG93cyBsYXRlciBleHBhbnNpb24gb2YgdGhpcyBoZWFkZXIpXG4gICAgICAgICAgICBkZXNjcmlwdG9yQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgb2YgaGVhZGVyIEFQRV9IRUFERVIgYnl0ZXNcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBoZWFkZXIgQVBFX0hFQURFUiBieXRlc1xuICAgICAgICAgICAgc2Vla1RhYmxlQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGhlYWRlciBkYXRhIGJ5dGVzIChmcm9tIG9yaWdpbmFsIGZpbGUpXG4gICAgICAgICAgICBoZWFkZXJEYXRhQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyMCksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIEFQRSBmcmFtZSBkYXRhXG4gICAgICAgICAgICBhcGVGcmFtZURhdGFCeXRlczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDI0KSxcbiAgICAgICAgICAgIC8vIHRoZSBoaWdoIG9yZGVyIG51bWJlciBvZiBBUEUgZnJhbWUgZGF0YSBieXRlc1xuICAgICAgICAgICAgYXBlRnJhbWVEYXRhQnl0ZXNIaWdoOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjgpLFxuICAgICAgICAgICAgLy8gdGhlIHRlcm1pbmF0aW5nIGRhdGEgb2YgdGhlIGZpbGUgKG5vdCBpbmNsdWRpbmcgdGFnIGRhdGEpXG4gICAgICAgICAgICB0ZXJtaW5hdGluZ0RhdGFCeXRlczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDMyKSxcbiAgICAgICAgICAgIC8vIHRoZSBNRDUgaGFzaCBvZiB0aGUgZmlsZSAoc2VlIG5vdGVzIGZvciB1c2FnZS4uLiBpdCdzIGEgbGl0dGx5IHRyaWNreSlcbiAgICAgICAgICAgIGZpbGVNRDU6IG5ldyBUb2tlbi5CdWZmZXJUeXBlKDE2KS5nZXQoYnVmLCBvZmYgKyAzNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBBUEVfSEVBREVSOiBkZXNjcmliZXMgYWxsIG9mIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEFQRSBmaWxlXG4gKi9cbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGxlbjogMjQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb21wcmVzc2lvbiBsZXZlbCAoc2VlIGRlZmluZXMgSS5FLiBDT01QUkVTU0lPTl9MRVZFTF9GQVNUKVxuICAgICAgICAgICAgY29tcHJlc3Npb25MZXZlbDogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBhbnkgZm9ybWF0IGZsYWdzIChmb3IgZnV0dXJlIHVzZSlcbiAgICAgICAgICAgIGZvcm1hdEZsYWdzOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgMiksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGF1ZGlvIGJsb2NrcyBpbiBvbmUgZnJhbWVcbiAgICAgICAgICAgIGJsb2Nrc1BlckZyYW1lOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGF1ZGlvIGJsb2NrcyBpbiB0aGUgZmluYWwgZnJhbWVcbiAgICAgICAgICAgIGZpbmFsRnJhbWVCbG9ja3M6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzXG4gICAgICAgICAgICB0b3RhbEZyYW1lczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDEyKSxcbiAgICAgICAgICAgIC8vIHRoZSBiaXRzIHBlciBzYW1wbGUgKHR5cGljYWxseSAxNilcbiAgICAgICAgICAgIGJpdHNQZXJTYW1wbGU6IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzICgxIG9yIDIpXG4gICAgICAgICAgICBjaGFubmVsOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTgpLFxuICAgICAgICAgICAgLy8gdGhlIHNhbXBsZSByYXRlICh0eXBpY2FsbHkgNDQxMDApXG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogQVBFIFRhZyBIZWFkZXIvRm9vdGVyIFZlcnNpb24gMi4wXG4gKiBUQUc6IGRlc2NyaWJlcyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGZpbGUgW29wdGlvbmFsXVxuICovXG5leHBvcnRzLlRhZ0Zvb3RlciA9IHtcbiAgICBsZW46IDMyLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBzaG91bGQgZXF1YWwgJ0FQRVRBR0VYJ1xuICAgICAgICAgICAgSUQ6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBlcXVhbHMgQ1VSUkVOVF9BUEVfVEFHX1ZFUlNJT05cbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIC8vIHRoZSBjb21wbGV0ZSBzaXplIG9mIHRoZSB0YWcsIGluY2x1ZGluZyB0aGlzIGZvb3RlciAoZXhjbHVkZXMgaGVhZGVyKVxuICAgICAgICAgICAgc2l6ZTogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDEyKSxcbiAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgb2YgZmllbGRzIGluIHRoZSB0YWdcbiAgICAgICAgICAgIGZpZWxkczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIC8vIHJlc2VydmVkIGZvciBsYXRlciB1c2UgKG11c3QgYmUgemVybyksXG4gICAgICAgICAgICBmbGFnczogcGFyc2VUYWdGbGFncyhUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEFQRSBUYWcgdjIuMCBJdGVtIEhlYWRlclxuICovXG5leHBvcnRzLlRhZ0l0ZW1IZWFkZXIgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBMZW5ndGggb2YgYXNzaWduZWQgdmFsdWUgaW4gYnl0ZXNcbiAgICAgICAgICAgIHNpemU6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gcmVzZXJ2ZWQgZm9yIGxhdGVyIHVzZSAobXVzdCBiZSB6ZXJvKSxcbiAgICAgICAgICAgIGZsYWdzOiBwYXJzZVRhZ0ZsYWdzKFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA0KSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5UYWdGaWVsZCA9IGZvb3RlciA9PiB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbi5CdWZmZXJUeXBlKGZvb3Rlci5zaXplIC0gZXhwb3J0cy5UYWdGb290ZXIubGVuKTtcbn07XG5mdW5jdGlvbiBwYXJzZVRhZ0ZsYWdzKGZsYWdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGFpbnNIZWFkZXI6IGlzQml0U2V0KGZsYWdzLCAzMSksXG4gICAgICAgIGNvbnRhaW5zRm9vdGVyOiBpc0JpdFNldChmbGFncywgMzApLFxuICAgICAgICBpc0hlYWRlcjogaXNCaXRTZXQoZmxhZ3MsIDMxKSxcbiAgICAgICAgcmVhZE9ubHk6IGlzQml0U2V0KGZsYWdzLCAwKSxcbiAgICAgICAgZGF0YVR5cGU6IChmbGFncyAmIDYpID4+IDFcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVRhZ0ZsYWdzID0gcGFyc2VUYWdGbGFncztcbi8qKlxuICogQHBhcmFtIG51bSB7bnVtYmVyfVxuICogQHBhcmFtIGJpdCAwIGlzIGxlYXN0IHNpZ25pZmljYW50IGJpdCAoTFNCKVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBiaXQgaXMgMTsgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQml0U2V0KG51bSwgYml0KSB7XG4gICAgcmV0dXJuIChudW0gJiAxIDw8IGJpdCkgIT09IDA7XG59XG5leHBvcnRzLmlzQml0U2V0ID0gaXNCaXRTZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BUEV2MlRva2VuLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/apev2/APEv2Token.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/asf/AsfObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfObject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// ASF Objects\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WmPictureToken = exports.MetadataLibraryObjectState = exports.MetadataObjectState = exports.ExtendedStreamPropertiesObjectState = exports.ExtendedContentDescriptionObjectState = exports.ContentDescriptionObjectState = exports.readCodecEntries = exports.HeaderExtensionObject = exports.StreamPropertiesObject = exports.FilePropertiesObject = exports.IgnoreObjectState = exports.State = exports.HeaderObjectToken = exports.TopLevelHeaderObjectToken = exports.DataType = void 0;\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst GUID_1 = __webpack_require__(/*! ./GUID */ \"./node_modules/music-metadata/lib/asf/GUID.js\");\nconst AsfUtil_1 = __webpack_require__(/*! ./AsfUtil */ \"./node_modules/music-metadata/lib/asf/AsfUtil.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ../id3v2/ID3v2Token */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n/**\n * Data Type: Specifies the type of information being stored. The following values are recognized.\n */\nvar DataType;\n(function (DataType) {\n    /**\n     * Unicode string. The data consists of a sequence of Unicode characters.\n     */\n    DataType[DataType[\"UnicodeString\"] = 0] = \"UnicodeString\";\n    /**\n     * BYTE array. The type of data is implementation-specific.\n     */\n    DataType[DataType[\"ByteArray\"] = 1] = \"ByteArray\";\n    /**\n     * BOOL. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer. Only 0x0000 or 0x0001 are permitted values.\n     */\n    DataType[DataType[\"Bool\"] = 2] = \"Bool\";\n    /**\n     * DWORD. The data is 4 bytes long and should be interpreted as a 32-bit unsigned integer.\n     */\n    DataType[DataType[\"DWord\"] = 3] = \"DWord\";\n    /**\n     * QWORD. The data is 8 bytes long and should be interpreted as a 64-bit unsigned integer.\n     */\n    DataType[DataType[\"QWord\"] = 4] = \"QWord\";\n    /**\n     * WORD. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer.\n     */\n    DataType[DataType[\"Word\"] = 5] = \"Word\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * Token for: 3. ASF top-level Header Object\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3\n */\nexports.TopLevelHeaderObjectToken = {\n    len: 30,\n    get: (buf, off) => {\n        return {\n            objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n            objectSize: Token.UINT64_LE.get(buf, off + 16),\n            numberOfHeaderObjects: Token.UINT32_LE.get(buf, off + 24)\n            // Reserved: 2 bytes\n        };\n    }\n};\n/**\n * Token for: 3.1 Header Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_1\n */\nexports.HeaderObjectToken = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n            objectSize: Token.UINT64_LE.get(buf, off + 16)\n        };\n    }\n};\nclass State {\n    constructor(header) {\n        this.len = header.objectSize - exports.HeaderObjectToken.len;\n    }\n    postProcessTag(tags, name, valueType, data) {\n        if (name === 'WM/Picture') {\n            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });\n        }\n        else {\n            const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);\n            if (!parseAttr) {\n                throw new Error('unexpected value headerType: ' + valueType);\n            }\n            tags.push({ id: name, value: parseAttr(data) });\n        }\n    }\n}\nexports.State = State;\n// ToDo: use ignore type\nclass IgnoreObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return null;\n    }\n}\nexports.IgnoreObjectState = IgnoreObjectState;\n/**\n * Token for: 3.2: File Properties Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_2\n */\nclass FilePropertiesObject extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            fileId: GUID_1.default.fromBin(buf, off),\n            fileSize: Token.UINT64_LE.get(buf, off + 16),\n            creationDate: Token.UINT64_LE.get(buf, off + 24),\n            dataPacketsCount: Token.UINT64_LE.get(buf, off + 32),\n            playDuration: Token.UINT64_LE.get(buf, off + 40),\n            sendDuration: Token.UINT64_LE.get(buf, off + 48),\n            preroll: Token.UINT64_LE.get(buf, off + 56),\n            flags: {\n                broadcast: Util_1.default.strtokBITSET.get(buf, off + 64, 24),\n                seekable: Util_1.default.strtokBITSET.get(buf, off + 64, 25)\n            },\n            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n            minimumDataPacketSize: Token.UINT32_LE.get(buf, off + 68),\n            maximumDataPacketSize: Token.UINT32_LE.get(buf, off + 72),\n            maximumBitrate: Token.UINT32_LE.get(buf, off + 76)\n        };\n    }\n}\nexports.FilePropertiesObject = FilePropertiesObject;\nFilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;\n/**\n * Token for: 3.3 Stream Properties Object (mandatory, one per stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_3\n */\nclass StreamPropertiesObject extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),\n            errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)\n            // ToDo\n        };\n    }\n}\nexports.StreamPropertiesObject = StreamPropertiesObject;\nStreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;\n/**\n * 3.4: Header Extension Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_4\n */\nclass HeaderExtensionObject {\n    constructor() {\n        this.len = 22;\n    }\n    get(buf, off) {\n        return {\n            reserved1: GUID_1.default.fromBin(buf, off),\n            reserved2: buf.readUInt16LE(off + 16),\n            extensionDataSize: buf.readUInt32LE(off + 18)\n        };\n    }\n}\nexports.HeaderExtensionObject = HeaderExtensionObject;\nHeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;\n/**\n * 3.5: The Codec List Object provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nconst CodecListObjectHeader = {\n    len: 20,\n    get: (buf, off) => {\n        return {\n            entryCount: buf.readUInt16LE(off + 16)\n        };\n    }\n};\nasync function readString(tokenizer) {\n    const length = await tokenizer.readNumber(Token.UINT16_LE);\n    return (await tokenizer.readToken(new Token.StringType(length * 2, 'utf16le'))).replace('\\0', '');\n}\n/**\n * 3.5: Read the Codec-List-Object, which provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nasync function readCodecEntries(tokenizer) {\n    const codecHeader = await tokenizer.readToken(CodecListObjectHeader);\n    const entries = [];\n    for (let i = 0; i < codecHeader.entryCount; ++i) {\n        entries.push(await readCodecEntry(tokenizer));\n    }\n    return entries;\n}\nexports.readCodecEntries = readCodecEntries;\nasync function readInformation(tokenizer) {\n    const length = await tokenizer.readNumber(Token.UINT16_LE);\n    const buf = Buffer.alloc(length);\n    await tokenizer.readBuffer(buf);\n    return buf;\n}\n/**\n * Read Codec-Entries\n * @param tokenizer\n */\nasync function readCodecEntry(tokenizer) {\n    const type = await tokenizer.readNumber(Token.UINT16_LE);\n    return {\n        type: {\n            videoCodec: (type & 0x0001) === 0x0001,\n            audioCodec: (type & 0x0002) === 0x0002\n        },\n        codecName: await readString(tokenizer),\n        description: await readString(tokenizer),\n        information: await readInformation(tokenizer)\n    };\n}\n/**\n * 3.10 Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_10\n */\nclass ContentDescriptionObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        const tags = [];\n        let pos = off + 10;\n        for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {\n            const length = buf.readUInt16LE(off + i * 2);\n            if (length > 0) {\n                const tagName = ContentDescriptionObjectState.contentDescTags[i];\n                const end = pos + length;\n                tags.push({ id: tagName, value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end)) });\n                pos = end;\n            }\n        }\n        return tags;\n    }\n}\nexports.ContentDescriptionObjectState = ContentDescriptionObjectState;\nContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;\nContentDescriptionObjectState.contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating'];\n/**\n * 3.11 Extended Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_11\n */\nclass ExtendedContentDescriptionObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        const tags = [];\n        const attrCount = buf.readUInt16LE(off);\n        let pos = off + 2;\n        for (let i = 0; i < attrCount; i += 1) {\n            const nameLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n            pos += nameLen;\n            const valueType = buf.readUInt16LE(pos);\n            pos += 2;\n            const valueLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const value = buf.slice(pos, pos + valueLen);\n            pos += valueLen;\n            this.postProcessTag(tags, name, valueType, value);\n        }\n        return tags;\n    }\n}\nexports.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;\nExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;\n/**\n * 4.1 Extended Stream Properties Object (optional, 1 per media stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_1\n */\nclass ExtendedStreamPropertiesObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            startTime: Token.UINT64_LE.get(buf, off),\n            endTime: Token.UINT64_LE.get(buf, off + 8),\n            dataBitrate: buf.readInt32LE(off + 12),\n            bufferSize: buf.readInt32LE(off + 16),\n            initialBufferFullness: buf.readInt32LE(off + 20),\n            alternateDataBitrate: buf.readInt32LE(off + 24),\n            alternateBufferSize: buf.readInt32LE(off + 28),\n            alternateInitialBufferFullness: buf.readInt32LE(off + 32),\n            maximumObjectSize: buf.readInt32LE(off + 36),\n            flags: {\n                reliableFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 0),\n                seekableFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 1),\n                resendLiveCleanpointsFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 2)\n            },\n            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n            streamNumber: buf.readInt16LE(off + 42),\n            streamLanguageId: buf.readInt16LE(off + 44),\n            averageTimePerFrame: buf.readInt32LE(off + 52),\n            streamNameCount: buf.readInt32LE(off + 54),\n            payloadExtensionSystems: buf.readInt32LE(off + 56),\n            streamNames: [],\n            streamPropertiesObject: null\n        };\n    }\n}\nexports.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;\nExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;\n/**\n * 4.7  Metadata Object (optional, 0 or 1)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_7\n */\nclass MetadataObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        const tags = [];\n        const descriptionRecordsCount = buf.readUInt16LE(off);\n        let pos = off + 2;\n        for (let i = 0; i < descriptionRecordsCount; i += 1) {\n            pos += 4;\n            const nameLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const dataType = buf.readUInt16LE(pos);\n            pos += 2;\n            const dataLen = buf.readUInt32LE(pos);\n            pos += 4;\n            const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n            pos += nameLen;\n            const data = buf.slice(pos, pos + dataLen);\n            pos += dataLen;\n            const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(dataType);\n            if (!parseAttr) {\n                throw new Error('unexpected value headerType: ' + dataType);\n            }\n            this.postProcessTag(tags, name, dataType, data);\n        }\n        return tags;\n    }\n}\nexports.MetadataObjectState = MetadataObjectState;\nMetadataObjectState.guid = GUID_1.default.MetadataObject;\n// 4.8\tMetadata Library Object (optional, 0 or 1)\nclass MetadataLibraryObjectState extends MetadataObjectState {\n    constructor(header) {\n        super(header);\n    }\n}\nexports.MetadataLibraryObjectState = MetadataLibraryObjectState;\nMetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd757977(v=vs.85).aspx\n */\nclass WmPictureToken {\n    constructor(len) {\n        this.len = len;\n    }\n    static fromBase64(base64str) {\n        return this.fromBuffer(Buffer.from(base64str, 'base64'));\n    }\n    static fromBuffer(buffer) {\n        const pic = new WmPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    get(buffer, offset) {\n        const typeId = buffer.readUInt8(offset++);\n        const size = buffer.readInt32LE(offset);\n        let index = 5;\n        while (buffer.readUInt16BE(index) !== 0) {\n            index += 2;\n        }\n        const format = buffer.slice(5, index).toString('utf16le');\n        while (buffer.readUInt16BE(index) !== 0) {\n            index += 2;\n        }\n        const description = buffer.slice(5, index).toString('utf16le');\n        return {\n            type: ID3v2Token_1.AttachedPictureType[typeId],\n            format,\n            description,\n            size,\n            data: buffer.slice(index + 4)\n        };\n    }\n}\nexports.WmPictureToken = WmPictureToken;\n//# sourceMappingURL=AsfObject.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZPYmplY3QuanM/ZmE4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsNkRBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsbUVBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVEQUF1RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQTBEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhFQUE4RTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZPYmplY3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBU0YgT2JqZWN0c1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XbVBpY3R1cmVUb2tlbiA9IGV4cG9ydHMuTWV0YWRhdGFMaWJyYXJ5T2JqZWN0U3RhdGUgPSBleHBvcnRzLk1ldGFkYXRhT2JqZWN0U3RhdGUgPSBleHBvcnRzLkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdFN0YXRlID0gZXhwb3J0cy5FeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlID0gZXhwb3J0cy5Db250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSA9IGV4cG9ydHMucmVhZENvZGVjRW50cmllcyA9IGV4cG9ydHMuSGVhZGVyRXh0ZW5zaW9uT2JqZWN0ID0gZXhwb3J0cy5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0ID0gZXhwb3J0cy5GaWxlUHJvcGVydGllc09iamVjdCA9IGV4cG9ydHMuSWdub3JlT2JqZWN0U3RhdGUgPSBleHBvcnRzLlN0YXRlID0gZXhwb3J0cy5IZWFkZXJPYmplY3RUb2tlbiA9IGV4cG9ydHMuVG9wTGV2ZWxIZWFkZXJPYmplY3RUb2tlbiA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEdVSURfMSA9IHJlcXVpcmUoXCIuL0dVSURcIik7XG5jb25zdCBBc2ZVdGlsXzEgPSByZXF1aXJlKFwiLi9Bc2ZVdGlsXCIpO1xuY29uc3QgSUQzdjJUb2tlbl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyVG9rZW5cIik7XG4vKipcbiAqIERhdGEgVHlwZTogU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGluZm9ybWF0aW9uIGJlaW5nIHN0b3JlZC4gVGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIHJlY29nbml6ZWQuXG4gKi9cbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVbmljb2RlIHN0cmluZy4gVGhlIGRhdGEgY29uc2lzdHMgb2YgYSBzZXF1ZW5jZSBvZiBVbmljb2RlIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJVbmljb2RlU3RyaW5nXCJdID0gMF0gPSBcIlVuaWNvZGVTdHJpbmdcIjtcbiAgICAvKipcbiAgICAgKiBCWVRFIGFycmF5LiBUaGUgdHlwZSBvZiBkYXRhIGlzIGltcGxlbWVudGF0aW9uLXNwZWNpZmljLlxuICAgICAqL1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQnl0ZUFycmF5XCJdID0gMV0gPSBcIkJ5dGVBcnJheVwiO1xuICAgIC8qKlxuICAgICAqIEJPT0wuIFRoZSBkYXRhIGlzIDIgYnl0ZXMgbG9uZyBhbmQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIuIE9ubHkgMHgwMDAwIG9yIDB4MDAwMSBhcmUgcGVybWl0dGVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkJvb2xcIl0gPSAyXSA9IFwiQm9vbFwiO1xuICAgIC8qKlxuICAgICAqIERXT1JELiBUaGUgZGF0YSBpcyA0IGJ5dGVzIGxvbmcgYW5kIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFdvcmRcIl0gPSAzXSA9IFwiRFdvcmRcIjtcbiAgICAvKipcbiAgICAgKiBRV09SRC4gVGhlIGRhdGEgaXMgOCBieXRlcyBsb25nIGFuZCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIlFXb3JkXCJdID0gNF0gPSBcIlFXb3JkXCI7XG4gICAgLyoqXG4gICAgICogV09SRC4gVGhlIGRhdGEgaXMgMiBieXRlcyBsb25nIGFuZCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSAxNi1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldvcmRcIl0gPSA1XSA9IFwiV29yZFwiO1xufSkoRGF0YVR5cGUgPSBleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcbi8qKlxuICogVG9rZW4gZm9yOiAzLiBBU0YgdG9wLWxldmVsIEhlYWRlciBPYmplY3RcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNcbiAqL1xuZXhwb3J0cy5Ub3BMZXZlbEhlYWRlck9iamVjdFRva2VuID0ge1xuICAgIGxlbjogMzAsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9iamVjdElkOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKG5ldyBUb2tlbi5CdWZmZXJUeXBlKDE2KS5nZXQoYnVmLCBvZmYpKSxcbiAgICAgICAgICAgIG9iamVjdFNpemU6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICBudW1iZXJPZkhlYWRlck9iamVjdHM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyNClcbiAgICAgICAgICAgIC8vIFJlc2VydmVkOiAyIGJ5dGVzXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogVG9rZW4gZm9yOiAzLjEgSGVhZGVyIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgb25seSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfMVxuICovXG5leHBvcnRzLkhlYWRlck9iamVjdFRva2VuID0ge1xuICAgIGxlbjogMjQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9iamVjdElkOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKG5ldyBUb2tlbi5CdWZmZXJUeXBlKDE2KS5nZXQoYnVmLCBvZmYpKSxcbiAgICAgICAgICAgIG9iamVjdFNpemU6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyAxNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5vYmplY3RTaXplIC0gZXhwb3J0cy5IZWFkZXJPYmplY3RUb2tlbi5sZW47XG4gICAgfVxuICAgIHBvc3RQcm9jZXNzVGFnKHRhZ3MsIG5hbWUsIHZhbHVlVHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ1dNL1BpY3R1cmUnKSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goeyBpZDogbmFtZSwgdmFsdWU6IFdtUGljdHVyZVRva2VuLmZyb21CdWZmZXIoZGF0YSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZUF0dHIgPSBBc2ZVdGlsXzEuQXNmVXRpbC5nZXRQYXJzZXJGb3JBdHRyKHZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlQXR0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCB2YWx1ZSBoZWFkZXJUeXBlOiAnICsgdmFsdWVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZ3MucHVzaCh7IGlkOiBuYW1lLCB2YWx1ZTogcGFyc2VBdHRyKGRhdGEpIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xuLy8gVG9EbzogdXNlIGlnbm9yZSB0eXBlXG5jbGFzcyBJZ25vcmVPYmplY3RTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoaGVhZGVyKTtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuSWdub3JlT2JqZWN0U3RhdGUgPSBJZ25vcmVPYmplY3RTdGF0ZTtcbi8qKlxuICogVG9rZW4gZm9yOiAzLjI6IEZpbGUgUHJvcGVydGllcyBPYmplY3QgKG1hbmRhdG9yeSwgb25lIG9ubHkpXG4gKiBSZWY6IGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8wM19hc2ZfdG9wX2xldmVsX2hlYWRlcl9vYmplY3QuaHRtbCMzXzJcbiAqL1xuY2xhc3MgRmlsZVByb3BlcnRpZXNPYmplY3QgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZUlkOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGZpbGVTaXplOiBUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTYpLFxuICAgICAgICAgICAgY3JlYXRpb25EYXRlOiBUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjQpLFxuICAgICAgICAgICAgZGF0YVBhY2tldHNDb3VudDogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDMyKSxcbiAgICAgICAgICAgIHBsYXlEdXJhdGlvbjogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDQwKSxcbiAgICAgICAgICAgIHNlbmREdXJhdGlvbjogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDQ4KSxcbiAgICAgICAgICAgIHByZXJvbGw6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA1NiksXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChidWYsIG9mZiArIDY0LCAyNCksXG4gICAgICAgICAgICAgICAgc2Vla2FibGU6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYnVmLCBvZmYgKyA2NCwgMjUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZmxhZ3NOdW1lcmljOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNjQpLFxuICAgICAgICAgICAgbWluaW11bURhdGFQYWNrZXRTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNjgpLFxuICAgICAgICAgICAgbWF4aW11bURhdGFQYWNrZXRTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNzIpLFxuICAgICAgICAgICAgbWF4aW11bUJpdHJhdGU6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA3NilcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVQcm9wZXJ0aWVzT2JqZWN0ID0gRmlsZVByb3BlcnRpZXNPYmplY3Q7XG5GaWxlUHJvcGVydGllc09iamVjdC5ndWlkID0gR1VJRF8xLmRlZmF1bHQuRmlsZVByb3BlcnRpZXNPYmplY3Q7XG4vKipcbiAqIFRva2VuIGZvcjogMy4zIFN0cmVhbSBQcm9wZXJ0aWVzIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgcGVyIHN0cmVhbSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfM1xuICovXG5jbGFzcyBTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0IGV4dGVuZHMgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBzdXBlcihoZWFkZXIpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmVhbVR5cGU6IEdVSURfMS5kZWZhdWx0LmRlY29kZU1lZGlhVHlwZShHVUlEXzEuZGVmYXVsdC5mcm9tQmluKGJ1Ziwgb2ZmKSksXG4gICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25UeXBlOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKGJ1Ziwgb2ZmICsgOClcbiAgICAgICAgICAgIC8vIFRvRG9cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbVByb3BlcnRpZXNPYmplY3QgPSBTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0O1xuU3RyZWFtUHJvcGVydGllc09iamVjdC5ndWlkID0gR1VJRF8xLmRlZmF1bHQuU3RyZWFtUHJvcGVydGllc09iamVjdDtcbi8qKlxuICogMy40OiBIZWFkZXIgRXh0ZW5zaW9uIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgb25seSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfNFxuICovXG5jbGFzcyBIZWFkZXJFeHRlbnNpb25PYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxlbiA9IDIyO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2VydmVkMTogR1VJRF8xLmRlZmF1bHQuZnJvbUJpbihidWYsIG9mZiksXG4gICAgICAgICAgICByZXNlcnZlZDI6IGJ1Zi5yZWFkVUludDE2TEUob2ZmICsgMTYpLFxuICAgICAgICAgICAgZXh0ZW5zaW9uRGF0YVNpemU6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5IZWFkZXJFeHRlbnNpb25PYmplY3QgPSBIZWFkZXJFeHRlbnNpb25PYmplY3Q7XG5IZWFkZXJFeHRlbnNpb25PYmplY3QuZ3VpZCA9IEdVSURfMS5kZWZhdWx0LkhlYWRlckV4dGVuc2lvbk9iamVjdDtcbi8qKlxuICogMy41OiBUaGUgQ29kZWMgTGlzdCBPYmplY3QgcHJvdmlkZXMgdXNlci1mcmllbmRseSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29kZWNzIGFuZCBmb3JtYXRzIHVzZWQgdG8gZW5jb2RlIHRoZSBjb250ZW50IGZvdW5kIGluIHRoZSBBU0YgZmlsZS5cbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfNVxuICovXG5jb25zdCBDb2RlY0xpc3RPYmplY3RIZWFkZXIgPSB7XG4gICAgbGVuOiAyMCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cnlDb3VudDogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmluZyh0b2tlbml6ZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhd2FpdCB0b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5VSU5UMTZfTEUpO1xuICAgIHJldHVybiAoYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShsZW5ndGggKiAyLCAndXRmMTZsZScpKSkucmVwbGFjZSgnXFwwJywgJycpO1xufVxuLyoqXG4gKiAzLjU6IFJlYWQgdGhlIENvZGVjLUxpc3QtT2JqZWN0LCB3aGljaCBwcm92aWRlcyB1c2VyLWZyaWVuZGx5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2RlY3MgYW5kIGZvcm1hdHMgdXNlZCB0byBlbmNvZGUgdGhlIGNvbnRlbnQgZm91bmQgaW4gdGhlIEFTRiBmaWxlLlxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM181XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb2RlY0VudHJpZXModG9rZW5pemVyKSB7XG4gICAgY29uc3QgY29kZWNIZWFkZXIgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKENvZGVjTGlzdE9iamVjdEhlYWRlcik7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNIZWFkZXIuZW50cnlDb3VudDsgKytpKSB7XG4gICAgICAgIGVudHJpZXMucHVzaChhd2FpdCByZWFkQ29kZWNFbnRyeSh0b2tlbml6ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG59XG5leHBvcnRzLnJlYWRDb2RlY0VudHJpZXMgPSByZWFkQ29kZWNFbnRyaWVzO1xuYXN5bmMgZnVuY3Rpb24gcmVhZEluZm9ybWF0aW9uKHRva2VuaXplcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGF3YWl0IHRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLlVJTlQxNl9MRSk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgYXdhaXQgdG9rZW5pemVyLnJlYWRCdWZmZXIoYnVmKTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBSZWFkIENvZGVjLUVudHJpZXNcbiAqIEBwYXJhbSB0b2tlbml6ZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZENvZGVjRW50cnkodG9rZW5pemVyKSB7XG4gICAgY29uc3QgdHlwZSA9IGF3YWl0IHRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLlVJTlQxNl9MRSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdmlkZW9Db2RlYzogKHR5cGUgJiAweDAwMDEpID09PSAweDAwMDEsXG4gICAgICAgICAgICBhdWRpb0NvZGVjOiAodHlwZSAmIDB4MDAwMikgPT09IDB4MDAwMlxuICAgICAgICB9LFxuICAgICAgICBjb2RlY05hbWU6IGF3YWl0IHJlYWRTdHJpbmcodG9rZW5pemVyKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGF3YWl0IHJlYWRTdHJpbmcodG9rZW5pemVyKSxcbiAgICAgICAgaW5mb3JtYXRpb246IGF3YWl0IHJlYWRJbmZvcm1hdGlvbih0b2tlbml6ZXIpXG4gICAgfTtcbn1cbi8qKlxuICogMy4xMCBDb250ZW50IERlc2NyaXB0aW9uIE9iamVjdCAob3B0aW9uYWwsIG9uZSBvbmx5KVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM18xMFxuICovXG5jbGFzcyBDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoaGVhZGVyKTtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IHRhZ3MgPSBbXTtcbiAgICAgICAgbGV0IHBvcyA9IG9mZiArIDEwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlLmNvbnRlbnREZXNjVGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnVmLnJlYWRVSW50MTZMRShvZmYgKyBpICogMik7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZS5jb250ZW50RGVzY1RhZ3NbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcG9zICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh7IGlkOiB0YWdOYW1lLCB2YWx1ZTogQXNmVXRpbF8xLkFzZlV0aWwucGFyc2VVbmljb2RlQXR0cihidWYuc2xpY2UocG9zLCBlbmQpKSB9KTtcbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxufVxuZXhwb3J0cy5Db250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSA9IENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlO1xuQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUuZ3VpZCA9IEdVSURfMS5kZWZhdWx0LkNvbnRlbnREZXNjcmlwdGlvbk9iamVjdDtcbkNvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlLmNvbnRlbnREZXNjVGFncyA9IFsnVGl0bGUnLCAnQXV0aG9yJywgJ0NvcHlyaWdodCcsICdEZXNjcmlwdGlvbicsICdSYXRpbmcnXTtcbi8qKlxuICogMy4xMSBFeHRlbmRlZCBDb250ZW50IERlc2NyaXB0aW9uIE9iamVjdCAob3B0aW9uYWwsIG9uZSBvbmx5KVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM18xMVxuICovXG5jbGFzcyBFeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlIGV4dGVuZHMgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBzdXBlcihoZWFkZXIpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgICBjb25zdCBhdHRyQ291bnQgPSBidWYucmVhZFVJbnQxNkxFKG9mZik7XG4gICAgICAgIGxldCBwb3MgPSBvZmYgKyAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lTGVuID0gYnVmLnJlYWRVSW50MTZMRShwb3MpO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gQXNmVXRpbF8xLkFzZlV0aWwucGFyc2VVbmljb2RlQXR0cihidWYuc2xpY2UocG9zLCBwb3MgKyBuYW1lTGVuKSk7XG4gICAgICAgICAgICBwb3MgKz0gbmFtZUxlbjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGJ1Zi5yZWFkVUludDE2TEUocG9zKTtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSBidWYucmVhZFVJbnQxNkxFKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnVmLnNsaWNlKHBvcywgcG9zICsgdmFsdWVMZW4pO1xuICAgICAgICAgICAgcG9zICs9IHZhbHVlTGVuO1xuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc1RhZyh0YWdzLCBuYW1lLCB2YWx1ZVR5cGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG59XG5leHBvcnRzLkV4dGVuZGVkQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUgPSBFeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlO1xuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZS5ndWlkID0gR1VJRF8xLmRlZmF1bHQuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3Q7XG4vKipcbiAqIDQuMSBFeHRlbmRlZCBTdHJlYW0gUHJvcGVydGllcyBPYmplY3QgKG9wdGlvbmFsLCAxIHBlciBtZWRpYSBzdHJlYW0pXG4gKiBSZWY6IGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8wNF9vYmplY3RzX2luX3RoZV9hc2ZfaGVhZGVyX2V4dGVuc2lvbl9vYmplY3QuaHRtbCM0XzFcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRUaW1lOiBUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGVuZFRpbWU6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIGRhdGFCaXRyYXRlOiBidWYucmVhZEludDMyTEUob2ZmICsgMTIpLFxuICAgICAgICAgICAgYnVmZmVyU2l6ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDE2KSxcbiAgICAgICAgICAgIGluaXRpYWxCdWZmZXJGdWxsbmVzczogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDIwKSxcbiAgICAgICAgICAgIGFsdGVybmF0ZURhdGFCaXRyYXRlOiBidWYucmVhZEludDMyTEUob2ZmICsgMjQpLFxuICAgICAgICAgICAgYWx0ZXJuYXRlQnVmZmVyU2l6ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDI4KSxcbiAgICAgICAgICAgIGFsdGVybmF0ZUluaXRpYWxCdWZmZXJGdWxsbmVzczogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDMyKSxcbiAgICAgICAgICAgIG1heGltdW1PYmplY3RTaXplOiBidWYucmVhZEludDMyTEUob2ZmICsgMzYpLFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICByZWxpYWJsZUZsYWc6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYnVmLCBvZmYgKyA0MCwgMCksXG4gICAgICAgICAgICAgICAgc2Vla2FibGVGbGFnOiBVdGlsXzEuZGVmYXVsdC5zdHJ0b2tCSVRTRVQuZ2V0KGJ1Ziwgb2ZmICsgNDAsIDEpLFxuICAgICAgICAgICAgICAgIHJlc2VuZExpdmVDbGVhbnBvaW50c0ZsYWc6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYnVmLCBvZmYgKyA0MCwgMilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBmbGFnc051bWVyaWM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA2NCksXG4gICAgICAgICAgICBzdHJlYW1OdW1iZXI6IGJ1Zi5yZWFkSW50MTZMRShvZmYgKyA0MiksXG4gICAgICAgICAgICBzdHJlYW1MYW5ndWFnZUlkOiBidWYucmVhZEludDE2TEUob2ZmICsgNDQpLFxuICAgICAgICAgICAgYXZlcmFnZVRpbWVQZXJGcmFtZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDUyKSxcbiAgICAgICAgICAgIHN0cmVhbU5hbWVDb3VudDogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDU0KSxcbiAgICAgICAgICAgIHBheWxvYWRFeHRlbnNpb25TeXN0ZW1zOiBidWYucmVhZEludDMyTEUob2ZmICsgNTYpLFxuICAgICAgICAgICAgc3RyZWFtTmFtZXM6IFtdLFxuICAgICAgICAgICAgc3RyZWFtUHJvcGVydGllc09iamVjdDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGUgPSBFeHRlbmRlZFN0cmVhbVByb3BlcnRpZXNPYmplY3RTdGF0ZTtcbkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdFN0YXRlLmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5FeHRlbmRlZFN0cmVhbVByb3BlcnRpZXNPYmplY3Q7XG4vKipcbiAqIDQuNyAgTWV0YWRhdGEgT2JqZWN0IChvcHRpb25hbCwgMCBvciAxKVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDRfb2JqZWN0c19pbl90aGVfYXNmX2hlYWRlcl9leHRlbnNpb25fb2JqZWN0Lmh0bWwjNF83XG4gKi9cbmNsYXNzIE1ldGFkYXRhT2JqZWN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICBjb25zdCB0YWdzID0gW107XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uUmVjb3Jkc0NvdW50ID0gYnVmLnJlYWRVSW50MTZMRShvZmYpO1xuICAgICAgICBsZXQgcG9zID0gb2ZmICsgMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvblJlY29yZHNDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwb3MgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVMZW4gPSBidWYucmVhZFVJbnQxNkxFKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gYnVmLnJlYWRVSW50MTZMRShwb3MpO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gYnVmLnJlYWRVSW50MzJMRShwb3MpO1xuICAgICAgICAgICAgcG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gQXNmVXRpbF8xLkFzZlV0aWwucGFyc2VVbmljb2RlQXR0cihidWYuc2xpY2UocG9zLCBwb3MgKyBuYW1lTGVuKSk7XG4gICAgICAgICAgICBwb3MgKz0gbmFtZUxlbjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWYuc2xpY2UocG9zLCBwb3MgKyBkYXRhTGVuKTtcbiAgICAgICAgICAgIHBvcyArPSBkYXRhTGVuO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VBdHRyID0gQXNmVXRpbF8xLkFzZlV0aWwuZ2V0UGFyc2VyRm9yQXR0cihkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlQXR0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCB2YWx1ZSBoZWFkZXJUeXBlOiAnICsgZGF0YVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc1RhZyh0YWdzLCBuYW1lLCBkYXRhVHlwZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxufVxuZXhwb3J0cy5NZXRhZGF0YU9iamVjdFN0YXRlID0gTWV0YWRhdGFPYmplY3RTdGF0ZTtcbk1ldGFkYXRhT2JqZWN0U3RhdGUuZ3VpZCA9IEdVSURfMS5kZWZhdWx0Lk1ldGFkYXRhT2JqZWN0O1xuLy8gNC44XHRNZXRhZGF0YSBMaWJyYXJ5IE9iamVjdCAob3B0aW9uYWwsIDAgb3IgMSlcbmNsYXNzIE1ldGFkYXRhTGlicmFyeU9iamVjdFN0YXRlIGV4dGVuZHMgTWV0YWRhdGFPYmplY3RTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5NZXRhZGF0YUxpYnJhcnlPYmplY3RTdGF0ZSA9IE1ldGFkYXRhTGlicmFyeU9iamVjdFN0YXRlO1xuTWV0YWRhdGFMaWJyYXJ5T2JqZWN0U3RhdGUuZ3VpZCA9IEdVSURfMS5kZWZhdWx0Lk1ldGFkYXRhTGlicmFyeU9iamVjdDtcbi8qKlxuICogUmVmOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDc1Nzk3Nyh2PXZzLjg1KS5hc3B4XG4gKi9cbmNsYXNzIFdtUGljdHVyZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGJhc2U2NHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGJhc2U2NHN0ciwgJ2Jhc2U2NCcpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHBpYyA9IG5ldyBXbVBpY3R1cmVUb2tlbihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHBpYy5nZXQoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgZ2V0KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHR5cGVJZCA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KyspO1xuICAgICAgICBjb25zdCBzaXplID0gYnVmZmVyLnJlYWRJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGxldCBpbmRleCA9IDU7XG4gICAgICAgIHdoaWxlIChidWZmZXIucmVhZFVJbnQxNkJFKGluZGV4KSAhPT0gMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXQgPSBidWZmZXIuc2xpY2UoNSwgaW5kZXgpLnRvU3RyaW5nKCd1dGYxNmxlJyk7XG4gICAgICAgIHdoaWxlIChidWZmZXIucmVhZFVJbnQxNkJFKGluZGV4KSAhPT0gMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGJ1ZmZlci5zbGljZSg1LCBpbmRleCkudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IElEM3YyVG9rZW5fMS5BdHRhY2hlZFBpY3R1cmVUeXBlW3R5cGVJZF0sXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBkYXRhOiBidWZmZXIuc2xpY2UoaW5kZXggKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV21QaWN0dXJlVG9rZW4gPSBXbVBpY3R1cmVUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzZk9iamVjdC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/asf/AsfObject.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/asf/AsfParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfParser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsfParser = void 0;\nconst type_1 = __webpack_require__(/*! ../type */ \"./node_modules/music-metadata/lib/type.js\");\nconst GUID_1 = __webpack_require__(/*! ./GUID */ \"./node_modules/music-metadata/lib/asf/GUID.js\");\nconst AsfObject = __webpack_require__(/*! ./AsfObject */ \"./node_modules/music-metadata/lib/asf/AsfObject.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst debug = _debug('music-metadata:parser:ASF');\nconst headerType = 'asf';\n/**\n * Windows Media Metadata Usage Guidelines\n *   Ref: https://msdn.microsoft.com/en-us/library/ms867702.aspx\n *\n * Ref:\n *   https://tools.ietf.org/html/draft-fleischman-asf-01\n *   https://hwiegman.home.xs4all.nl/fileformats/asf/ASF_Specification.pdf\n *   http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html\n *   https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx\n */\nclass AsfParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);\n        if (!header.objectId.equals(GUID_1.default.HeaderObject)) {\n            throw new Error('expected asf header; but was not found; got: ' + header.objectId.str);\n        }\n        try {\n            await this.parseObjectHeader(header.numberOfHeaderObjects);\n        }\n        catch (err) {\n            debug('Error while parsing ASF: %s', err);\n        }\n    }\n    async parseObjectHeader(numberOfObjectHeaders) {\n        let tags;\n        do {\n            // Parse common header of the ASF Object (3.1)\n            const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);\n            // Parse data part of the ASF Object\n            debug('header GUID=%s', header.objectId.str);\n            switch (header.objectId.str) {\n                case AsfObject.FilePropertiesObject.guid.str: // 3.2\n                    const fpo = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));\n                    this.metadata.setFormat('duration', fpo.playDuration / 10000000);\n                    this.metadata.setFormat('bitrate', fpo.maximumBitrate);\n                    break;\n                case AsfObject.StreamPropertiesObject.guid.str: // 3.3\n                    const spo = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));\n                    this.metadata.setFormat('container', 'ASF/' + spo.streamType);\n                    break;\n                case AsfObject.HeaderExtensionObject.guid.str: // 3.4\n                    const extHeader = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());\n                    await this.parseExtensionObject(extHeader.extensionDataSize);\n                    break;\n                case AsfObject.ContentDescriptionObjectState.guid.str: // 3.10\n                    tags = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header));\n                    this.addTags(tags);\n                    break;\n                case AsfObject.ExtendedContentDescriptionObjectState.guid.str: // 3.11\n                    tags = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header));\n                    this.addTags(tags);\n                    break;\n                case GUID_1.default.CodecListObject.str:\n                    const codecs = await AsfObject.readCodecEntries(this.tokenizer);\n                    codecs.forEach(codec => {\n                        this.metadata.addStreamInfo({\n                            type: codec.type.videoCodec ? type_1.TrackType.video : type_1.TrackType.audio,\n                            codecName: codec.codecName\n                        });\n                    });\n                    const audioCodecs = codecs.filter(codec => codec.type.audioCodec).map(codec => codec.codecName).join('/');\n                    this.metadata.setFormat('codec', audioCodecs);\n                    break;\n                case GUID_1.default.StreamBitratePropertiesObject.str:\n                    // ToDo?\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                case GUID_1.default.PaddingObject.str:\n                    // ToDo: register bytes pad\n                    debug('Padding: %s bytes', header.objectSize - AsfObject.HeaderObjectToken.len);\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                default:\n                    this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);\n                    debug('Ignore ASF-Object-GUID: %s', header.objectId.str);\n                    await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));\n            }\n        } while (--numberOfObjectHeaders);\n        // done\n    }\n    addTags(tags) {\n        tags.forEach(tag => {\n            this.metadata.addTag(headerType, tag.id, tag.value);\n        });\n    }\n    async parseExtensionObject(extensionSize) {\n        do {\n            // Parse common header of the ASF Object (3.1)\n            const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);\n            // Parse data part of the ASF Object\n            switch (header.objectId.str) {\n                case AsfObject.ExtendedStreamPropertiesObjectState.guid.str: // 4.1\n                    // ToDo: extended stream header properties are ignored\n                    await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));\n                    break;\n                case AsfObject.MetadataObjectState.guid.str: // 4.7\n                    const moTags = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));\n                    this.addTags(moTags);\n                    break;\n                case AsfObject.MetadataLibraryObjectState.guid.str: // 4.8\n                    const mlTags = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));\n                    this.addTags(mlTags);\n                    break;\n                case GUID_1.default.PaddingObject.str:\n                    // ToDo: register bytes pad\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                case GUID_1.default.CompatibilityObject.str:\n                    this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                case GUID_1.default.ASF_Index_Placeholder_Object.str:\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                default:\n                    this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);\n                    // console.log(\"Ignore ASF-Object-GUID: %s\", header.objectId.str);\n                    await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));\n                    break;\n            }\n            extensionSize -= header.objectSize;\n        } while (extensionSize > 0);\n    }\n}\nexports.AsfParser = AsfParser;\n//# sourceMappingURL=AsfParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZQYXJzZXIuanM/NjVkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBEQUFTO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyw2REFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBYTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsOEVBQU87QUFDOUIsc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc2ZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB0eXBlXzEgPSByZXF1aXJlKFwiLi4vdHlwZVwiKTtcbmNvbnN0IEdVSURfMSA9IHJlcXVpcmUoXCIuL0dVSURcIik7XG5jb25zdCBBc2ZPYmplY3QgPSByZXF1aXJlKFwiLi9Bc2ZPYmplY3RcIik7XG5jb25zdCBfZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6QVNGJyk7XG5jb25zdCBoZWFkZXJUeXBlID0gJ2FzZic7XG4vKipcbiAqIFdpbmRvd3MgTWVkaWEgTWV0YWRhdGEgVXNhZ2UgR3VpZGVsaW5lc1xuICogICBSZWY6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM4Njc3MDIuYXNweFxuICpcbiAqIFJlZjpcbiAqICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWZsZWlzY2htYW4tYXNmLTAxXG4gKiAgIGh0dHBzOi8vaHdpZWdtYW4uaG9tZS54czRhbGwubmwvZmlsZWZvcm1hdHMvYXNmL0FTRl9TcGVjaWZpY2F0aW9uLnBkZlxuICogICBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvaW5kZXguaHRtbFxuICogICBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9lZTY2MzU3NSh2PXZzLjg1KS5hc3B4XG4gKi9cbmNsYXNzIEFzZlBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGFzeW5jIHBhcnNlKCkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oQXNmT2JqZWN0LlRvcExldmVsSGVhZGVyT2JqZWN0VG9rZW4pO1xuICAgICAgICBpZiAoIWhlYWRlci5vYmplY3RJZC5lcXVhbHMoR1VJRF8xLmRlZmF1bHQuSGVhZGVyT2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhc2YgaGVhZGVyOyBidXQgd2FzIG5vdCBmb3VuZDsgZ290OiAnICsgaGVhZGVyLm9iamVjdElkLnN0cik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VPYmplY3RIZWFkZXIoaGVhZGVyLm51bWJlck9mSGVhZGVyT2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVidWcoJ0Vycm9yIHdoaWxlIHBhcnNpbmcgQVNGOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VPYmplY3RIZWFkZXIobnVtYmVyT2ZPYmplY3RIZWFkZXJzKSB7XG4gICAgICAgIGxldCB0YWdzO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb21tb24gaGVhZGVyIG9mIHRoZSBBU0YgT2JqZWN0ICgzLjEpXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oQXNmT2JqZWN0LkhlYWRlck9iamVjdFRva2VuKTtcbiAgICAgICAgICAgIC8vIFBhcnNlIGRhdGEgcGFydCBvZiB0aGUgQVNGIE9iamVjdFxuICAgICAgICAgICAgZGVidWcoJ2hlYWRlciBHVUlEPSVzJywgaGVhZGVyLm9iamVjdElkLnN0cik7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci5vYmplY3RJZC5zdHIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFzZk9iamVjdC5GaWxlUHJvcGVydGllc09iamVjdC5ndWlkLnN0cjogLy8gMy4yXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZwbyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0LkZpbGVQcm9wZXJ0aWVzT2JqZWN0KGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBmcG8ucGxheUR1cmF0aW9uIC8gMTAwMDAwMDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGZwby5tYXhpbXVtQml0cmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXNmT2JqZWN0LlN0cmVhbVByb3BlcnRpZXNPYmplY3QuZ3VpZC5zdHI6IC8vIDMuM1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcG8gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0KGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ0FTRi8nICsgc3BvLnN0cmVhbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEFzZk9iamVjdC5IZWFkZXJFeHRlbnNpb25PYmplY3QuZ3VpZC5zdHI6IC8vIDMuNFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5IZWFkZXJFeHRlbnNpb25PYmplY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VFeHRlbnNpb25PYmplY3QoZXh0SGVhZGVyLmV4dGVuc2lvbkRhdGFTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUuZ3VpZC5zdHI6IC8vIDMuMTBcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0LkNvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlKGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZ3ModGFncyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXNmT2JqZWN0LkV4dGVuZGVkQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUuZ3VpZC5zdHI6IC8vIDMuMTFcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0LkV4dGVuZGVkQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFncyh0YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5Db2RlY0xpc3RPYmplY3Quc3RyOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlY3MgPSBhd2FpdCBBc2ZPYmplY3QucmVhZENvZGVjRW50cmllcyh0aGlzLnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkU3RyZWFtSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29kZWMudHlwZS52aWRlb0NvZGVjID8gdHlwZV8xLlRyYWNrVHlwZS52aWRlbyA6IHR5cGVfMS5UcmFja1R5cGUuYXVkaW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNOYW1lOiBjb2RlYy5jb2RlY05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXVkaW9Db2RlY3MgPSBjb2RlY3MuZmlsdGVyKGNvZGVjID0+IGNvZGVjLnR5cGUuYXVkaW9Db2RlYykubWFwKGNvZGVjID0+IGNvZGVjLmNvZGVjTmFtZSkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCBhdWRpb0NvZGVjcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR1VJRF8xLmRlZmF1bHQuU3RyZWFtQml0cmF0ZVByb3BlcnRpZXNPYmplY3Quc3RyOlxuICAgICAgICAgICAgICAgICAgICAvLyBUb0RvP1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoaGVhZGVyLm9iamVjdFNpemUgLSBBc2ZPYmplY3QuSGVhZGVyT2JqZWN0VG9rZW4ubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5QYWRkaW5nT2JqZWN0LnN0cjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9EbzogcmVnaXN0ZXIgYnl0ZXMgcGFkXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdQYWRkaW5nOiAlcyBieXRlcycsIGhlYWRlci5vYmplY3RTaXplIC0gQXNmT2JqZWN0LkhlYWRlck9iamVjdFRva2VuLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIub2JqZWN0U2l6ZSAtIEFzZk9iamVjdC5IZWFkZXJPYmplY3RUb2tlbi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0lnbm9yZSBBU0YtT2JqZWN0LUdVSUQ6ICcgKyBoZWFkZXIub2JqZWN0SWQuc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ0lnbm9yZSBBU0YtT2JqZWN0LUdVSUQ6ICVzJywgaGVhZGVyLm9iamVjdElkLnN0cik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0Lklnbm9yZU9iamVjdFN0YXRlKGhlYWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgtLW51bWJlck9mT2JqZWN0SGVhZGVycyk7XG4gICAgICAgIC8vIGRvbmVcbiAgICB9XG4gICAgYWRkVGFncyh0YWdzKSB7XG4gICAgICAgIHRhZ3MuZm9yRWFjaCh0YWcgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoaGVhZGVyVHlwZSwgdGFnLmlkLCB0YWcudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VFeHRlbnNpb25PYmplY3QoZXh0ZW5zaW9uU2l6ZSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb21tb24gaGVhZGVyIG9mIHRoZSBBU0YgT2JqZWN0ICgzLjEpXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oQXNmT2JqZWN0LkhlYWRlck9iamVjdFRva2VuKTtcbiAgICAgICAgICAgIC8vIFBhcnNlIGRhdGEgcGFydCBvZiB0aGUgQVNGIE9iamVjdFxuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXIub2JqZWN0SWQuc3RyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGUuZ3VpZC5zdHI6IC8vIDQuMVxuICAgICAgICAgICAgICAgICAgICAvLyBUb0RvOiBleHRlbmRlZCBzdHJlYW0gaGVhZGVyIHByb3BlcnRpZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBc2ZPYmplY3QuRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXNmT2JqZWN0Lk1ldGFkYXRhT2JqZWN0U3RhdGUuZ3VpZC5zdHI6IC8vIDQuN1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb1RhZ3MgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5NZXRhZGF0YU9iamVjdFN0YXRlKGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZ3MobW9UYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuTWV0YWRhdGFMaWJyYXJ5T2JqZWN0U3RhdGUuZ3VpZC5zdHI6IC8vIDQuOFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtbFRhZ3MgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5NZXRhZGF0YUxpYnJhcnlPYmplY3RTdGF0ZShoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWdzKG1sVGFncyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR1VJRF8xLmRlZmF1bHQuUGFkZGluZ09iamVjdC5zdHI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvRG86IHJlZ2lzdGVyIGJ5dGVzIHBhZFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoaGVhZGVyLm9iamVjdFNpemUgLSBBc2ZPYmplY3QuSGVhZGVyT2JqZWN0VG9rZW4ubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5Db21wYXRpYmlsaXR5T2JqZWN0LnN0cjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5vYmplY3RTaXplIC0gQXNmT2JqZWN0LkhlYWRlck9iamVjdFRva2VuLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR1VJRF8xLmRlZmF1bHQuQVNGX0luZGV4X1BsYWNlaG9sZGVyX09iamVjdC5zdHI6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIub2JqZWN0U2l6ZSAtIEFzZk9iamVjdC5IZWFkZXJPYmplY3RUb2tlbi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0lnbm9yZSBBU0YtT2JqZWN0LUdVSUQ6ICcgKyBoZWFkZXIub2JqZWN0SWQuc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJJZ25vcmUgQVNGLU9iamVjdC1HVUlEOiAlc1wiLCBoZWFkZXIub2JqZWN0SWQuc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBc2ZPYmplY3QuSWdub3JlT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5zaW9uU2l6ZSAtPSBoZWFkZXIub2JqZWN0U2l6ZTtcbiAgICAgICAgfSB3aGlsZSAoZXh0ZW5zaW9uU2l6ZSA+IDApO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNmUGFyc2VyID0gQXNmUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNmUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/asf/AsfParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/asf/AsfTagMapper.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfTagMapper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsfTagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * ASF Metadata tag mappings.\n * See http://msdn.microsoft.com/en-us/library/ms867702.aspx\n */\nconst asfTagMap = {\n    Title: 'title',\n    Author: 'artist',\n    'WM/AlbumArtist': 'albumartist',\n    'WM/AlbumTitle': 'album',\n    'WM/Year': 'date',\n    'WM/OriginalReleaseTime': 'originaldate',\n    'WM/OriginalReleaseYear': 'originalyear',\n    Description: 'comment',\n    'WM/TrackNumber': 'track',\n    'WM/PartOfSet': 'disk',\n    'WM/Genre': 'genre',\n    'WM/Composer': 'composer',\n    'WM/Lyrics': 'lyrics',\n    'WM/AlbumSortOrder': 'albumsort',\n    'WM/TitleSortOrder': 'titlesort',\n    'WM/ArtistSortOrder': 'artistsort',\n    'WM/AlbumArtistSortOrder': 'albumartistsort',\n    'WM/ComposerSortOrder': 'composersort',\n    'WM/Writer': 'lyricist',\n    'WM/Conductor': 'conductor',\n    'WM/ModifiedBy': 'remixer',\n    'WM/Engineer': 'engineer',\n    'WM/Producer': 'producer',\n    'WM/DJMixer': 'djmixer',\n    'WM/Mixer': 'mixer',\n    'WM/Publisher': 'label',\n    'WM/ContentGroupDescription': 'grouping',\n    'WM/SubTitle': 'subtitle',\n    'WM/SetSubTitle': 'discsubtitle',\n    // 'WM/PartOfSet': 'totaldiscs',\n    'WM/IsCompilation': 'compilation',\n    'WM/SharedUserRating': 'rating',\n    'WM/BeatsPerMinute': 'bpm',\n    'WM/Mood': 'mood',\n    'WM/Media': 'media',\n    'WM/CatalogNo': 'catalognumber',\n    'MusicBrainz/Album Status': 'releasestatus',\n    'MusicBrainz/Album Type': 'releasetype',\n    'MusicBrainz/Album Release Country': 'releasecountry',\n    'WM/Script': 'script',\n    'WM/Language': 'language',\n    Copyright: 'copyright',\n    LICENSE: 'license',\n    'WM/EncodedBy': 'encodedby',\n    'WM/EncodingSettings': 'encodersettings',\n    'WM/Barcode': 'barcode',\n    'WM/ISRC': 'isrc',\n    'MusicBrainz/Track Id': 'musicbrainz_recordingid',\n    'MusicBrainz/Release Track Id': 'musicbrainz_trackid',\n    'MusicBrainz/Album Id': 'musicbrainz_albumid',\n    'MusicBrainz/Artist Id': 'musicbrainz_artistid',\n    'MusicBrainz/Album Artist Id': 'musicbrainz_albumartistid',\n    'MusicBrainz/Release Group Id': 'musicbrainz_releasegroupid',\n    'MusicBrainz/Work Id': 'musicbrainz_workid',\n    'MusicBrainz/TRM Id': 'musicbrainz_trmid',\n    'MusicBrainz/Disc Id': 'musicbrainz_discid',\n    'Acoustid/Id': 'acoustid_id',\n    'Acoustid/Fingerprint': 'acoustid_fingerprint',\n    'MusicIP/PUID': 'musicip_puid',\n    'WM/ARTISTS': 'artists',\n    'WM/InitialKey': 'key',\n    ASIN: 'asin',\n    'WM/Work': 'work',\n    'WM/AuthorURL': 'website',\n    'WM/Picture': 'picture'\n};\nclass AsfTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    static toRating(rating) {\n        return {\n            rating: parseFloat(rating + 1) / 5\n        };\n    }\n    constructor() {\n        super(['asf'], asfTagMap);\n    }\n    postMap(tag) {\n        switch (tag.id) {\n            case 'WM/SharedUserRating':\n                const keys = tag.id.split(':');\n                tag.value = AsfTagMapper.toRating(tag.value);\n                tag.id = keys[0];\n                break;\n        }\n    }\n}\nexports.AsfTagMapper = AsfTagMapper;\n//# sourceMappingURL=AsfTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZUYWdNYXBwZXIuanM/ZGUzNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZUYWdNYXBwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNmVGFnTWFwcGVyID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuLyoqXG4gKiBBU0YgTWV0YWRhdGEgdGFnIG1hcHBpbmdzLlxuICogU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczg2NzcwMi5hc3B4XG4gKi9cbmNvbnN0IGFzZlRhZ01hcCA9IHtcbiAgICBUaXRsZTogJ3RpdGxlJyxcbiAgICBBdXRob3I6ICdhcnRpc3QnLFxuICAgICdXTS9BbGJ1bUFydGlzdCc6ICdhbGJ1bWFydGlzdCcsXG4gICAgJ1dNL0FsYnVtVGl0bGUnOiAnYWxidW0nLFxuICAgICdXTS9ZZWFyJzogJ2RhdGUnLFxuICAgICdXTS9PcmlnaW5hbFJlbGVhc2VUaW1lJzogJ29yaWdpbmFsZGF0ZScsXG4gICAgJ1dNL09yaWdpbmFsUmVsZWFzZVllYXInOiAnb3JpZ2luYWx5ZWFyJyxcbiAgICBEZXNjcmlwdGlvbjogJ2NvbW1lbnQnLFxuICAgICdXTS9UcmFja051bWJlcic6ICd0cmFjaycsXG4gICAgJ1dNL1BhcnRPZlNldCc6ICdkaXNrJyxcbiAgICAnV00vR2VucmUnOiAnZ2VucmUnLFxuICAgICdXTS9Db21wb3Nlcic6ICdjb21wb3NlcicsXG4gICAgJ1dNL0x5cmljcyc6ICdseXJpY3MnLFxuICAgICdXTS9BbGJ1bVNvcnRPcmRlcic6ICdhbGJ1bXNvcnQnLFxuICAgICdXTS9UaXRsZVNvcnRPcmRlcic6ICd0aXRsZXNvcnQnLFxuICAgICdXTS9BcnRpc3RTb3J0T3JkZXInOiAnYXJ0aXN0c29ydCcsXG4gICAgJ1dNL0FsYnVtQXJ0aXN0U29ydE9yZGVyJzogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgJ1dNL0NvbXBvc2VyU29ydE9yZGVyJzogJ2NvbXBvc2Vyc29ydCcsXG4gICAgJ1dNL1dyaXRlcic6ICdseXJpY2lzdCcsXG4gICAgJ1dNL0NvbmR1Y3Rvcic6ICdjb25kdWN0b3InLFxuICAgICdXTS9Nb2RpZmllZEJ5JzogJ3JlbWl4ZXInLFxuICAgICdXTS9FbmdpbmVlcic6ICdlbmdpbmVlcicsXG4gICAgJ1dNL1Byb2R1Y2VyJzogJ3Byb2R1Y2VyJyxcbiAgICAnV00vREpNaXhlcic6ICdkam1peGVyJyxcbiAgICAnV00vTWl4ZXInOiAnbWl4ZXInLFxuICAgICdXTS9QdWJsaXNoZXInOiAnbGFiZWwnLFxuICAgICdXTS9Db250ZW50R3JvdXBEZXNjcmlwdGlvbic6ICdncm91cGluZycsXG4gICAgJ1dNL1N1YlRpdGxlJzogJ3N1YnRpdGxlJyxcbiAgICAnV00vU2V0U3ViVGl0bGUnOiAnZGlzY3N1YnRpdGxlJyxcbiAgICAvLyAnV00vUGFydE9mU2V0JzogJ3RvdGFsZGlzY3MnLFxuICAgICdXTS9Jc0NvbXBpbGF0aW9uJzogJ2NvbXBpbGF0aW9uJyxcbiAgICAnV00vU2hhcmVkVXNlclJhdGluZyc6ICdyYXRpbmcnLFxuICAgICdXTS9CZWF0c1Blck1pbnV0ZSc6ICdicG0nLFxuICAgICdXTS9Nb29kJzogJ21vb2QnLFxuICAgICdXTS9NZWRpYSc6ICdtZWRpYScsXG4gICAgJ1dNL0NhdGFsb2dObyc6ICdjYXRhbG9nbnVtYmVyJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gU3RhdHVzJzogJ3JlbGVhc2VzdGF0dXMnLFxuICAgICdNdXNpY0JyYWluei9BbGJ1bSBUeXBlJzogJ3JlbGVhc2V0eXBlJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gUmVsZWFzZSBDb3VudHJ5JzogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICAnV00vU2NyaXB0JzogJ3NjcmlwdCcsXG4gICAgJ1dNL0xhbmd1YWdlJzogJ2xhbmd1YWdlJyxcbiAgICBDb3B5cmlnaHQ6ICdjb3B5cmlnaHQnLFxuICAgIExJQ0VOU0U6ICdsaWNlbnNlJyxcbiAgICAnV00vRW5jb2RlZEJ5JzogJ2VuY29kZWRieScsXG4gICAgJ1dNL0VuY29kaW5nU2V0dGluZ3MnOiAnZW5jb2RlcnNldHRpbmdzJyxcbiAgICAnV00vQmFyY29kZSc6ICdiYXJjb2RlJyxcbiAgICAnV00vSVNSQyc6ICdpc3JjJyxcbiAgICAnTXVzaWNCcmFpbnovVHJhY2sgSWQnOiAnbXVzaWNicmFpbnpfcmVjb3JkaW5naWQnLFxuICAgICdNdXNpY0JyYWluei9SZWxlYXNlIFRyYWNrIElkJzogJ211c2ljYnJhaW56X3RyYWNraWQnLFxuICAgICdNdXNpY0JyYWluei9BbGJ1bSBJZCc6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICAnTXVzaWNCcmFpbnovQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FydGlzdGlkJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FsYnVtYXJ0aXN0aWQnLFxuICAgICdNdXNpY0JyYWluei9SZWxlYXNlIEdyb3VwIElkJzogJ211c2ljYnJhaW56X3JlbGVhc2Vncm91cGlkJyxcbiAgICAnTXVzaWNCcmFpbnovV29yayBJZCc6ICdtdXNpY2JyYWluel93b3JraWQnLFxuICAgICdNdXNpY0JyYWluei9UUk0gSWQnOiAnbXVzaWNicmFpbnpfdHJtaWQnLFxuICAgICdNdXNpY0JyYWluei9EaXNjIElkJzogJ211c2ljYnJhaW56X2Rpc2NpZCcsXG4gICAgJ0Fjb3VzdGlkL0lkJzogJ2Fjb3VzdGlkX2lkJyxcbiAgICAnQWNvdXN0aWQvRmluZ2VycHJpbnQnOiAnYWNvdXN0aWRfZmluZ2VycHJpbnQnLFxuICAgICdNdXNpY0lQL1BVSUQnOiAnbXVzaWNpcF9wdWlkJyxcbiAgICAnV00vQVJUSVNUUyc6ICdhcnRpc3RzJyxcbiAgICAnV00vSW5pdGlhbEtleSc6ICdrZXknLFxuICAgIEFTSU46ICdhc2luJyxcbiAgICAnV00vV29yayc6ICd3b3JrJyxcbiAgICAnV00vQXV0aG9yVVJMJzogJ3dlYnNpdGUnLFxuICAgICdXTS9QaWN0dXJlJzogJ3BpY3R1cmUnXG59O1xuY2xhc3MgQXNmVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgc3RhdGljIHRvUmF0aW5nKHJhdGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF0aW5nOiBwYXJzZUZsb2F0KHJhdGluZyArIDEpIC8gNVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoWydhc2YnXSwgYXNmVGFnTWFwKTtcbiAgICB9XG4gICAgcG9zdE1hcCh0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcuaWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1dNL1NoYXJlZFVzZXJSYXRpbmcnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0YWcuaWQuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBBc2ZUYWdNYXBwZXIudG9SYXRpbmcodGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0YWcuaWQgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc2ZUYWdNYXBwZXIgPSBBc2ZUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc2ZUYWdNYXBwZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/asf/AsfTagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/asf/AsfUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfUtil.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsfUtil = void 0;\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nclass AsfUtil {\n    static getParserForAttr(i) {\n        return AsfUtil.attributeParsers[i];\n    }\n    static parseUnicodeAttr(buf) {\n        return Util_1.default.stripNulls(Util_1.default.decodeString(buf, \"utf16le\"));\n    }\n    static parseByteArrayAttr(buf) {\n        const newBuf = Buffer.alloc(buf.length);\n        buf.copy(newBuf);\n        return newBuf;\n    }\n    static parseBoolAttr(buf, offset = 0) {\n        return AsfUtil.parseWordAttr(buf, offset) === 1;\n    }\n    static parseDWordAttr(buf, offset = 0) {\n        return buf.readUInt32LE(offset);\n    }\n    static parseQWordAttr(buf, offset = 0) {\n        return Token.UINT64_LE.get(buf, offset);\n    }\n    static parseWordAttr(buf, offset = 0) {\n        return buf.readUInt16LE(offset);\n    }\n}\nexports.AsfUtil = AsfUtil;\nAsfUtil.attributeParsers = [\n    AsfUtil.parseUnicodeAttr,\n    AsfUtil.parseByteArrayAttr,\n    AsfUtil.parseBoolAttr,\n    AsfUtil.parseDWordAttr,\n    AsfUtil.parseQWordAttr,\n    AsfUtil.parseWordAttr,\n    AsfUtil.parseByteArrayAttr\n];\n//# sourceMappingURL=AsfUtil.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZVdGlsLmpzPzRjYzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlV0aWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNmVXRpbCA9IHZvaWQgMDtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY2xhc3MgQXNmVXRpbCB7XG4gICAgc3RhdGljIGdldFBhcnNlckZvckF0dHIoaSkge1xuICAgICAgICByZXR1cm4gQXNmVXRpbC5hdHRyaWJ1dGVQYXJzZXJzW2ldO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VVbmljb2RlQXR0cihidWYpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxfMS5kZWZhdWx0LnN0cmlwTnVsbHMoVXRpbF8xLmRlZmF1bHQuZGVjb2RlU3RyaW5nKGJ1ZiwgXCJ1dGYxNmxlXCIpKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQnl0ZUFycmF5QXR0cihidWYpIHtcbiAgICAgICAgY29uc3QgbmV3QnVmID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgpO1xuICAgICAgICBidWYuY29weShuZXdCdWYpO1xuICAgICAgICByZXR1cm4gbmV3QnVmO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VCb29sQXR0cihidWYsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIEFzZlV0aWwucGFyc2VXb3JkQXR0cihidWYsIG9mZnNldCkgPT09IDE7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZURXb3JkQXR0cihidWYsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUVdvcmRBdHRyKGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZnNldCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVdvcmRBdHRyKGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNmVXRpbCA9IEFzZlV0aWw7XG5Bc2ZVdGlsLmF0dHJpYnV0ZVBhcnNlcnMgPSBbXG4gICAgQXNmVXRpbC5wYXJzZVVuaWNvZGVBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCeXRlQXJyYXlBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCb29sQXR0cixcbiAgICBBc2ZVdGlsLnBhcnNlRFdvcmRBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VRV29yZEF0dHIsXG4gICAgQXNmVXRpbC5wYXJzZVdvcmRBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCeXRlQXJyYXlBdHRyXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNmVXRpbC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/asf/AsfUtil.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/asf/GUID.js":
/*!*****************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/GUID.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n// Implementation of the Advanced Systems Format (ASF)\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Ref:\n *    https://tools.ietf.org/html/draft-fleischman-asf-01, Appendix A: ASF GUIDs\n *    http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n *    http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html\n *\n *    http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n *\n *  ASF File Structure:\n *    https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx\n *\n *  ASF GUIDs:\n *    http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n *\n *    https://github.com/dji-sdk/FFmpeg/blob/master/libavformat/asf.c\n */\nclass GUID {\n    constructor(str) {\n        this.str = str;\n    }\n    static fromBin(bin, offset = 0) {\n        return new GUID(this.decode(bin, offset));\n    }\n    /**\n     * Decode GUID in format like \"B503BF5F-2EA9-CF11-8EE3-00C00C205365\"\n     * @param objectId Binary GUID\n     * @param offset Read offset in bytes, default 0\n     * @returns {string} GUID as dashed hexadecimal representation\n     */\n    static decode(objectId, offset = 0) {\n        const guid = objectId.readUInt32LE(offset).toString(16) + \"-\" +\n            objectId.readUInt16LE(offset + 4).toString(16) + \"-\" +\n            objectId.readUInt16LE(offset + 6).toString(16) + \"-\" +\n            objectId.readUInt16BE(offset + 8).toString(16) + \"-\" +\n            objectId.slice(offset + 10, offset + 16).toString('hex');\n        return guid.toUpperCase();\n    }\n    /**\n     * Decode stream type\n     * @param {string} mediaType\n     * @returns {string}\n     */\n    static decodeMediaType(mediaType) {\n        switch (mediaType.str) {\n            case GUID.AudioMedia.str: return 'audio';\n            case GUID.VideoMedia.str: return 'video';\n            case GUID.CommandMedia.str: return 'command';\n            case GUID.Degradable_JPEG_Media.str: return 'degradable-jpeg';\n            case GUID.FileTransferMedia.str: return 'file-transfer';\n            case GUID.BinaryMedia.str: return 'binary';\n        }\n    }\n    /**\n     * Encode GUID\n     * @param guid GUID like: \"B503BF5F-2EA9-CF11-8EE3-00C00C205365\"\n     * @returns {Buffer} Encoded Bnary GUID\n     */\n    static encode(str) {\n        const bin = Buffer.alloc(16);\n        bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0);\n        bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4);\n        bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6);\n        Buffer.from(str.slice(19, 23), \"hex\").copy(bin, 8);\n        Buffer.from(str.slice(24), \"hex\").copy(bin, 10);\n        return bin;\n    }\n    equals(guid) {\n        return this.str === guid.str;\n    }\n    toBin() {\n        return GUID.encode(this.str);\n    }\n}\nexports.default = GUID;\n// 10.1 Top-level ASF object GUIDs\nGUID.HeaderObject = new GUID(\"75B22630-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.DataObject = new GUID(\"75B22636-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.SimpleIndexObject = new GUID(\"33000890-E5B1-11CF-89F4-00A0C90349CB\");\nGUID.IndexObject = new GUID(\"D6E229D3-35DA-11D1-9034-00A0C90349BE\");\nGUID.MediaObjectIndexObject = new GUID(\"FEB103F8-12AD-4C64-840F-2A1D2F7AD48C\");\nGUID.TimecodeIndexObject = new GUID(\"3CB73FD0-0C4A-4803-953D-EDF7B6228F0C\");\n// 10.2 Header Object GUIDs\nGUID.FilePropertiesObject = new GUID(\"8CABDCA1-A947-11CF-8EE4-00C00C205365\");\nGUID.StreamPropertiesObject = new GUID(\"B7DC0791-A9B7-11CF-8EE6-00C00C205365\");\nGUID.HeaderExtensionObject = new GUID(\"5FBF03B5-A92E-11CF-8EE3-00C00C205365\");\nGUID.CodecListObject = new GUID(\"86D15240-311D-11D0-A3A4-00A0C90348F6\");\nGUID.ScriptCommandObject = new GUID(\"1EFB1A30-0B62-11D0-A39B-00A0C90348F6\");\nGUID.MarkerObject = new GUID(\"F487CD01-A951-11CF-8EE6-00C00C205365\");\nGUID.BitrateMutualExclusionObject = new GUID(\"D6E229DC-35DA-11D1-9034-00A0C90349BE\");\nGUID.ErrorCorrectionObject = new GUID(\"75B22635-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.ContentDescriptionObject = new GUID(\"75B22633-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.ExtendedContentDescriptionObject = new GUID(\"D2D0A440-E307-11D2-97F0-00A0C95EA850\");\nGUID.ContentBrandingObject = new GUID(\"2211B3FA-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.StreamBitratePropertiesObject = new GUID(\"7BF875CE-468D-11D1-8D82-006097C9A2B2\");\nGUID.ContentEncryptionObject = new GUID(\"2211B3FB-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.ExtendedContentEncryptionObject = new GUID(\"298AE614-2622-4C17-B935-DAE07EE9289C\");\nGUID.DigitalSignatureObject = new GUID(\"2211B3FC-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.PaddingObject = new GUID(\"1806D474-CADF-4509-A4BA-9AABCB96AAE8\");\n// 10.3 Header Extension Object GUIDs\nGUID.ExtendedStreamPropertiesObject = new GUID(\"14E6A5CB-C672-4332-8399-A96952065B5A\");\nGUID.AdvancedMutualExclusionObject = new GUID(\"A08649CF-4775-4670-8A16-6E35357566CD\");\nGUID.GroupMutualExclusionObject = new GUID(\"D1465A40-5A79-4338-B71B-E36B8FD6C249\");\nGUID.StreamPrioritizationObject = new GUID(\"D4FED15B-88D3-454F-81F0-ED5C45999E24\");\nGUID.BandwidthSharingObject = new GUID(\"A69609E6-517B-11D2-B6AF-00C04FD908E9\");\nGUID.LanguageListObject = new GUID(\"7C4346A9-EFE0-4BFC-B229-393EDE415C85\");\nGUID.MetadataObject = new GUID(\"C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA\");\nGUID.MetadataLibraryObject = new GUID(\"44231C94-9498-49D1-A141-1D134E457054\");\nGUID.IndexParametersObject = new GUID(\"D6E229DF-35DA-11D1-9034-00A0C90349BE\");\nGUID.MediaObjectIndexParametersObject = new GUID(\"6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7\");\nGUID.TimecodeIndexParametersObject = new GUID(\"F55E496D-9797-4B5D-8C8B-604DFE9BFB24\");\nGUID.CompatibilityObject = new GUID(\"26F18B5D-4584-47EC-9F5F-0E651F0452C9\");\nGUID.AdvancedContentEncryptionObject = new GUID(\"43058533-6981-49E6-9B74-AD12CB86D58C\");\n// 10.4 Stream Properties Object Stream Type GUIDs\nGUID.AudioMedia = new GUID(\"F8699E40-5B4D-11CF-A8FD-00805F5C442B\");\nGUID.VideoMedia = new GUID(\"BC19EFC0-5B4D-11CF-A8FD-00805F5C442B\");\nGUID.CommandMedia = new GUID(\"59DACFC0-59E6-11D0-A3AC-00A0C90348F6\");\nGUID.JFIF_Media = new GUID(\"B61BE100-5B4E-11CF-A8FD-00805F5C442B\");\nGUID.Degradable_JPEG_Media = new GUID(\"35907DE0-E415-11CF-A917-00805F5C442B\");\nGUID.FileTransferMedia = new GUID(\"91BD222C-F21C-497A-8B6D-5AA86BFC0185\");\nGUID.BinaryMedia = new GUID(\"3AFB65E2-47EF-40F2-AC2C-70A90D71D343\");\nGUID.ASF_Index_Placeholder_Object = new GUID(\"D9AADE20-7C17-4F9C-BC28-8555DD98E2A2\");\n//# sourceMappingURL=GUID.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9HVUlELmpzPzkxMzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYjtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9HVUlELmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgQWR2YW5jZWQgU3lzdGVtcyBGb3JtYXQgKEFTRilcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmVmOlxuICogICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWZsZWlzY2htYW4tYXNmLTAxLCBBcHBlbmRpeCBBOiBBU0YgR1VJRHNcbiAqICAgIGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8xMF9hc2ZfZ3VpZHMuaHRtbFxuICogICAgaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wL2luZGV4Lmh0bWxcbiAqXG4gKiAgICBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMTBfYXNmX2d1aWRzLmh0bWxcbiAqXG4gKiAgQVNGIEZpbGUgU3RydWN0dXJlOlxuICogICAgaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZWU2NjM1NzUodj12cy44NSkuYXNweFxuICpcbiAqICBBU0YgR1VJRHM6XG4gKiAgICBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMTBfYXNmX2d1aWRzLmh0bWxcbiAqXG4gKiAgICBodHRwczovL2dpdGh1Yi5jb20vZGppLXNkay9GRm1wZWcvYmxvYi9tYXN0ZXIvbGliYXZmb3JtYXQvYXNmLmNcbiAqL1xuY2xhc3MgR1VJRCB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyID0gc3RyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbihiaW4sIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHVUlEKHRoaXMuZGVjb2RlKGJpbiwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBHVUlEIGluIGZvcm1hdCBsaWtlIFwiQjUwM0JGNUYtMkVBOS1DRjExLThFRTMtMDBDMDBDMjA1MzY1XCJcbiAgICAgKiBAcGFyYW0gb2JqZWN0SWQgQmluYXJ5IEdVSURcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFJlYWQgb2Zmc2V0IGluIGJ5dGVzLCBkZWZhdWx0IDBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBHVUlEIGFzIGRhc2hlZCBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNvZGUob2JqZWN0SWQsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZ3VpZCA9IG9iamVjdElkLnJlYWRVSW50MzJMRShvZmZzZXQpLnRvU3RyaW5nKDE2KSArIFwiLVwiICtcbiAgICAgICAgICAgIG9iamVjdElkLnJlYWRVSW50MTZMRShvZmZzZXQgKyA0KS50b1N0cmluZygxNikgKyBcIi1cIiArXG4gICAgICAgICAgICBvYmplY3RJZC5yZWFkVUludDE2TEUob2Zmc2V0ICsgNikudG9TdHJpbmcoMTYpICsgXCItXCIgK1xuICAgICAgICAgICAgb2JqZWN0SWQucmVhZFVJbnQxNkJFKG9mZnNldCArIDgpLnRvU3RyaW5nKDE2KSArIFwiLVwiICtcbiAgICAgICAgICAgIG9iamVjdElkLnNsaWNlKG9mZnNldCArIDEwLCBvZmZzZXQgKyAxNikudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICByZXR1cm4gZ3VpZC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgc3RyZWFtIHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFUeXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlTWVkaWFUeXBlKG1lZGlhVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKG1lZGlhVHlwZS5zdHIpIHtcbiAgICAgICAgICAgIGNhc2UgR1VJRC5BdWRpb01lZGlhLnN0cjogcmV0dXJuICdhdWRpbyc7XG4gICAgICAgICAgICBjYXNlIEdVSUQuVmlkZW9NZWRpYS5zdHI6IHJldHVybiAndmlkZW8nO1xuICAgICAgICAgICAgY2FzZSBHVUlELkNvbW1hbmRNZWRpYS5zdHI6IHJldHVybiAnY29tbWFuZCc7XG4gICAgICAgICAgICBjYXNlIEdVSUQuRGVncmFkYWJsZV9KUEVHX01lZGlhLnN0cjogcmV0dXJuICdkZWdyYWRhYmxlLWpwZWcnO1xuICAgICAgICAgICAgY2FzZSBHVUlELkZpbGVUcmFuc2Zlck1lZGlhLnN0cjogcmV0dXJuICdmaWxlLXRyYW5zZmVyJztcbiAgICAgICAgICAgIGNhc2UgR1VJRC5CaW5hcnlNZWRpYS5zdHI6IHJldHVybiAnYmluYXJ5JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgR1VJRFxuICAgICAqIEBwYXJhbSBndWlkIEdVSUQgbGlrZTogXCJCNTAzQkY1Ri0yRUE5LUNGMTEtOEVFMy0wMEMwMEMyMDUzNjVcIlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEVuY29kZWQgQm5hcnkgR1VJRFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoc3RyKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IEJ1ZmZlci5hbGxvYygxNik7XG4gICAgICAgIGJpbi53cml0ZVVJbnQzMkxFKHBhcnNlSW50KHN0ci5zbGljZSgwLCA4KSwgMTYpLCAwKTtcbiAgICAgICAgYmluLndyaXRlVUludDE2TEUocGFyc2VJbnQoc3RyLnNsaWNlKDksIDEzKSwgMTYpLCA0KTtcbiAgICAgICAgYmluLndyaXRlVUludDE2TEUocGFyc2VJbnQoc3RyLnNsaWNlKDE0LCAxOCksIDE2KSwgNik7XG4gICAgICAgIEJ1ZmZlci5mcm9tKHN0ci5zbGljZSgxOSwgMjMpLCBcImhleFwiKS5jb3B5KGJpbiwgOCk7XG4gICAgICAgIEJ1ZmZlci5mcm9tKHN0ci5zbGljZSgyNCksIFwiaGV4XCIpLmNvcHkoYmluLCAxMCk7XG4gICAgICAgIHJldHVybiBiaW47XG4gICAgfVxuICAgIGVxdWFscyhndWlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ciA9PT0gZ3VpZC5zdHI7XG4gICAgfVxuICAgIHRvQmluKCkge1xuICAgICAgICByZXR1cm4gR1VJRC5lbmNvZGUodGhpcy5zdHIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdVSUQ7XG4vLyAxMC4xIFRvcC1sZXZlbCBBU0Ygb2JqZWN0IEdVSURzXG5HVUlELkhlYWRlck9iamVjdCA9IG5ldyBHVUlEKFwiNzVCMjI2MzAtNjY4RS0xMUNGLUE2RDktMDBBQTAwNjJDRTZDXCIpO1xuR1VJRC5EYXRhT2JqZWN0ID0gbmV3IEdVSUQoXCI3NUIyMjYzNi02NjhFLTExQ0YtQTZEOS0wMEFBMDA2MkNFNkNcIik7XG5HVUlELlNpbXBsZUluZGV4T2JqZWN0ID0gbmV3IEdVSUQoXCIzMzAwMDg5MC1FNUIxLTExQ0YtODlGNC0wMEEwQzkwMzQ5Q0JcIik7XG5HVUlELkluZGV4T2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlEMy0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELk1lZGlhT2JqZWN0SW5kZXhPYmplY3QgPSBuZXcgR1VJRChcIkZFQjEwM0Y4LTEyQUQtNEM2NC04NDBGLTJBMUQyRjdBRDQ4Q1wiKTtcbkdVSUQuVGltZWNvZGVJbmRleE9iamVjdCA9IG5ldyBHVUlEKFwiM0NCNzNGRDAtMEM0QS00ODAzLTk1M0QtRURGN0I2MjI4RjBDXCIpO1xuLy8gMTAuMiBIZWFkZXIgT2JqZWN0IEdVSURzXG5HVUlELkZpbGVQcm9wZXJ0aWVzT2JqZWN0ID0gbmV3IEdVSUQoXCI4Q0FCRENBMS1BOTQ3LTExQ0YtOEVFNC0wMEMwMEMyMDUzNjVcIik7XG5HVUlELlN0cmVhbVByb3BlcnRpZXNPYmplY3QgPSBuZXcgR1VJRChcIkI3REMwNzkxLUE5QjctMTFDRi04RUU2LTAwQzAwQzIwNTM2NVwiKTtcbkdVSUQuSGVhZGVyRXh0ZW5zaW9uT2JqZWN0ID0gbmV3IEdVSUQoXCI1RkJGMDNCNS1BOTJFLTExQ0YtOEVFMy0wMEMwMEMyMDUzNjVcIik7XG5HVUlELkNvZGVjTGlzdE9iamVjdCA9IG5ldyBHVUlEKFwiODZEMTUyNDAtMzExRC0xMUQwLUEzQTQtMDBBMEM5MDM0OEY2XCIpO1xuR1VJRC5TY3JpcHRDb21tYW5kT2JqZWN0ID0gbmV3IEdVSUQoXCIxRUZCMUEzMC0wQjYyLTExRDAtQTM5Qi0wMEEwQzkwMzQ4RjZcIik7XG5HVUlELk1hcmtlck9iamVjdCA9IG5ldyBHVUlEKFwiRjQ4N0NEMDEtQTk1MS0xMUNGLThFRTYtMDBDMDBDMjA1MzY1XCIpO1xuR1VJRC5CaXRyYXRlTXV0dWFsRXhjbHVzaW9uT2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlEQy0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELkVycm9yQ29ycmVjdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiNzVCMjI2MzUtNjY4RS0xMUNGLUE2RDktMDBBQTAwNjJDRTZDXCIpO1xuR1VJRC5Db250ZW50RGVzY3JpcHRpb25PYmplY3QgPSBuZXcgR1VJRChcIjc1QjIyNjMzLTY2OEUtMTFDRi1BNkQ5LTAwQUEwMDYyQ0U2Q1wiKTtcbkdVSUQuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3QgPSBuZXcgR1VJRChcIkQyRDBBNDQwLUUzMDctMTFEMi05N0YwLTAwQTBDOTVFQTg1MFwiKTtcbkdVSUQuQ29udGVudEJyYW5kaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCIyMjExQjNGQS1CRDIzLTExRDItQjRCNy0wMEEwQzk1NUZDNkVcIik7XG5HVUlELlN0cmVhbUJpdHJhdGVQcm9wZXJ0aWVzT2JqZWN0ID0gbmV3IEdVSUQoXCI3QkY4NzVDRS00NjhELTExRDEtOEQ4Mi0wMDYwOTdDOUEyQjJcIik7XG5HVUlELkNvbnRlbnRFbmNyeXB0aW9uT2JqZWN0ID0gbmV3IEdVSUQoXCIyMjExQjNGQi1CRDIzLTExRDItQjRCNy0wMEEwQzk1NUZDNkVcIik7XG5HVUlELkV4dGVuZGVkQ29udGVudEVuY3J5cHRpb25PYmplY3QgPSBuZXcgR1VJRChcIjI5OEFFNjE0LTI2MjItNEMxNy1COTM1LURBRTA3RUU5Mjg5Q1wiKTtcbkdVSUQuRGlnaXRhbFNpZ25hdHVyZU9iamVjdCA9IG5ldyBHVUlEKFwiMjIxMUIzRkMtQkQyMy0xMUQyLUI0QjctMDBBMEM5NTVGQzZFXCIpO1xuR1VJRC5QYWRkaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCIxODA2RDQ3NC1DQURGLTQ1MDktQTRCQS05QUFCQ0I5NkFBRThcIik7XG4vLyAxMC4zIEhlYWRlciBFeHRlbnNpb24gT2JqZWN0IEdVSURzXG5HVUlELkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdCA9IG5ldyBHVUlEKFwiMTRFNkE1Q0ItQzY3Mi00MzMyLTgzOTktQTk2OTUyMDY1QjVBXCIpO1xuR1VJRC5BZHZhbmNlZE11dHVhbEV4Y2x1c2lvbk9iamVjdCA9IG5ldyBHVUlEKFwiQTA4NjQ5Q0YtNDc3NS00NjcwLThBMTYtNkUzNTM1NzU2NkNEXCIpO1xuR1VJRC5Hcm91cE11dHVhbEV4Y2x1c2lvbk9iamVjdCA9IG5ldyBHVUlEKFwiRDE0NjVBNDAtNUE3OS00MzM4LUI3MUItRTM2QjhGRDZDMjQ5XCIpO1xuR1VJRC5TdHJlYW1Qcmlvcml0aXphdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiRDRGRUQxNUItODhEMy00NTRGLTgxRjAtRUQ1QzQ1OTk5RTI0XCIpO1xuR1VJRC5CYW5kd2lkdGhTaGFyaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCJBNjk2MDlFNi01MTdCLTExRDItQjZBRi0wMEMwNEZEOTA4RTlcIik7XG5HVUlELkxhbmd1YWdlTGlzdE9iamVjdCA9IG5ldyBHVUlEKFwiN0M0MzQ2QTktRUZFMC00QkZDLUIyMjktMzkzRURFNDE1Qzg1XCIpO1xuR1VJRC5NZXRhZGF0YU9iamVjdCA9IG5ldyBHVUlEKFwiQzVGOENCRUEtNUJBRi00ODc3LTg0NjctQUE4QzQ0RkE0Q0NBXCIpO1xuR1VJRC5NZXRhZGF0YUxpYnJhcnlPYmplY3QgPSBuZXcgR1VJRChcIjQ0MjMxQzk0LTk0OTgtNDlEMS1BMTQxLTFEMTM0RTQ1NzA1NFwiKTtcbkdVSUQuSW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlERi0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELk1lZGlhT2JqZWN0SW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCI2QjIwM0JBRC0zRjExLTQ4RTQtQUNBOC1ENzYxM0RFMkNGQTdcIik7XG5HVUlELlRpbWVjb2RlSW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCJGNTVFNDk2RC05Nzk3LTRCNUQtOEM4Qi02MDRERkU5QkZCMjRcIik7XG5HVUlELkNvbXBhdGliaWxpdHlPYmplY3QgPSBuZXcgR1VJRChcIjI2RjE4QjVELTQ1ODQtNDdFQy05RjVGLTBFNjUxRjA0NTJDOVwiKTtcbkdVSUQuQWR2YW5jZWRDb250ZW50RW5jcnlwdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiNDMwNTg1MzMtNjk4MS00OUU2LTlCNzQtQUQxMkNCODZENThDXCIpO1xuLy8gMTAuNCBTdHJlYW0gUHJvcGVydGllcyBPYmplY3QgU3RyZWFtIFR5cGUgR1VJRHNcbkdVSUQuQXVkaW9NZWRpYSA9IG5ldyBHVUlEKFwiRjg2OTlFNDAtNUI0RC0xMUNGLUE4RkQtMDA4MDVGNUM0NDJCXCIpO1xuR1VJRC5WaWRlb01lZGlhID0gbmV3IEdVSUQoXCJCQzE5RUZDMC01QjRELTExQ0YtQThGRC0wMDgwNUY1QzQ0MkJcIik7XG5HVUlELkNvbW1hbmRNZWRpYSA9IG5ldyBHVUlEKFwiNTlEQUNGQzAtNTlFNi0xMUQwLUEzQUMtMDBBMEM5MDM0OEY2XCIpO1xuR1VJRC5KRklGX01lZGlhID0gbmV3IEdVSUQoXCJCNjFCRTEwMC01QjRFLTExQ0YtQThGRC0wMDgwNUY1QzQ0MkJcIik7XG5HVUlELkRlZ3JhZGFibGVfSlBFR19NZWRpYSA9IG5ldyBHVUlEKFwiMzU5MDdERTAtRTQxNS0xMUNGLUE5MTctMDA4MDVGNUM0NDJCXCIpO1xuR1VJRC5GaWxlVHJhbnNmZXJNZWRpYSA9IG5ldyBHVUlEKFwiOTFCRDIyMkMtRjIxQy00OTdBLThCNkQtNUFBODZCRkMwMTg1XCIpO1xuR1VJRC5CaW5hcnlNZWRpYSA9IG5ldyBHVUlEKFwiM0FGQjY1RTItNDdFRi00MEYyLUFDMkMtNzBBOTBENzFEMzQzXCIpO1xuR1VJRC5BU0ZfSW5kZXhfUGxhY2Vob2xkZXJfT2JqZWN0ID0gbmV3IEdVSUQoXCJEOUFBREUyMC03QzE3LTRGOUMtQkMyOC04NTU1REQ5OEUyQTJcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HVUlELmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/asf/GUID.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/BasicParser.js":
/*!***************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/BasicParser.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasicParser = void 0;\nclass BasicParser {\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n        this.options = options;\n        return this;\n    }\n}\nexports.BasicParser = BasicParser;\n//# sourceMappingURL=BasicParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9CYXNpY1BhcnNlci5qcz85NWM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vQmFzaWNQYXJzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzaWNQYXJzZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNpY1BhcnNlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBwYXJzZXIgd2l0aCBvdXRwdXQgKG1ldGFkYXRhKSwgaW5wdXQgKHRva2VuaXplcikgJiBwYXJzaW5nIG9wdGlvbnMgKG9wdGlvbnMpLlxuICAgICAqIEBwYXJhbSB7SU5hdGl2ZU1ldGFkYXRhQ29sbGVjdG9yfSBtZXRhZGF0YSBPdXRwdXRcbiAgICAgKiBAcGFyYW0ge0lUb2tlbml6ZXJ9IHRva2VuaXplciBJbnB1dFxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnMgUGFyc2luZyBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdChtZXRhZGF0YSwgdG9rZW5pemVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNQYXJzZXIgPSBCYXNpY1BhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2ljUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/BasicParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js":
/*!*************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CaseInsensitiveTagMap = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ./GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nclass CaseInsensitiveTagMap extends GenericTagMapper_1.CommonTagMapper {\n    constructor(tagTypes, tagMap) {\n        const upperCaseMap = {};\n        for (const tag of Object.keys(tagMap)) {\n            upperCaseMap[tag.toUpperCase()] = tagMap[tag];\n        }\n        super(tagTypes, upperCaseMap);\n    }\n    /**\n     * @tag  Native header tag\n     * @return common tag name (alias)\n     */\n    getCommonName(tag) {\n        return this.tagMap[tag.toUpperCase()];\n    }\n}\nexports.CaseInsensitiveTagMap = CaseInsensitiveTagMap;\n//# sourceMappingURL=CaseInsensitiveTagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXAuanM/NTNkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0Nhc2VJbnNlbnNpdGl2ZVRhZ01hcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYXNlSW5zZW5zaXRpdmVUYWdNYXAgPSB2b2lkIDA7XG5jb25zdCBHZW5lcmljVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlVGFnTWFwIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgY29uc3RydWN0b3IodGFnVHlwZXMsIHRhZ01hcCkge1xuICAgICAgICBjb25zdCB1cHBlckNhc2VNYXAgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgT2JqZWN0LmtleXModGFnTWFwKSkge1xuICAgICAgICAgICAgdXBwZXJDYXNlTWFwW3RhZy50b1VwcGVyQ2FzZSgpXSA9IHRhZ01hcFt0YWddO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHRhZ1R5cGVzLCB1cHBlckNhc2VNYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGFnICBOYXRpdmUgaGVhZGVyIHRhZ1xuICAgICAqIEByZXR1cm4gY29tbW9uIHRhZyBuYW1lIChhbGlhcylcbiAgICAgKi9cbiAgICBnZXRDb21tb25OYW1lKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdNYXBbdGFnLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FzZUluc2Vuc2l0aXZlVGFnTWFwID0gQ2FzZUluc2Vuc2l0aXZlVGFnTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FzZUluc2Vuc2l0aXZlVGFnTWFwLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/CombinedTagMapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/CombinedTagMapper.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CombinedTagMapper = void 0;\nconst ID3v1TagMap_1 = __webpack_require__(/*! ../id3v1/ID3v1TagMap */ \"./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js\");\nconst ID3v24TagMapper_1 = __webpack_require__(/*! ../id3v2/ID3v24TagMapper */ \"./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js\");\nconst AsfTagMapper_1 = __webpack_require__(/*! ../asf/AsfTagMapper */ \"./node_modules/music-metadata/lib/asf/AsfTagMapper.js\");\nconst ID3v22TagMapper_1 = __webpack_require__(/*! ../id3v2/ID3v22TagMapper */ \"./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js\");\nconst APEv2TagMapper_1 = __webpack_require__(/*! ../apev2/APEv2TagMapper */ \"./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js\");\nconst MP4TagMapper_1 = __webpack_require__(/*! ../mp4/MP4TagMapper */ \"./node_modules/music-metadata/lib/mp4/MP4TagMapper.js\");\nconst VorbisTagMapper_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisTagMapper */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js\");\nconst RiffInfoTagMap_1 = __webpack_require__(/*! ../riff/RiffInfoTagMap */ \"./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js\");\nconst MatroskaTagMapper_1 = __webpack_require__(/*! ../matroska/MatroskaTagMapper */ \"./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js\");\nclass CombinedTagMapper {\n    constructor() {\n        this.tagMappers = {};\n        [\n            new ID3v1TagMap_1.ID3v1TagMapper(),\n            new ID3v22TagMapper_1.ID3v22TagMapper(),\n            new ID3v24TagMapper_1.ID3v24TagMapper(),\n            new MP4TagMapper_1.MP4TagMapper(),\n            new MP4TagMapper_1.MP4TagMapper(),\n            new VorbisTagMapper_1.VorbisTagMapper(),\n            new APEv2TagMapper_1.APEv2TagMapper(),\n            new AsfTagMapper_1.AsfTagMapper(),\n            new RiffInfoTagMap_1.RiffInfoTagMapper(),\n            new MatroskaTagMapper_1.MatroskaTagMapper()\n        ].forEach(mapper => {\n            this.registerTagMapper(mapper);\n        });\n    }\n    /**\n     * Convert native to generic (common) tags\n     * @param tagType Originating tag format\n     * @param tag     Native tag to map to a generic tag id\n     * @param warnings\n     * @return Generic tag result (output of this function)\n     */\n    mapTag(tagType, tag, warnings) {\n        const tagMapper = this.tagMappers[tagType];\n        if (tagMapper) {\n            return this.tagMappers[tagType].mapGenericTag(tag, warnings);\n        }\n        throw new Error(\"No generic tag mapper defined for tag-format: \" + tagType);\n    }\n    registerTagMapper(genericTagMapper) {\n        for (const tagType of genericTagMapper.tagTypes) {\n            this.tagMappers[tagType] = genericTagMapper;\n        }\n    }\n}\nexports.CombinedTagMapper = CombinedTagMapper;\n//# sourceMappingURL=CombinedTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9Db21iaW5lZFRhZ01hcHBlci5qcz9hODY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEZBQTBCO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLGtGQUFxQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMsMEZBQXlCO0FBQzFELHVCQUF1QixtQkFBTyxDQUFDLGtGQUFxQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBK0I7QUFDakUseUJBQXlCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ3pELDRCQUE0QixtQkFBTyxDQUFDLHNHQUErQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vQ29tYmluZWRUYWdNYXBwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tYmluZWRUYWdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBJRDN2MVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2lkM3YxL0lEM3YxVGFnTWFwXCIpO1xuY29uc3QgSUQzdjI0VGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvSUQzdjI0VGFnTWFwcGVyXCIpO1xuY29uc3QgQXNmVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vYXNmL0FzZlRhZ01hcHBlclwiKTtcbmNvbnN0IElEM3YyMlRhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyMlRhZ01hcHBlclwiKTtcbmNvbnN0IEFQRXYyVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vYXBldjIvQVBFdjJUYWdNYXBwZXJcIik7XG5jb25zdCBNUDRUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tcDQvTVA0VGFnTWFwcGVyXCIpO1xuY29uc3QgVm9yYmlzVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vb2dnL3ZvcmJpcy9Wb3JiaXNUYWdNYXBwZXJcIik7XG5jb25zdCBSaWZmSW5mb1RhZ01hcF8xID0gcmVxdWlyZShcIi4uL3JpZmYvUmlmZkluZm9UYWdNYXBcIik7XG5jb25zdCBNYXRyb3NrYVRhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hdHJvc2thL01hdHJvc2thVGFnTWFwcGVyXCIpO1xuY2xhc3MgQ29tYmluZWRUYWdNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhZ01hcHBlcnMgPSB7fTtcbiAgICAgICAgW1xuICAgICAgICAgICAgbmV3IElEM3YxVGFnTWFwXzEuSUQzdjFUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBJRDN2MjJUYWdNYXBwZXJfMS5JRDN2MjJUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBJRDN2MjRUYWdNYXBwZXJfMS5JRDN2MjRUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBNUDRUYWdNYXBwZXJfMS5NUDRUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBNUDRUYWdNYXBwZXJfMS5NUDRUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBWb3JiaXNUYWdNYXBwZXJfMS5Wb3JiaXNUYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBBUEV2MlRhZ01hcHBlcl8xLkFQRXYyVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgQXNmVGFnTWFwcGVyXzEuQXNmVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgUmlmZkluZm9UYWdNYXBfMS5SaWZmSW5mb1RhZ01hcHBlcigpLFxuICAgICAgICAgICAgbmV3IE1hdHJvc2thVGFnTWFwcGVyXzEuTWF0cm9za2FUYWdNYXBwZXIoKVxuICAgICAgICBdLmZvckVhY2gobWFwcGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUYWdNYXBwZXIobWFwcGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRvIGdlbmVyaWMgKGNvbW1vbikgdGFnc1xuICAgICAqIEBwYXJhbSB0YWdUeXBlIE9yaWdpbmF0aW5nIHRhZyBmb3JtYXRcbiAgICAgKiBAcGFyYW0gdGFnICAgICBOYXRpdmUgdGFnIHRvIG1hcCB0byBhIGdlbmVyaWMgdGFnIGlkXG4gICAgICogQHBhcmFtIHdhcm5pbmdzXG4gICAgICogQHJldHVybiBHZW5lcmljIHRhZyByZXN1bHQgKG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uKVxuICAgICAqL1xuICAgIG1hcFRhZyh0YWdUeXBlLCB0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIGNvbnN0IHRhZ01hcHBlciA9IHRoaXMudGFnTWFwcGVyc1t0YWdUeXBlXTtcbiAgICAgICAgaWYgKHRhZ01hcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnTWFwcGVyc1t0YWdUeXBlXS5tYXBHZW5lcmljVGFnKHRhZywgd2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGdlbmVyaWMgdGFnIG1hcHBlciBkZWZpbmVkIGZvciB0YWctZm9ybWF0OiBcIiArIHRhZ1R5cGUpO1xuICAgIH1cbiAgICByZWdpc3RlclRhZ01hcHBlcihnZW5lcmljVGFnTWFwcGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnVHlwZSBvZiBnZW5lcmljVGFnTWFwcGVyLnRhZ1R5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ01hcHBlcnNbdGFnVHlwZV0gPSBnZW5lcmljVGFnTWFwcGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db21iaW5lZFRhZ01hcHBlciA9IENvbWJpbmVkVGFnTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tYmluZWRUYWdNYXBwZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/CombinedTagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/FourCC.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/FourCC.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FourCcToken = void 0;\nconst Util_1 = __webpack_require__(/*! ./Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst validFourCC = /^[\\w-©][\\w-\\x000-3]/;\n/**\n * Token for read FourCC\n * Ref: https://en.wikipedia.org/wiki/FourCC\n */\nexports.FourCcToken = {\n    len: 4,\n    get: (buf, off) => {\n        const id = buf.toString(\"binary\", off, off + exports.FourCcToken.len);\n        if (!id.match(validFourCC)) {\n            throw new Error(`FourCC contains invalid characters: ${Util_1.default.a2hex(id)}`);\n        }\n        return id;\n    },\n    put: (buffer, offset, id) => {\n        const str = Buffer.from(id, 'binary');\n        if (str.length !== 4)\n            throw new Error(\"Invalid length\");\n        return str.copy(buffer, offset);\n    }\n};\n//# sourceMappingURL=FourCC.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9Gb3VyQ0MuanM/OThhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGdFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHlCQUF5QjtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9Gb3VyQ0MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm91ckNjVG9rZW4gPSB2b2lkIDA7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xuY29uc3QgdmFsaWRGb3VyQ0MgPSAvXltcXHctwqldW1xcdy1cXHgwMDAtM10vO1xuLyoqXG4gKiBUb2tlbiBmb3IgcmVhZCBGb3VyQ0NcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm91ckNDXG4gKi9cbmV4cG9ydHMuRm91ckNjVG9rZW4gPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gYnVmLnRvU3RyaW5nKFwiYmluYXJ5XCIsIG9mZiwgb2ZmICsgZXhwb3J0cy5Gb3VyQ2NUb2tlbi5sZW4pO1xuICAgICAgICBpZiAoIWlkLm1hdGNoKHZhbGlkRm91ckNDKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VyQ0MgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzOiAke1V0aWxfMS5kZWZhdWx0LmEyaGV4KGlkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICBwdXQ6IChidWZmZXIsIG9mZnNldCwgaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyID0gQnVmZmVyLmZyb20oaWQsICdiaW5hcnknKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxlbmd0aFwiKTtcbiAgICAgICAgcmV0dXJuIHN0ci5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm91ckNDLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/FourCC.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/GenericTagMapper.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/GenericTagMapper.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommonTagMapper = void 0;\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nclass CommonTagMapper {\n    constructor(tagTypes, tagMap) {\n        this.tagTypes = tagTypes;\n        this.tagMap = tagMap;\n    }\n    static parseGenre(origVal) {\n        // match everything inside parentheses\n        const split = origVal.trim().split(/\\((.*?)\\)/g).filter(val => {\n            return val !== '';\n        });\n        const array = [];\n        for (let cur of split) {\n            if (/^\\d+$/.test(cur) && !isNaN(parseInt(cur, 10))) {\n                cur = ID3v1Parser_1.Genres[cur];\n            }\n            array.push(cur);\n        }\n        return array\n            .filter(val => {\n            return val !== undefined;\n        }).join('/');\n    }\n    static toIntOrNull(str) {\n        const cleaned = parseInt(str, 10);\n        return isNaN(cleaned) ? null : cleaned;\n    }\n    // TODO: a string of 1of1 would fail to be converted\n    // converts 1/10 to no : 1, of : 10\n    // or 1 to no : 1, of : 0\n    static normalizeTrack(origVal) {\n        const split = origVal.toString().split('/');\n        return {\n            no: parseInt(split[0], 10) || null,\n            of: parseInt(split[1], 10) || null\n        };\n    }\n    /**\n     * Process and set common tags\n     * write common tags to\n     * @param tag Native tag\n     * @param warnings Register warnings\n     * @return common name\n     */\n    mapGenericTag(tag, warnings) {\n        tag = { id: tag.id, value: tag.value }; // clone object\n        this.postMap(tag, warnings);\n        // Convert native tag event to generic 'alias' tag\n        const id = this.getCommonName(tag.id);\n        return id ? { id, value: tag.value } : null;\n    }\n    /**\n     * Convert native tag key to common tag key\n     * @tag  Native header tag\n     * @return common tag name (alias)\n     */\n    getCommonName(tag) {\n        return this.tagMap[tag];\n    }\n    /**\n     * Handle post mapping exceptions / correction\n     * @param {string} tag Tag e.g. {\"©alb\", \"Buena Vista Social Club\")\n     * @param {warnings} Used to register warnings\n     */\n    postMap(tag, warnings) {\n        return;\n    }\n}\nexports.CommonTagMapper = CommonTagMapper;\nCommonTagMapper.maxRatingScore = 1;\n//# sourceMappingURL=GenericTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyLmpzP2ZjOTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxlQUFlO0FBQ3JDLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vR2VuZXJpY1RhZ01hcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25UYWdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBJRDN2MVBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YxL0lEM3YxUGFyc2VyXCIpO1xuY2xhc3MgQ29tbW9uVGFnTWFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdUeXBlcywgdGFnTWFwKSB7XG4gICAgICAgIHRoaXMudGFnVHlwZXMgPSB0YWdUeXBlcztcbiAgICAgICAgdGhpcy50YWdNYXAgPSB0YWdNYXA7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUdlbnJlKG9yaWdWYWwpIHtcbiAgICAgICAgLy8gbWF0Y2ggZXZlcnl0aGluZyBpbnNpZGUgcGFyZW50aGVzZXNcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBvcmlnVmFsLnRyaW0oKS5zcGxpdCgvXFwoKC4qPylcXCkvZykuZmlsdGVyKHZhbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9PSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiBzcGxpdCkge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QoY3VyKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gSUQzdjFQYXJzZXJfMS5HZW5yZXNbY3VyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5LnB1c2goY3VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5maWx0ZXIodmFsID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSkuam9pbignLycpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9JbnRPck51bGwoc3RyKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGNsZWFuZWQpID8gbnVsbCA6IGNsZWFuZWQ7XG4gICAgfVxuICAgIC8vIFRPRE86IGEgc3RyaW5nIG9mIDFvZjEgd291bGQgZmFpbCB0byBiZSBjb252ZXJ0ZWRcbiAgICAvLyBjb252ZXJ0cyAxLzEwIHRvIG5vIDogMSwgb2YgOiAxMFxuICAgIC8vIG9yIDEgdG8gbm8gOiAxLCBvZiA6IDBcbiAgICBzdGF0aWMgbm9ybWFsaXplVHJhY2sob3JpZ1ZhbCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IG9yaWdWYWwudG9TdHJpbmcoKS5zcGxpdCgnLycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm86IHBhcnNlSW50KHNwbGl0WzBdLCAxMCkgfHwgbnVsbCxcbiAgICAgICAgICAgIG9mOiBwYXJzZUludChzcGxpdFsxXSwgMTApIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbmQgc2V0IGNvbW1vbiB0YWdzXG4gICAgICogd3JpdGUgY29tbW9uIHRhZ3MgdG9cbiAgICAgKiBAcGFyYW0gdGFnIE5hdGl2ZSB0YWdcbiAgICAgKiBAcGFyYW0gd2FybmluZ3MgUmVnaXN0ZXIgd2FybmluZ3NcbiAgICAgKiBAcmV0dXJuIGNvbW1vbiBuYW1lXG4gICAgICovXG4gICAgbWFwR2VuZXJpY1RhZyh0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIHRhZyA9IHsgaWQ6IHRhZy5pZCwgdmFsdWU6IHRhZy52YWx1ZSB9OyAvLyBjbG9uZSBvYmplY3RcbiAgICAgICAgdGhpcy5wb3N0TWFwKHRhZywgd2FybmluZ3MpO1xuICAgICAgICAvLyBDb252ZXJ0IG5hdGl2ZSB0YWcgZXZlbnQgdG8gZ2VuZXJpYyAnYWxpYXMnIHRhZ1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0Q29tbW9uTmFtZSh0YWcuaWQpO1xuICAgICAgICByZXR1cm4gaWQgPyB7IGlkLCB2YWx1ZTogdGFnLnZhbHVlIH0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IG5hdGl2ZSB0YWcga2V5IHRvIGNvbW1vbiB0YWcga2V5XG4gICAgICogQHRhZyAgTmF0aXZlIGhlYWRlciB0YWdcbiAgICAgKiBAcmV0dXJuIGNvbW1vbiB0YWcgbmFtZSAoYWxpYXMpXG4gICAgICovXG4gICAgZ2V0Q29tbW9uTmFtZSh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnTWFwW3RhZ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwb3N0IG1hcHBpbmcgZXhjZXB0aW9ucyAvIGNvcnJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRhZyBlLmcuIHtcIsKpYWxiXCIsIFwiQnVlbmEgVmlzdGEgU29jaWFsIENsdWJcIilcbiAgICAgKiBAcGFyYW0ge3dhcm5pbmdzfSBVc2VkIHRvIHJlZ2lzdGVyIHdhcm5pbmdzXG4gICAgICovXG4gICAgcG9zdE1hcCh0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLkNvbW1vblRhZ01hcHBlciA9IENvbW1vblRhZ01hcHBlcjtcbkNvbW1vblRhZ01hcHBlci5tYXhSYXRpbmdTY29yZSA9IDE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljVGFnTWFwcGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/GenericTagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/GenericTagTypes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/GenericTagTypes.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isUnique = exports.isSingleton = exports.commonTags = void 0;\nexports.commonTags = {\n    year: { multiple: false },\n    track: { multiple: false },\n    disk: { multiple: false },\n    title: { multiple: false },\n    artist: { multiple: false },\n    artists: { multiple: true, unique: true },\n    albumartist: { multiple: false },\n    album: { multiple: false },\n    date: { multiple: false },\n    originaldate: { multiple: false },\n    originalyear: { multiple: false },\n    comment: { multiple: true, unique: false },\n    genre: { multiple: true, unique: true },\n    picture: { multiple: true, unique: true },\n    composer: { multiple: true, unique: true },\n    lyrics: { multiple: true, unique: false },\n    albumsort: { multiple: false, unique: true },\n    titlesort: { multiple: false, unique: true },\n    work: { multiple: false, unique: true },\n    artistsort: { multiple: false, unique: true },\n    albumartistsort: { multiple: false, unique: true },\n    composersort: { multiple: false, unique: true },\n    lyricist: { multiple: true, unique: true },\n    writer: { multiple: true, unique: true },\n    conductor: { multiple: true, unique: true },\n    remixer: { multiple: true, unique: true },\n    arranger: { multiple: true, unique: true },\n    engineer: { multiple: true, unique: true },\n    producer: { multiple: true, unique: true },\n    technician: { multiple: true, unique: true },\n    djmixer: { multiple: true, unique: true },\n    mixer: { multiple: true, unique: true },\n    label: { multiple: true, unique: true },\n    grouping: { multiple: false },\n    subtitle: { multiple: true },\n    discsubtitle: { multiple: false },\n    totaltracks: { multiple: false },\n    totaldiscs: { multiple: false },\n    compilation: { multiple: false },\n    rating: { multiple: true },\n    bpm: { multiple: false },\n    mood: { multiple: false },\n    media: { multiple: false },\n    catalognumber: { multiple: true, unique: true },\n    tvShow: { multiple: false },\n    tvShowSort: { multiple: false },\n    tvSeason: { multiple: false },\n    tvEpisode: { multiple: false },\n    tvEpisodeId: { multiple: false },\n    tvNetwork: { multiple: false },\n    podcast: { multiple: false },\n    podcasturl: { multiple: false },\n    releasestatus: { multiple: false },\n    releasetype: { multiple: true },\n    releasecountry: { multiple: false },\n    script: { multiple: false },\n    language: { multiple: false },\n    copyright: { multiple: false },\n    license: { multiple: false },\n    encodedby: { multiple: false },\n    encodersettings: { multiple: false },\n    gapless: { multiple: false },\n    barcode: { multiple: false },\n    isrc: { multiple: true },\n    asin: { multiple: false },\n    musicbrainz_recordingid: { multiple: false },\n    musicbrainz_trackid: { multiple: false },\n    musicbrainz_albumid: { multiple: false },\n    musicbrainz_artistid: { multiple: true },\n    musicbrainz_albumartistid: { multiple: true },\n    musicbrainz_releasegroupid: { multiple: false },\n    musicbrainz_workid: { multiple: false },\n    musicbrainz_trmid: { multiple: false },\n    musicbrainz_discid: { multiple: false },\n    acoustid_id: { multiple: false },\n    acoustid_fingerprint: { multiple: false },\n    musicip_puid: { multiple: false },\n    musicip_fingerprint: { multiple: false },\n    website: { multiple: false },\n    'performer:instrument': { multiple: true, unique: true },\n    averageLevel: { multiple: false },\n    peakLevel: { multiple: false },\n    notes: { multiple: true, unique: false },\n    key: { multiple: false },\n    originalalbum: { multiple: false },\n    originalartist: { multiple: false },\n    discogs_artist_id: { multiple: true, unique: true },\n    discogs_release_id: { multiple: false },\n    discogs_label_id: { multiple: false },\n    discogs_master_release_id: { multiple: false },\n    discogs_votes: { multiple: false },\n    discogs_rating: { multiple: false },\n    replaygain_track_peak: { multiple: false },\n    replaygain_track_gain: { multiple: false },\n    replaygain_album_peak: { multiple: false },\n    replaygain_album_gain: { multiple: false },\n    replaygain_track_minmax: { multiple: false },\n    replaygain_album_minmax: { multiple: false },\n    replaygain_undo: { multiple: false },\n    description: { multiple: true },\n    category: { multiple: true },\n    hdVideo: { multiple: false },\n    keywords: { multiple: true },\n    movement: { multiple: false },\n    movementIndex: { multiple: false },\n    movementTotal: { multiple: false },\n    podcastId: { multiple: false },\n    showMovement: { multiple: false },\n    stik: { multiple: false }\n};\n/**\n * @param alias Name of common tag\n * @returns {boolean|*} true if given alias is mapped as a singleton', otherwise false\n */\nfunction isSingleton(alias) {\n    return exports.commonTags.hasOwnProperty(alias) && !exports.commonTags[alias].multiple;\n}\nexports.isSingleton = isSingleton;\n/**\n * @param alias Common (generic) tag\n * @returns {boolean|*} true if given alias is a singleton or explicitly marked as unique\n */\nfunction isUnique(alias) {\n    return !exports.commonTags[alias].multiple || exports.commonTags[alias].unique;\n}\nexports.isUnique = isUnique;\n//# sourceMappingURL=GenericTagTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9HZW5lcmljVGFnVHlwZXMuanM/MjgxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLGtCQUFrQjtBQUM5QixXQUFXLGtCQUFrQjtBQUM3QixZQUFZLGtCQUFrQjtBQUM5QixhQUFhLGtCQUFrQjtBQUMvQixjQUFjLCtCQUErQjtBQUM3QyxrQkFBa0Isa0JBQWtCO0FBQ3BDLFlBQVksa0JBQWtCO0FBQzlCLFdBQVcsa0JBQWtCO0FBQzdCLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLGtCQUFrQjtBQUNyQyxjQUFjLGdDQUFnQztBQUM5QyxZQUFZLCtCQUErQjtBQUMzQyxjQUFjLCtCQUErQjtBQUM3QyxlQUFlLCtCQUErQjtBQUM5QyxhQUFhLGdDQUFnQztBQUM3QyxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdCQUFnQixnQ0FBZ0M7QUFDaEQsV0FBVyxnQ0FBZ0M7QUFDM0MsaUJBQWlCLGdDQUFnQztBQUNqRCxzQkFBc0IsZ0NBQWdDO0FBQ3RELG1CQUFtQixnQ0FBZ0M7QUFDbkQsZUFBZSwrQkFBK0I7QUFDOUMsYUFBYSwrQkFBK0I7QUFDNUMsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLCtCQUErQjtBQUM3QyxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLCtCQUErQjtBQUM5QyxpQkFBaUIsK0JBQStCO0FBQ2hELGNBQWMsK0JBQStCO0FBQzdDLFlBQVksK0JBQStCO0FBQzNDLFlBQVksK0JBQStCO0FBQzNDLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsaUJBQWlCO0FBQ2hDLG1CQUFtQixrQkFBa0I7QUFDckMsa0JBQWtCLGtCQUFrQjtBQUNwQyxpQkFBaUIsa0JBQWtCO0FBQ25DLGtCQUFrQixrQkFBa0I7QUFDcEMsYUFBYSxpQkFBaUI7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxrQkFBa0I7QUFDOUIsb0JBQW9CLCtCQUErQjtBQUNuRCxhQUFhLGtCQUFrQjtBQUMvQixpQkFBaUIsa0JBQWtCO0FBQ25DLGVBQWUsa0JBQWtCO0FBQ2pDLGdCQUFnQixrQkFBa0I7QUFDbEMsa0JBQWtCLGtCQUFrQjtBQUNwQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGNBQWMsa0JBQWtCO0FBQ2hDLGlCQUFpQixrQkFBa0I7QUFDbkMsb0JBQW9CLGtCQUFrQjtBQUN0QyxrQkFBa0IsaUJBQWlCO0FBQ25DLHFCQUFxQixrQkFBa0I7QUFDdkMsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZSxrQkFBa0I7QUFDakMsZ0JBQWdCLGtCQUFrQjtBQUNsQyxjQUFjLGtCQUFrQjtBQUNoQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLHNCQUFzQixrQkFBa0I7QUFDeEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxrQkFBa0I7QUFDaEMsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsOEJBQThCLGtCQUFrQjtBQUNoRCwwQkFBMEIsa0JBQWtCO0FBQzVDLDBCQUEwQixrQkFBa0I7QUFDNUMsMkJBQTJCLGlCQUFpQjtBQUM1QyxnQ0FBZ0MsaUJBQWlCO0FBQ2pELGlDQUFpQyxrQkFBa0I7QUFDbkQseUJBQXlCLGtCQUFrQjtBQUMzQyx3QkFBd0Isa0JBQWtCO0FBQzFDLHlCQUF5QixrQkFBa0I7QUFDM0Msa0JBQWtCLGtCQUFrQjtBQUNwQywyQkFBMkIsa0JBQWtCO0FBQzdDLG1CQUFtQixrQkFBa0I7QUFDckMsMEJBQTBCLGtCQUFrQjtBQUM1QyxjQUFjLGtCQUFrQjtBQUNoQyw2QkFBNkIsK0JBQStCO0FBQzVELG1CQUFtQixrQkFBa0I7QUFDckMsZ0JBQWdCLGtCQUFrQjtBQUNsQyxZQUFZLGdDQUFnQztBQUM1QyxVQUFVLGtCQUFrQjtBQUM1QixvQkFBb0Isa0JBQWtCO0FBQ3RDLHFCQUFxQixrQkFBa0I7QUFDdkMsd0JBQXdCLCtCQUErQjtBQUN2RCx5QkFBeUIsa0JBQWtCO0FBQzNDLHVCQUF1QixrQkFBa0I7QUFDekMsZ0NBQWdDLGtCQUFrQjtBQUNsRCxvQkFBb0Isa0JBQWtCO0FBQ3RDLHFCQUFxQixrQkFBa0I7QUFDdkMsNEJBQTRCLGtCQUFrQjtBQUM5Qyw0QkFBNEIsa0JBQWtCO0FBQzlDLDRCQUE0QixrQkFBa0I7QUFDOUMsNEJBQTRCLGtCQUFrQjtBQUM5Qyw4QkFBOEIsa0JBQWtCO0FBQ2hELDhCQUE4QixrQkFBa0I7QUFDaEQsc0JBQXNCLGtCQUFrQjtBQUN4QyxrQkFBa0IsaUJBQWlCO0FBQ25DLGVBQWUsaUJBQWlCO0FBQ2hDLGNBQWMsa0JBQWtCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsa0JBQWtCO0FBQ2pDLG9CQUFvQixrQkFBa0I7QUFDdEMsb0JBQW9CLGtCQUFrQjtBQUN0QyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLG1CQUFtQixrQkFBa0I7QUFDckMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9HZW5lcmljVGFnVHlwZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNVbmlxdWUgPSBleHBvcnRzLmlzU2luZ2xldG9uID0gZXhwb3J0cy5jb21tb25UYWdzID0gdm9pZCAwO1xuZXhwb3J0cy5jb21tb25UYWdzID0ge1xuICAgIHllYXI6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHJhY2s6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGlzazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICB0aXRsZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhcnRpc3Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYXJ0aXN0czogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgYWxidW1hcnRpc3Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYWxidW06IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGF0ZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBvcmlnaW5hbGRhdGU6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgb3JpZ2luYWx5ZWFyOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGNvbW1lbnQ6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogZmFsc2UgfSxcbiAgICBnZW5yZTogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgcGljdHVyZTogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29tcG9zZXI6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGx5cmljczogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiBmYWxzZSB9LFxuICAgIGFsYnVtc29ydDogeyBtdWx0aXBsZTogZmFsc2UsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHRpdGxlc29ydDogeyBtdWx0aXBsZTogZmFsc2UsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHdvcms6IHsgbXVsdGlwbGU6IGZhbHNlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBhcnRpc3Rzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgYWxidW1hcnRpc3Rzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29tcG9zZXJzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgbHlyaWNpc3Q6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHdyaXRlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29uZHVjdG9yOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICByZW1peGVyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBhcnJhbmdlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgZW5naW5lZXI6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHByb2R1Y2VyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICB0ZWNobmljaWFuOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBkam1peGVyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBtaXhlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgbGFiZWw6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGdyb3VwaW5nOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHN1YnRpdGxlOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgZGlzY3N1YnRpdGxlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHRvdGFsdHJhY2tzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHRvdGFsZGlzY3M6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgY29tcGlsYXRpb246IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmF0aW5nOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYnBtOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG1vb2Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbWVkaWE6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgY2F0YWxvZ251bWJlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgdHZTaG93OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2U2hvd1NvcnQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHZTZWFzb246IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHZFcGlzb2RlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2RXBpc29kZUlkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2TmV0d29yazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBwb2RjYXN0OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHBvZGNhc3R1cmw6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmVsZWFzZXN0YXR1czogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZWxlYXNldHlwZTogeyBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIHJlbGVhc2Vjb3VudHJ5OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHNjcmlwdDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBsYW5ndWFnZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBjb3B5cmlnaHQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbGljZW5zZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBlbmNvZGVkYnk6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZW5jb2RlcnNldHRpbmdzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGdhcGxlc3M6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYmFyY29kZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBpc3JjOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYXNpbjogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2JyYWluel9yZWNvcmRpbmdpZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2JyYWluel90cmFja2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X2FsYnVtaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNicmFpbnpfYXJ0aXN0aWQ6IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBtdXNpY2JyYWluel9hbGJ1bWFydGlzdGlkOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgbXVzaWNicmFpbnpfcmVsZWFzZWdyb3VwaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNicmFpbnpfd29ya2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X3RybWlkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X2Rpc2NpZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhY291c3RpZF9pZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhY291c3RpZF9maW5nZXJwcmludDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2lwX3B1aWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNpcF9maW5nZXJwcmludDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICB3ZWJzaXRlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgICdwZXJmb3JtZXI6aW5zdHJ1bWVudCc6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGF2ZXJhZ2VMZXZlbDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBwZWFrTGV2ZWw6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbm90ZXM6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogZmFsc2UgfSxcbiAgICBrZXk6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgb3JpZ2luYWxhbGJ1bTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBvcmlnaW5hbGFydGlzdDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBkaXNjb2dzX2FydGlzdF9pZDogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgZGlzY29nc19yZWxlYXNlX2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGRpc2NvZ3NfbGFiZWxfaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGlzY29nc19tYXN0ZXJfcmVsZWFzZV9pZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBkaXNjb2dzX3ZvdGVzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGRpc2NvZ3NfcmF0aW5nOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHJlcGxheWdhaW5fdHJhY2tfcGVhazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3RyYWNrX2dhaW46IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHJlcGxheWdhaW5fYWxidW1fZ2FpbjogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3RyYWNrX21pbm1heDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX2FsYnVtX21pbm1heDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3VuZG86IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGVzY3JpcHRpb246IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBjYXRlZ29yeTogeyBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIGhkVmlkZW86IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAga2V5d29yZHM6IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBtb3ZlbWVudDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtb3ZlbWVudEluZGV4OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG1vdmVtZW50VG90YWw6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcG9kY2FzdElkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHNob3dNb3ZlbWVudDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBzdGlrOiB7IG11bHRpcGxlOiBmYWxzZSB9XG59O1xuLyoqXG4gKiBAcGFyYW0gYWxpYXMgTmFtZSBvZiBjb21tb24gdGFnXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnwqfSB0cnVlIGlmIGdpdmVuIGFsaWFzIGlzIG1hcHBlZCBhcyBhIHNpbmdsZXRvbicsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1NpbmdsZXRvbihhbGlhcykge1xuICAgIHJldHVybiBleHBvcnRzLmNvbW1vblRhZ3MuaGFzT3duUHJvcGVydHkoYWxpYXMpICYmICFleHBvcnRzLmNvbW1vblRhZ3NbYWxpYXNdLm11bHRpcGxlO1xufVxuZXhwb3J0cy5pc1NpbmdsZXRvbiA9IGlzU2luZ2xldG9uO1xuLyoqXG4gKiBAcGFyYW0gYWxpYXMgQ29tbW9uIChnZW5lcmljKSB0YWdcbiAqIEByZXR1cm5zIHtib29sZWFufCp9IHRydWUgaWYgZ2l2ZW4gYWxpYXMgaXMgYSBzaW5nbGV0b24gb3IgZXhwbGljaXRseSBtYXJrZWQgYXMgdW5pcXVlXG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlKGFsaWFzKSB7XG4gICAgcmV0dXJuICFleHBvcnRzLmNvbW1vblRhZ3NbYWxpYXNdLm11bHRpcGxlIHx8IGV4cG9ydHMuY29tbW9uVGFnc1thbGlhc10udW5pcXVlO1xufVxuZXhwb3J0cy5pc1VuaXF1ZSA9IGlzVW5pcXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY1RhZ1R5cGVzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/GenericTagTypes.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/MetadataCollector.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/MetadataCollector.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = __webpack_require__(/*! ../type */ \"./node_modules/music-metadata/lib/type.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst GenericTagTypes_1 = __webpack_require__(/*! ./GenericTagTypes */ \"./node_modules/music-metadata/lib/common/GenericTagTypes.js\");\nconst CombinedTagMapper_1 = __webpack_require__(/*! ./CombinedTagMapper */ \"./node_modules/music-metadata/lib/common/CombinedTagMapper.js\");\nconst GenericTagMapper_1 = __webpack_require__(/*! ./GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nconst Util_1 = __webpack_require__(/*! ./Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst FileType = __webpack_require__(/*! file-type/core */ \"./node_modules/music-metadata/node_modules/file-type/core.js\");\nconst debug = _debug('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n    constructor(opts) {\n        this.opts = opts;\n        this.format = {\n            tagTypes: [],\n            trackInfo: []\n        };\n        this.native = {};\n        this.common = {\n            track: { no: null, of: null },\n            disk: { no: null, of: null },\n            movementIndex: {}\n        };\n        this.quality = {\n            warnings: []\n        };\n        /**\n         * Keeps track of origin priority for each mapped id\n         */\n        this.commonOrigin = {};\n        /**\n         * Maps a tag type to a priority\n         */\n        this.originPriority = {};\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n        let priority = 1;\n        for (const tagType of TagPriority) {\n            this.originPriority[tagType] = priority++;\n        }\n        this.originPriority.artificial = 500; // Filled using alternative tags\n        this.originPriority.id3v1 = 600; // Consider worst due to field length limit\n    }\n    /**\n     * @returns {boolean} true if one or more tags have been found\n     */\n    hasAny() {\n        return Object.keys(this.native).length > 0;\n    }\n    addStreamInfo(streamInfo) {\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n        this.format.trackInfo.push(streamInfo);\n    }\n    setFormat(key, value) {\n        debug(`format: ${key} = ${value}`);\n        this.format[key] = value; // as any to override readonly\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\n        }\n    }\n    addTag(tagType, tagId, value) {\n        debug(`tag ${tagType}.${tagId} = ${value}`);\n        if (!this.native[tagType]) {\n            this.format.tagTypes.push(tagType);\n            this.native[tagType] = [];\n        }\n        this.native[tagType].push({ id: tagId, value });\n        this.toCommon(tagType, tagId, value);\n    }\n    addWarning(warning) {\n        this.quality.warnings.push({ message: warning });\n    }\n    postMap(tagType, tag) {\n        // Common tag (alias) found\n        // check if we need to do something special with common tag\n        // if the event has been aliased then we need to clean it before\n        // it is emitted to the user. e.g. genre (20) -> Electronic\n        switch (tag.id) {\n            case 'artist':\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\n                    // Assume the artist field is used as artists\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\n                }\n                if (!this.common.artists) {\n                    // Fill artists using artist source\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\n                }\n                break;\n            case 'artists':\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n                        // Fill artist using artists source\n                        const artists = (this.common.artists || []).concat([tag.value]);\n                        const value = joinArtists(artists);\n                        const artistTag = { id: 'artist', value };\n                        this.setGenericTag('artificial', artistTag);\n                    }\n                }\n                break;\n            case 'genre':\n                tag.value = GenericTagMapper_1.CommonTagMapper.parseGenre(tag.value);\n                break;\n            case 'picture':\n                this.postFixPicture(tag.value).then(picture => {\n                    if (picture !== null) {\n                        tag.value = picture;\n                        this.setGenericTag(tagType, tag);\n                    }\n                });\n                return;\n            case 'totaltracks':\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'totaldiscs':\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'movementTotal':\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'track':\n            case 'disk':\n            case 'movementIndex':\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n                return;\n            case 'year':\n            case 'originalyear':\n                tag.value = parseInt(tag.value, 10);\n                break;\n            case 'date':\n                // ToDo: be more strict on 'YYYY...'\n                const year = parseInt(tag.value.substr(0, 4), 10);\n                if (!isNaN(year)) {\n                    this.common.year = year;\n                }\n                break;\n            case 'discogs_label_id':\n            case 'discogs_release_id':\n            case 'discogs_master_release_id':\n            case 'discogs_artist_id':\n            case 'discogs_votes':\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n                break;\n            case 'replaygain_track_gain':\n            case 'replaygain_track_peak':\n            case 'replaygain_album_gain':\n            case 'replaygain_album_peak':\n                tag.value = Util_1.toRatio(tag.value);\n                break;\n            case 'replaygain_track_minmax':\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n                break;\n            case 'replaygain_undo':\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n                tag.value = {\n                    leftChannel: minMix[0],\n                    rightChannel: minMix[1]\n                };\n                break;\n            case 'gapless': // iTunes gap-less flag\n            case 'compilation':\n            case 'podcast':\n            case 'showMovement':\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\n                break;\n            case 'isrc': // Only keep unique values\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\n                    return;\n                break;\n            default:\n            // nothing to do\n        }\n        if (tag.value !== null) {\n            this.setGenericTag(tagType, tag);\n        }\n    }\n    /**\n     * Convert native tags to common tags\n     * @returns {IAudioMetadata} Native + common tags\n     */\n    toCommonMetadata() {\n        return {\n            format: this.format,\n            native: this.native,\n            quality: this.quality,\n            common: this.common\n        };\n    }\n    /**\n     * Fix some common issues with picture object\n     * @param pictureType\n     */\n    async postFixPicture(picture) {\n        if (picture.data.length > 0) {\n            if (!picture.format) {\n                const fileType = await FileType.fromBuffer(picture.data);\n                if (fileType) {\n                    picture.format = fileType.mime;\n                }\n                else {\n                    return null;\n                }\n            }\n            picture.format = picture.format.toLocaleLowerCase();\n            switch (picture.format) {\n                case 'image/jpg':\n                    picture.format = 'image/jpeg'; // ToDo: register warning\n            }\n            return picture;\n        }\n        this.addWarning(`Empty picture tag found`);\n        return null;\n    }\n    /**\n     * Convert native tag to common tags\n     */\n    toCommon(tagType, tagId, value) {\n        const tag = { id: tagId, value };\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n        if (genericTag) {\n            this.postMap(tagType, genericTag);\n        }\n    }\n    /**\n     * Set generic tag\n     */\n    setGenericTag(tagType, tag) {\n        debug(`common.${tag.id} = ${tag.value}`);\n        const prio0 = this.commonOrigin[tag.id] || 1000;\n        const prio1 = this.originPriority[tagType];\n        if (GenericTagTypes_1.isSingleton(tag.id)) {\n            if (prio1 <= prio0) {\n                this.common[tag.id] = tag.value;\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        else {\n            if (prio1 === prio0) {\n                if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n                    this.common[tag.id].push(tag.value);\n                }\n                else {\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n                }\n                // no effect? this.commonOrigin[tag.id] = prio1;\n            }\n            else if (prio1 < prio0) {\n                this.common[tag.id] = [tag.value];\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\n        }\n        // ToDo: trigger metadata event\n    }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n    if (artists.length > 2) {\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n    }\n    return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;\n//# sourceMappingURL=MetadataCollector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9NZXRhZGF0YUNvbGxlY3Rvci5qcz8wM2ViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsMERBQVM7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLDhFQUFPO0FBQzlCLDBCQUEwQixtQkFBTyxDQUFDLHNGQUFtQjtBQUNyRCw0QkFBNEIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDekQsMkJBQTJCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDLFVBQVUscUJBQXFCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLEtBQUssTUFBTTtBQUN4QyxpQ0FBaUM7QUFDakM7QUFDQSxnQ0FBZ0MsdUJBQXVCLGlDQUFpQyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLEdBQUcsTUFBTSxLQUFLLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0NBQWtDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBa0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sS0FBSyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsUUFBUSxHQUFHLE9BQU8sS0FBSyxVQUFVO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUSxHQUFHLE9BQU8sS0FBSyxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUSxHQUFHLE9BQU8sS0FBSyxVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUIsK0NBQStDLEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9NZXRhZGF0YUNvbGxlY3Rvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5qb2luQXJ0aXN0cyA9IGV4cG9ydHMuTWV0YWRhdGFDb2xsZWN0b3IgPSB2b2lkIDA7XG5jb25zdCB0eXBlXzEgPSByZXF1aXJlKFwiLi4vdHlwZVwiKTtcbmNvbnN0IF9kZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IEdlbmVyaWNUYWdUeXBlc18xID0gcmVxdWlyZShcIi4vR2VuZXJpY1RhZ1R5cGVzXCIpO1xuY29uc3QgQ29tYmluZWRUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkVGFnTWFwcGVyXCIpO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4vR2VuZXJpY1RhZ01hcHBlclwiKTtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuL1V0aWxcIik7XG5jb25zdCBGaWxlVHlwZSA9IHJlcXVpcmUoXCJmaWxlLXR5cGUvY29yZVwiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpjb2xsZWN0b3InKTtcbmNvbnN0IFRhZ1ByaW9yaXR5ID0gWydtYXRyb3NrYScsICdBUEV2MicsICd2b3JiaXMnLCAnSUQzdjIuNCcsICdJRDN2Mi4zJywgJ0lEM3YyLjInLCAnZXhpZicsICdhc2YnLCAnaVR1bmVzJywgJ0lEM3YxJ107XG4vKipcbiAqIFByb3ZpZGVkIHRvIHRoZSBwYXJzZXIgdG8gdW9kYXRlIHRoZSBtZXRhZGF0YSByZXN1bHQuXG4gKiBSZXNwb25zaWJsZSBmb3IgdHJpZ2dlcmluZyBhc3luYyB1cGRhdGVzXG4gKi9cbmNsYXNzIE1ldGFkYXRhQ29sbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0ge1xuICAgICAgICAgICAgdGFnVHlwZXM6IFtdLFxuICAgICAgICAgICAgdHJhY2tJbmZvOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IHt9O1xuICAgICAgICB0aGlzLmNvbW1vbiA9IHtcbiAgICAgICAgICAgIHRyYWNrOiB7IG5vOiBudWxsLCBvZjogbnVsbCB9LFxuICAgICAgICAgICAgZGlzazogeyBubzogbnVsbCwgb2Y6IG51bGwgfSxcbiAgICAgICAgICAgIG1vdmVtZW50SW5kZXg6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVhbGl0eSA9IHtcbiAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2Ygb3JpZ2luIHByaW9yaXR5IGZvciBlYWNoIG1hcHBlZCBpZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21tb25PcmlnaW4gPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYSB0YWcgdHlwZSB0byBhIHByaW9yaXR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5ID0ge307XG4gICAgICAgIHRoaXMudGFnTWFwcGVyID0gbmV3IENvbWJpbmVkVGFnTWFwcGVyXzEuQ29tYmluZWRUYWdNYXBwZXIoKTtcbiAgICAgICAgbGV0IHByaW9yaXR5ID0gMTtcbiAgICAgICAgZm9yIChjb25zdCB0YWdUeXBlIG9mIFRhZ1ByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5W3RhZ1R5cGVdID0gcHJpb3JpdHkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5LmFydGlmaWNpYWwgPSA1MDA7IC8vIEZpbGxlZCB1c2luZyBhbHRlcm5hdGl2ZSB0YWdzXG4gICAgICAgIHRoaXMub3JpZ2luUHJpb3JpdHkuaWQzdjEgPSA2MDA7IC8vIENvbnNpZGVyIHdvcnN0IGR1ZSB0byBmaWVsZCBsZW5ndGggbGltaXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgb25lIG9yIG1vcmUgdGFncyBoYXZlIGJlZW4gZm91bmRcbiAgICAgKi9cbiAgICBoYXNBbnkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hdGl2ZSkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgYWRkU3RyZWFtSW5mbyhzdHJlYW1JbmZvKSB7XG4gICAgICAgIGRlYnVnKGBzdHJlYW1JbmZvOiB0eXBlPSR7dHlwZV8xLlRyYWNrVHlwZVtzdHJlYW1JbmZvLnR5cGVdfSwgY29kZWM9JHtzdHJlYW1JbmZvLmNvZGVjTmFtZX1gKTtcbiAgICAgICAgdGhpcy5mb3JtYXQudHJhY2tJbmZvLnB1c2goc3RyZWFtSW5mbyk7XG4gICAgfVxuICAgIHNldEZvcm1hdChrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlYnVnKGBmb3JtYXQ6ICR7a2V5fSA9ICR7dmFsdWV9YCk7XG4gICAgICAgIHRoaXMuZm9ybWF0W2tleV0gPSB2YWx1ZTsgLy8gYXMgYW55IHRvIG92ZXJyaWRlIHJlYWRvbmx5XG4gICAgICAgIGlmICh0aGlzLm9wdHMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5vYnNlcnZlcih7IG1ldGFkYXRhOiB0aGlzLCB0YWc6IHsgdHlwZTogJ2Zvcm1hdCcsIGlkOiBrZXksIHZhbHVlIH0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKHRhZ1R5cGUsIHRhZ0lkLCB2YWx1ZSkge1xuICAgICAgICBkZWJ1ZyhgdGFnICR7dGFnVHlwZX0uJHt0YWdJZH0gPSAke3ZhbHVlfWApO1xuICAgICAgICBpZiAoIXRoaXMubmF0aXZlW3RhZ1R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdC50YWdUeXBlcy5wdXNoKHRhZ1R5cGUpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVbdGFnVHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdGl2ZVt0YWdUeXBlXS5wdXNoKHsgaWQ6IHRhZ0lkLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy50b0NvbW1vbih0YWdUeXBlLCB0YWdJZCwgdmFsdWUpO1xuICAgIH1cbiAgICBhZGRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICAgICAgdGhpcy5xdWFsaXR5Lndhcm5pbmdzLnB1c2goeyBtZXNzYWdlOiB3YXJuaW5nIH0pO1xuICAgIH1cbiAgICBwb3N0TWFwKHRhZ1R5cGUsIHRhZykge1xuICAgICAgICAvLyBDb21tb24gdGFnIChhbGlhcykgZm91bmRcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkbyBzb21ldGhpbmcgc3BlY2lhbCB3aXRoIGNvbW1vbiB0YWdcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGhhcyBiZWVuIGFsaWFzZWQgdGhlbiB3ZSBuZWVkIHRvIGNsZWFuIGl0IGJlZm9yZVxuICAgICAgICAvLyBpdCBpcyBlbWl0dGVkIHRvIHRoZSB1c2VyLiBlLmcuIGdlbnJlICgyMCkgLT4gRWxlY3Ryb25pY1xuICAgICAgICBzd2l0Y2ggKHRhZy5pZCkge1xuICAgICAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21tb25PcmlnaW4uYXJ0aXN0ID09PSB0aGlzLm9yaWdpblByaW9yaXR5W3RhZ1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgYXJ0aXN0IGZpZWxkIGlzIHVzZWQgYXMgYXJ0aXN0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0TWFwKCdhcnRpZmljaWFsJywgeyBpZDogJ2FydGlzdHMnLCB2YWx1ZTogdGFnLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tbW9uLmFydGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsbCBhcnRpc3RzIHVzaW5nIGFydGlzdCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHZW5lcmljVGFnKCdhcnRpZmljaWFsJywgeyBpZDogJ2FydGlzdHMnLCB2YWx1ZTogdGFnLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FydGlzdHMnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21tb24uYXJ0aXN0IHx8IHRoaXMuY29tbW9uT3JpZ2luLmFydGlzdCA9PT0gdGhpcy5vcmlnaW5Qcmlvcml0eS5hcnRpZmljaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21tb24uYXJ0aXN0cyB8fCB0aGlzLmNvbW1vbi5hcnRpc3RzLmluZGV4T2YodGFnLnZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgYXJ0aXN0IHVzaW5nIGFydGlzdHMgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnRpc3RzID0gKHRoaXMuY29tbW9uLmFydGlzdHMgfHwgW10pLmNvbmNhdChbdGFnLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGpvaW5BcnRpc3RzKGFydGlzdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJ0aXN0VGFnID0geyBpZDogJ2FydGlzdCcsIHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEdlbmVyaWNUYWcoJ2FydGlmaWNpYWwnLCBhcnRpc3RUYWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2VucmUnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIucGFyc2VHZW5yZSh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGljdHVyZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0Rml4UGljdHVyZSh0YWcudmFsdWUpLnRoZW4ocGljdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWN0dXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBwaWN0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHZW5lcmljVGFnKHRhZ1R5cGUsIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICd0b3RhbHRyYWNrcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb24udHJhY2sub2YgPSBHZW5lcmljVGFnTWFwcGVyXzEuQ29tbW9uVGFnTWFwcGVyLnRvSW50T3JOdWxsKHRhZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAndG90YWxkaXNjcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb24uZGlzay5vZiA9IEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIudG9JbnRPck51bGwodGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdtb3ZlbWVudFRvdGFsJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbi5tb3ZlbWVudEluZGV4Lm9mID0gR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlci50b0ludE9yTnVsbCh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2snOlxuICAgICAgICAgICAgY2FzZSAnbW92ZW1lbnRJbmRleCc6XG4gICAgICAgICAgICAgICAgY29uc3Qgb2YgPSB0aGlzLmNvbW1vblt0YWcuaWRdLm9mOyAvLyBzdG9yZSBvZiB2YWx1ZSwgbWF5YmUgbWF5YmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdID0gR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlci5ub3JtYWxpemVUcmFjayh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uW3RhZy5pZF0ub2YgPSBvZiAhPSBudWxsID8gb2YgOiB0aGlzLmNvbW1vblt0YWcuaWRdLm9mO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgY2FzZSAnb3JpZ2luYWx5ZWFyJzpcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBwYXJzZUludCh0YWcudmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIC8vIFRvRG86IGJlIG1vcmUgc3RyaWN0IG9uICdZWVlZLi4uJ1xuICAgICAgICAgICAgICAgIGNvbnN0IHllYXIgPSBwYXJzZUludCh0YWcudmFsdWUuc3Vic3RyKDAsIDQpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih5ZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbi55ZWFyID0geWVhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjb2dzX2xhYmVsX2lkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2NvZ3NfcmVsZWFzZV9pZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNjb2dzX21hc3Rlcl9yZWxlYXNlX2lkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2NvZ3NfYXJ0aXN0X2lkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2NvZ3Nfdm90ZXMnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHR5cGVvZiB0YWcudmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQodGFnLnZhbHVlLCAxMCkgOiB0YWcudmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXBsYXlnYWluX3RyYWNrX2dhaW4nOlxuICAgICAgICAgICAgY2FzZSAncmVwbGF5Z2Fpbl90cmFja19wZWFrJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxheWdhaW5fYWxidW1fZ2Fpbic6XG4gICAgICAgICAgICBjYXNlICdyZXBsYXlnYWluX2FsYnVtX3BlYWsnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IFV0aWxfMS50b1JhdGlvKHRhZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXBsYXlnYWluX3RyYWNrX21pbm1heCc6XG4gICAgICAgICAgICAgICAgdGFnLnZhbHVlID0gdGFnLnZhbHVlLnNwbGl0KCcsJykubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxheWdhaW5fdW5kbyc6XG4gICAgICAgICAgICAgICAgY29uc3QgbWluTWl4ID0gdGFnLnZhbHVlLnNwbGl0KCcsJykubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFubmVsOiBtaW5NaXhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbm5lbDogbWluTWl4WzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dhcGxlc3MnOiAvLyBpVHVuZXMgZ2FwLWxlc3MgZmxhZ1xuICAgICAgICAgICAgY2FzZSAnY29tcGlsYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAncG9kY2FzdCc6XG4gICAgICAgICAgICBjYXNlICdzaG93TW92ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHRhZy52YWx1ZSA9PT0gJzEnIHx8IHRhZy52YWx1ZSA9PT0gMTsgLy8gYm9vbGVhblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNyYyc6IC8vIE9ubHkga2VlcCB1bmlxdWUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tbW9uW3RhZy5pZF0gJiYgdGhpcy5jb21tb25bdGFnLmlkXS5pbmRleE9mKHRhZy52YWx1ZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R2VuZXJpY1RhZyh0YWdUeXBlLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRhZ3MgdG8gY29tbW9uIHRhZ3NcbiAgICAgKiBAcmV0dXJucyB7SUF1ZGlvTWV0YWRhdGF9IE5hdGl2ZSArIGNvbW1vbiB0YWdzXG4gICAgICovXG4gICAgdG9Db21tb25NZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICBuYXRpdmU6IHRoaXMubmF0aXZlLFxuICAgICAgICAgICAgcXVhbGl0eTogdGhpcy5xdWFsaXR5LFxuICAgICAgICAgICAgY29tbW9uOiB0aGlzLmNvbW1vblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXggc29tZSBjb21tb24gaXNzdWVzIHdpdGggcGljdHVyZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcGljdHVyZVR5cGVcbiAgICAgKi9cbiAgICBhc3luYyBwb3N0Rml4UGljdHVyZShwaWN0dXJlKSB7XG4gICAgICAgIGlmIChwaWN0dXJlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFwaWN0dXJlLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVUeXBlID0gYXdhaXQgRmlsZVR5cGUuZnJvbUJ1ZmZlcihwaWN0dXJlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBwaWN0dXJlLmZvcm1hdCA9IGZpbGVUeXBlLm1pbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWN0dXJlLmZvcm1hdCA9IHBpY3R1cmUuZm9ybWF0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBpY3R1cmUuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UvanBnJzpcbiAgICAgICAgICAgICAgICAgICAgcGljdHVyZS5mb3JtYXQgPSAnaW1hZ2UvanBlZyc7IC8vIFRvRG86IHJlZ2lzdGVyIHdhcm5pbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwaWN0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV2FybmluZyhgRW1wdHkgcGljdHVyZSB0YWcgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRhZyB0byBjb21tb24gdGFnc1xuICAgICAqL1xuICAgIHRvQ29tbW9uKHRhZ1R5cGUsIHRhZ0lkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YWcgPSB7IGlkOiB0YWdJZCwgdmFsdWUgfTtcbiAgICAgICAgY29uc3QgZ2VuZXJpY1RhZyA9IHRoaXMudGFnTWFwcGVyLm1hcFRhZyh0YWdUeXBlLCB0YWcsIHRoaXMpO1xuICAgICAgICBpZiAoZ2VuZXJpY1RhZykge1xuICAgICAgICAgICAgdGhpcy5wb3N0TWFwKHRhZ1R5cGUsIGdlbmVyaWNUYWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBnZW5lcmljIHRhZ1xuICAgICAqL1xuICAgIHNldEdlbmVyaWNUYWcodGFnVHlwZSwgdGFnKSB7XG4gICAgICAgIGRlYnVnKGBjb21tb24uJHt0YWcuaWR9ID0gJHt0YWcudmFsdWV9YCk7XG4gICAgICAgIGNvbnN0IHByaW8wID0gdGhpcy5jb21tb25PcmlnaW5bdGFnLmlkXSB8fCAxMDAwO1xuICAgICAgICBjb25zdCBwcmlvMSA9IHRoaXMub3JpZ2luUHJpb3JpdHlbdGFnVHlwZV07XG4gICAgICAgIGlmIChHZW5lcmljVGFnVHlwZXNfMS5pc1NpbmdsZXRvbih0YWcuaWQpKSB7XG4gICAgICAgICAgICBpZiAocHJpbzEgPD0gcHJpbzApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdID0gdGFnLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uT3JpZ2luW3RhZy5pZF0gPSBwcmlvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhgSWdub3JlIG5hdGl2ZSB0YWcgKHNpbmdsZXRvbik6ICR7dGFnVHlwZX0uJHt0YWcuaWR9ID0gJHt0YWcudmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJpbzEgPT09IHByaW8wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFHZW5lcmljVGFnVHlwZXNfMS5pc1VuaXF1ZSh0YWcuaWQpIHx8IHRoaXMuY29tbW9uW3RhZy5pZF0uaW5kZXhPZih0YWcudmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdLnB1c2godGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBJZ25vcmUgZHVwbGljYXRlIHZhbHVlOiAke3RhZ1R5cGV9LiR7dGFnLmlkfSA9ICR7dGFnLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBlZmZlY3Q/IHRoaXMuY29tbW9uT3JpZ2luW3RhZy5pZF0gPSBwcmlvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByaW8xIDwgcHJpbzApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdID0gW3RhZy52YWx1ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25PcmlnaW5bdGFnLmlkXSA9IHByaW8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnKGBJZ25vcmUgbmF0aXZlIHRhZyAobGlzdCk6ICR7dGFnVHlwZX0uJHt0YWcuaWR9ID0gJHt0YWcudmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm9ic2VydmVyKHsgbWV0YWRhdGE6IHRoaXMsIHRhZzogeyB0eXBlOiAnY29tbW9uJywgaWQ6IHRhZy5pZCwgdmFsdWU6IHRhZy52YWx1ZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvRG86IHRyaWdnZXIgbWV0YWRhdGEgZXZlbnRcbiAgICB9XG59XG5leHBvcnRzLk1ldGFkYXRhQ29sbGVjdG9yID0gTWV0YWRhdGFDb2xsZWN0b3I7XG5mdW5jdGlvbiBqb2luQXJ0aXN0cyhhcnRpc3RzKSB7XG4gICAgaWYgKGFydGlzdHMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gYXJ0aXN0cy5zbGljZSgwLCBhcnRpc3RzLmxlbmd0aCAtIDEpLmpvaW4oJywgJykgKyAnICYgJyArIGFydGlzdHNbYXJ0aXN0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFydGlzdHMuam9pbignICYgJyk7XG59XG5leHBvcnRzLmpvaW5BcnRpc3RzID0gam9pbkFydGlzdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXRhZGF0YUNvbGxlY3Rvci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/MetadataCollector.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/RandomBufferReader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/RandomBufferReader.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RandomBufferReader = void 0;\n/**\n * Provides abstract Node Buffer access via the IRandomRead interface\n */\nclass RandomBufferReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.fileSize = buf.length;\n    }\n    /**\n     * Read from a given position of an abstracted file or buffer.\n     * @param buffer {Buffer} is the buffer that the data will be written to.\n     * @param offset {number} is the offset in the buffer to start writing at.\n     * @param length {number}is an integer specifying the number of bytes to read.\n     * @param position {number} is an argument specifying where to begin reading from in the file.\n     * @return {Promise<number>} bytes read\n     */\n    async randomRead(buffer, offset, length, position) {\n        return this.buf.copy(buffer, offset, position, position + length);\n    }\n}\nexports.RandomBufferReader = RandomBufferReader;\n//# sourceMappingURL=RandomBufferReader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9SYW5kb21CdWZmZXJSZWFkZXIuanM/Njk1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixzQkFBc0IsT0FBTztBQUM3QixzQkFBc0IsT0FBTztBQUM3Qix3QkFBd0IsT0FBTztBQUMvQixnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vUmFuZG9tQnVmZmVyUmVhZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmRvbUJ1ZmZlclJlYWRlciA9IHZvaWQgMDtcbi8qKlxuICogUHJvdmlkZXMgYWJzdHJhY3QgTm9kZSBCdWZmZXIgYWNjZXNzIHZpYSB0aGUgSVJhbmRvbVJlYWQgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFJhbmRvbUJ1ZmZlclJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLmZpbGVTaXplID0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIGEgZ2l2ZW4gcG9zaXRpb24gb2YgYW4gYWJzdHJhY3RlZCBmaWxlIG9yIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gYnVmZmVyIHtCdWZmZXJ9IGlzIHRoZSBidWZmZXIgdGhhdCB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8uXG4gICAgICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfSBpcyB0aGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyBhdC5cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHtudW1iZXJ9aXMgYW4gaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24ge251bWJlcn0gaXMgYW4gYXJndW1lbnQgc3BlY2lmeWluZyB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb20gaW4gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSBieXRlcyByZWFkXG4gICAgICovXG4gICAgYXN5bmMgcmFuZG9tUmVhZChidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuY29weShidWZmZXIsIG9mZnNldCwgcG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnRzLlJhbmRvbUJ1ZmZlclJlYWRlciA9IFJhbmRvbUJ1ZmZlclJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJhbmRvbUJ1ZmZlclJlYWRlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/RandomBufferReader.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/Util.js":
/*!********************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/Util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst Windows1292Decoder_1 = __webpack_require__(/*! ./Windows1292Decoder */ \"./node_modules/music-metadata/lib/common/Windows1292Decoder.js\");\nclass Util {\n    /**\n     *\n     * @param buffer\n     * @param start\n     * @param end\n     * @param encoding // ToDo: ts.enum\n     * @return {number}\n     */\n    static findZero(buffer, start, end, encoding) {\n        let i = start;\n        if (encoding === 'utf16') {\n            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n                if (i >= end)\n                    return end;\n                i += 2;\n            }\n            return i;\n        }\n        else {\n            while (buffer[i] !== 0) {\n                if (i >= end)\n                    return end;\n                i++;\n            }\n            return i;\n        }\n    }\n    static trimRightNull(x) {\n        const pos0 = x.indexOf('\\0');\n        return pos0 === -1 ? x : x.substr(0, pos0);\n    }\n    static swapBytes(buffer) {\n        const l = buffer.length;\n        assert.ok((l & 1) === 0, 'Buffer length must be even');\n        for (let i = 0; i < l; i += 2) {\n            const a = buffer[i];\n            buffer[i] = buffer[i + 1];\n            buffer[i + 1] = a;\n        }\n        return buffer;\n    }\n    static readUTF16String(buffer) {\n        let offset = 0;\n        if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian\n            buffer = Util.swapBytes(buffer);\n            offset = 2;\n        }\n        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian\n            offset = 2;\n        }\n        return buffer.toString('ucs2', offset);\n    }\n    /**\n     *\n     * @param buffer Decoder input data\n     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\n     * @return {string}\n     */\n    static decodeString(buffer, encoding) {\n        // annoying workaround for a double BOM issue\n        // https://github.com/leetreveil/musicmetadata/issues/84\n        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n            buffer = buffer.slice(2);\n        }\n        if (encoding === 'utf16le' || encoding === 'utf16') {\n            return Util.readUTF16String(buffer);\n        }\n        else if (encoding === 'utf8') {\n            return buffer.toString('utf8');\n        }\n        else if (encoding === 'iso-8859-1') {\n            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\n        }\n        throw Error(encoding + ' encoding is not supported!');\n    }\n    static stripNulls(str) {\n        str = str.replace(/^\\x00+/g, '');\n        str = str.replace(/\\x00+$/g, '');\n        return str;\n    }\n    /**\n     * Read bit-aligned number start from buffer\n     * Total offset in bits = byteOffset * 8 + bitOffset\n     * @param buf Byte buffer\n     * @param byteOffset Starting offset in bytes\n     * @param bitOffset Starting offset in bits: 0 = lsb\n     * @param len Length of number in bits\n     * @return {number} decoded bit aligned number\n     */\n    static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\n        const byteOff = byteOffset + ~~(bitOffset / 8);\n        const bitOff = bitOffset % 8;\n        let value = buf[byteOff];\n        value &= 0xff >> bitOff;\n        const bitsRead = 8 - bitOff;\n        const bitsLeft = len - bitsRead;\n        if (bitsLeft < 0) {\n            value >>= (8 - bitOff - len);\n        }\n        else if (bitsLeft > 0) {\n            value <<= bitsLeft;\n            value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\n        }\n        return value;\n    }\n    /**\n     * Read bit-aligned number start from buffer\n     * Total offset in bits = byteOffset * 8 + bitOffset\n     * @param buf Byte buffer\n     * @param byteOffset Starting offset in bytes\n     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\n     * @return {number} decoded bit aligned number\n     */\n    static isBitSet(buf, byteOffset, bitOffset) {\n        return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\n    }\n    static a2hex(str) {\n        const arr = [];\n        for (let i = 0, l = str.length; i < l; i++) {\n            const hex = Number(str.charCodeAt(i)).toString(16);\n            arr.push(hex.length === 1 ? '0' + hex : hex);\n        }\n        return arr.join(' ');\n    }\n}\nexports.default = Util;\nUtil.strtokBITSET = {\n    get: (buf, off, bit) => {\n        return (buf[off] & (1 << bit)) !== 0;\n    },\n    len: 1\n};\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n    return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    // @ts-ignore\n    if (ps.length >= 1) {\n        const v = parseFloat(ps[0]);\n        if (ps.length === 2 && ps[1] === 'db') {\n            return {\n                dB: v,\n                ratio: dbToRatio(v)\n            };\n        }\n        else {\n            return {\n                dB: ratioToDb(v),\n                ratio: v\n            };\n        }\n    }\n}\nexports.toRatio = toRatio;\n//# sourceMappingURL=Util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9VdGlsLmpzP2QzYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUTtBQUMvQiw2QkFBNkIsbUJBQU8sQ0FBQyw0RkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9VdGlsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvUmF0aW8gPSBleHBvcnRzLmRiVG9SYXRpbyA9IGV4cG9ydHMucmF0aW9Ub0RiID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IFdpbmRvd3MxMjkyRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vV2luZG93czEyOTJEZWNvZGVyXCIpO1xuY2xhc3MgVXRpbCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZmVyXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqIEBwYXJhbSBlbmNvZGluZyAvLyBUb0RvOiB0cy5lbnVtXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kWmVybyhidWZmZXIsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMCB8fCBidWZmZXJbaSArIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgdHJpbVJpZ2h0TnVsbCh4KSB7XG4gICAgICAgIGNvbnN0IHBvczAgPSB4LmluZGV4T2YoJ1xcMCcpO1xuICAgICAgICByZXR1cm4gcG9zMCA9PT0gLTEgPyB4IDogeC5zdWJzdHIoMCwgcG9zMCk7XG4gICAgfVxuICAgIHN0YXRpYyBzd2FwQnl0ZXMoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGwgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBhc3NlcnQub2soKGwgJiAxKSA9PT0gMCwgJ0J1ZmZlciBsZW5ndGggbXVzdCBiZSBldmVuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gYnVmZmVyW2ldO1xuICAgICAgICAgICAgYnVmZmVyW2ldID0gYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPSBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyByZWFkVVRGMTZTdHJpbmcoYnVmZmVyKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBpZiAoYnVmZmVyWzBdID09PSAweEZFICYmIGJ1ZmZlclsxXSA9PT0gMHhGRikgeyAvLyBiaWcgZW5kaWFuXG4gICAgICAgICAgICBidWZmZXIgPSBVdGlsLnN3YXBCeXRlcyhidWZmZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidWZmZXJbMF0gPT09IDB4RkYgJiYgYnVmZmVyWzFdID09PSAweEZFKSB7IC8vIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgICAgIG9mZnNldCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndWNzMicsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmZlciBEZWNvZGVyIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgJ3V0ZjE2bGUnIHwgJ3V0ZjE2JyB8ICd1dGY4JyB8ICdpc28tODg1OS0xJ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlU3RyaW5nKGJ1ZmZlciwgZW5jb2RpbmcpIHtcbiAgICAgICAgLy8gYW5ub3lpbmcgd29ya2Fyb3VuZCBmb3IgYSBkb3VibGUgQk9NIGlzc3VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sZWV0cmV2ZWlsL211c2ljbWV0YWRhdGEvaXNzdWVzLzg0XG4gICAgICAgIGlmIChidWZmZXJbMF0gPT09IDB4RkYgJiYgYnVmZmVyWzFdID09PSAweEZFICYmIGJ1ZmZlclsyXSA9PT0gMHhGRSAmJiBidWZmZXJbM10gPT09IDB4RkYpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwucmVhZFVURjE2U3RyaW5nKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIHJldHVybiBXaW5kb3dzMTI5MkRlY29kZXJfMS5XaW5kb3dzMTI5MkRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoZW5jb2RpbmcgKyAnIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpcE51bGxzKHN0cikge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxceDAwKy9nLCAnJyk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHgwMCskL2csICcnKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBiaXQtYWxpZ25lZCBudW1iZXIgc3RhcnQgZnJvbSBidWZmZXJcbiAgICAgKiBUb3RhbCBvZmZzZXQgaW4gYml0cyA9IGJ5dGVPZmZzZXQgKiA4ICsgYml0T2Zmc2V0XG4gICAgICogQHBhcmFtIGJ1ZiBCeXRlIGJ1ZmZlclxuICAgICAqIEBwYXJhbSBieXRlT2Zmc2V0IFN0YXJ0aW5nIG9mZnNldCBpbiBieXRlc1xuICAgICAqIEBwYXJhbSBiaXRPZmZzZXQgU3RhcnRpbmcgb2Zmc2V0IGluIGJpdHM6IDAgPSBsc2JcbiAgICAgKiBAcGFyYW0gbGVuIExlbmd0aCBvZiBudW1iZXIgaW4gYml0c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gZGVjb2RlZCBiaXQgYWxpZ25lZCBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBieXRlT2Zmc2V0LCBiaXRPZmZzZXQsIGxlbikge1xuICAgICAgICBjb25zdCBieXRlT2ZmID0gYnl0ZU9mZnNldCArIH5+KGJpdE9mZnNldCAvIDgpO1xuICAgICAgICBjb25zdCBiaXRPZmYgPSBiaXRPZmZzZXQgJSA4O1xuICAgICAgICBsZXQgdmFsdWUgPSBidWZbYnl0ZU9mZl07XG4gICAgICAgIHZhbHVlICY9IDB4ZmYgPj4gYml0T2ZmO1xuICAgICAgICBjb25zdCBiaXRzUmVhZCA9IDggLSBiaXRPZmY7XG4gICAgICAgIGNvbnN0IGJpdHNMZWZ0ID0gbGVuIC0gYml0c1JlYWQ7XG4gICAgICAgIGlmIChiaXRzTGVmdCA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlID4+PSAoOCAtIGJpdE9mZiAtIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA8PD0gYml0c0xlZnQ7XG4gICAgICAgICAgICB2YWx1ZSB8PSBVdGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1ZiwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0ICsgYml0c1JlYWQsIGJpdHNMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYml0LWFsaWduZWQgbnVtYmVyIHN0YXJ0IGZyb20gYnVmZmVyXG4gICAgICogVG90YWwgb2Zmc2V0IGluIGJpdHMgPSBieXRlT2Zmc2V0ICogOCArIGJpdE9mZnNldFxuICAgICAqIEBwYXJhbSBidWYgQnl0ZSBidWZmZXJcbiAgICAgKiBAcGFyYW0gYnl0ZU9mZnNldCBTdGFydGluZyBvZmZzZXQgaW4gYnl0ZXNcbiAgICAgKiBAcGFyYW0gYml0T2Zmc2V0IFN0YXJ0aW5nIG9mZnNldCBpbiBiaXRzOiAwID0gbW9zdCBzaWduaWZpY2FudCBiaXQsIDcgaXMgbGVhc3Qgc2lnbmlmaWNhbnQgYml0XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBkZWNvZGVkIGJpdCBhbGlnbmVkIG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBpc0JpdFNldChidWYsIGJ5dGVPZmZzZXQsIGJpdE9mZnNldCkge1xuICAgICAgICByZXR1cm4gVXRpbC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIGJ5dGVPZmZzZXQsIGJpdE9mZnNldCwgMSkgPT09IDE7XG4gICAgfVxuICAgIHN0YXRpYyBhMmhleChzdHIpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gTnVtYmVyKHN0ci5jaGFyQ29kZUF0KGkpKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBhcnIucHVzaChoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyLmpvaW4oJyAnKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBVdGlsO1xuVXRpbC5zdHJ0b2tCSVRTRVQgPSB7XG4gICAgZ2V0OiAoYnVmLCBvZmYsIGJpdCkgPT4ge1xuICAgICAgICByZXR1cm4gKGJ1ZltvZmZdICYgKDEgPDwgYml0KSkgIT09IDA7XG4gICAgfSxcbiAgICBsZW46IDFcbn07XG4vKipcbiAqIENvbnZlcnQgcG93ZXIgcmF0aW8gdG8gREJcbiAqIHJhdGlvOiBbMC4uMV1cbiAqL1xuZnVuY3Rpb24gcmF0aW9Ub0RiKHJhdGlvKSB7XG4gICAgcmV0dXJuIDEwICogTWF0aC5sb2cxMChyYXRpbyk7XG59XG5leHBvcnRzLnJhdGlvVG9EYiA9IHJhdGlvVG9EYjtcbi8qKlxuICogQ29udmVydCBkQiB0byByYXRpb1xuICogZGIgRGVjaWJlbHNcbiAqL1xuZnVuY3Rpb24gZGJUb1JhdGlvKGRCKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCBkQiAvIDEwKTtcbn1cbmV4cG9ydHMuZGJUb1JhdGlvID0gZGJUb1JhdGlvO1xuLyoqXG4gKiBDb252ZXJ0IHJlcGxheSBnYWluIHRvIHJhdGlvIGFuZCBEZWNpYmVsXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIGhvbGRpbmcgYSByYXRpbyBsaWtlICcwLjAzNCcgb3IgJy03LjU0IGRCJ1xuICovXG5mdW5jdGlvbiB0b1JhdGlvKHZhbHVlKSB7XG4gICAgY29uc3QgcHMgPSB2YWx1ZS5zcGxpdCgnICcpLm1hcChwID0+IHAudHJpbSgpLnRvTG93ZXJDYXNlKCkpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAocHMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29uc3QgdiA9IHBhcnNlRmxvYXQocHNbMF0pO1xuICAgICAgICBpZiAocHMubGVuZ3RoID09PSAyICYmIHBzWzFdID09PSAnZGInKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRCOiB2LFxuICAgICAgICAgICAgICAgIHJhdGlvOiBkYlRvUmF0aW8odilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRCOiByYXRpb1RvRGIodiksXG4gICAgICAgICAgICAgICAgcmF0aW86IHZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRvUmF0aW8gPSB0b1JhdGlvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/Util.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/common/Windows1292Decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/Windows1292Decoder.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Windows1292Decoder = void 0;\n/**\n * windows-1252 / iso_8859-1 decoder (ANSI)\n */\nclass Windows1292Decoder {\n    static decode(buffer) {\n        let str = '';\n        for (const i in buffer) {\n            if (buffer.hasOwnProperty(i)) {\n                str += Windows1292Decoder.codePointToString(Windows1292Decoder.singleByteDecoder(buffer[i]));\n            }\n        }\n        return str;\n    }\n    static inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    static codePointToString(cp) {\n        if (cp <= 0xFFFF) {\n            return String.fromCharCode(cp);\n        }\n        else {\n            cp -= 0x10000;\n            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n        }\n    }\n    static singleByteDecoder(bite) {\n        if (Windows1292Decoder.inRange(bite, 0x00, 0x7F)) {\n            return bite;\n        }\n        const codePoint = Windows1292Decoder.windows1252[bite - 0x80];\n        if (codePoint === null) {\n            throw Error('invaliding encoding');\n        }\n        return codePoint;\n    }\n}\nexports.Windows1292Decoder = Windows1292Decoder;\nWindows1292Decoder.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,\n    8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,\n    8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n    169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,\n    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,\n    201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,\n    217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,\n    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\n    248, 249, 250, 251, 252, 253, 254, 255];\n//# sourceMappingURL=Windows1292Decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9XaW5kb3dzMTI5MkRlY29kZXIuanM/MmU2NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL1dpbmRvd3MxMjkyRGVjb2Rlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XaW5kb3dzMTI5MkRlY29kZXIgPSB2b2lkIDA7XG4vKipcbiAqIHdpbmRvd3MtMTI1MiAvIGlzb184ODU5LTEgZGVjb2RlciAoQU5TSSlcbiAqL1xuY2xhc3MgV2luZG93czEyOTJEZWNvZGVyIHtcbiAgICBzdGF0aWMgZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gV2luZG93czEyOTJEZWNvZGVyLmNvZGVQb2ludFRvU3RyaW5nKFdpbmRvd3MxMjkyRGVjb2Rlci5zaW5nbGVCeXRlRGVjb2RlcihidWZmZXJbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBzdGF0aWMgaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluIDw9IGEgJiYgYSA8PSBtYXg7XG4gICAgfVxuICAgIHN0YXRpYyBjb2RlUG9pbnRUb1N0cmluZyhjcCkge1xuICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNwID4+IDEwKSArIDB4RDgwMCwgKGNwICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2luZ2xlQnl0ZURlY29kZXIoYml0ZSkge1xuICAgICAgICBpZiAoV2luZG93czEyOTJEZWNvZGVyLmluUmFuZ2UoYml0ZSwgMHgwMCwgMHg3RikpIHtcbiAgICAgICAgICAgIHJldHVybiBiaXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IFdpbmRvd3MxMjkyRGVjb2Rlci53aW5kb3dzMTI1MltiaXRlIC0gMHg4MF07XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnZhbGlkaW5nIGVuY29kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICB9XG59XG5leHBvcnRzLldpbmRvd3MxMjkyRGVjb2RlciA9IFdpbmRvd3MxMjkyRGVjb2RlcjtcbldpbmRvd3MxMjkyRGVjb2Rlci53aW5kb3dzMTI1MiA9IFs4MzY0LCAxMjksIDgyMTgsIDQwMiwgODIyMiwgODIzMCwgODIyNCwgODIyNSwgNzEwLCA4MjQwLCAzNTIsXG4gICAgODI0OSwgMzM4LCAxNDEsIDM4MSwgMTQzLCAxNDQsIDgyMTYsIDgyMTcsIDgyMjAsIDgyMjEsIDgyMjYsIDgyMTEsIDgyMTIsIDczMixcbiAgICA4NDgyLCAzNTMsIDgyNTAsIDMzOSwgMTU3LCAzODIsIDM3NiwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCxcbiAgICAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsXG4gICAgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLFxuICAgIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNixcbiAgICAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsXG4gICAgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NyxcbiAgICAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaW5kb3dzMTI5MkRlY29kZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/common/Windows1292Decoder.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/core.js":
/*!*************************************************!*\
  !*** ./node_modules/music-metadata/lib/core.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scanAppendingHeaders = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst ParserFactory_1 = __webpack_require__(/*! ./ParserFactory */ \"./node_modules/music-metadata/lib/ParserFactory.js\");\nconst RandomBufferReader_1 = __webpack_require__(/*! ./common/RandomBufferReader */ \"./node_modules/music-metadata/lib/common/RandomBufferReader.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ./apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ./id3v1/ID3v1Parser */ \"./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst Lyrics3_1 = __webpack_require__(/*! ./lyrics3/Lyrics3 */ \"./node_modules/music-metadata/lib/lyrics3/Lyrics3.js\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n    return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param buf - Buffer holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(buf, fileInfo, options = {}) {\n    const bufferReader = new RandomBufferReader_1.RandomBufferReader(buf);\n    await scanAppendingHeaders(bufferReader, options);\n    const tokenizer = strtok3.fromBuffer(buf, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\n    return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n    return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n    const tags = {};\n    for (const tag of nativeTags) {\n        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\n    }\n    return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n    let apeOffset = randomReader.fileSize;\n    if (await ID3v1Parser_1.hasID3v1Header(randomReader)) {\n        apeOffset -= 128;\n        const lyricsLen = await Lyrics3_1.getLyricsHeaderLength(randomReader);\n        apeOffset -= lyricsLen;\n    }\n    options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvcmUuanM/ZTM3NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWtCO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLDJFQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBNkI7QUFDbEUsc0JBQXNCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQseUZBQXlGLHFCQUFxQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsOEVBQThFLHFCQUFxQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb3JlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjYW5BcHBlbmRpbmdIZWFkZXJzID0gZXhwb3J0cy5yYXRpbmdUb1N0YXJzID0gZXhwb3J0cy5vcmRlclRhZ3MgPSBleHBvcnRzLnBhcnNlRnJvbVRva2VuaXplciA9IGV4cG9ydHMucGFyc2VCdWZmZXIgPSBleHBvcnRzLnBhcnNlU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RydG9rMyA9IHJlcXVpcmUoXCJzdHJ0b2szL2xpYi9jb3JlXCIpO1xuY29uc3QgUGFyc2VyRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vUGFyc2VyRmFjdG9yeVwiKTtcbmNvbnN0IFJhbmRvbUJ1ZmZlclJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29tbW9uL1JhbmRvbUJ1ZmZlclJlYWRlclwiKTtcbmNvbnN0IEFQRXYyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IElEM3YxUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9pZDN2MS9JRDN2MVBhcnNlclwiKTtcbmNvbnN0IEx5cmljczNfMSA9IHJlcXVpcmUoXCIuL2x5cmljczMvTHlyaWNzM1wiKTtcbi8qKlxuICogUGFyc2UgYXVkaW8gZnJvbSBOb2RlIFN0cmVhbS5SZWFkYWJsZVxuICogQHBhcmFtIHN0cmVhbSAtIFN0cmVhbSB0byByZWFkIHRoZSBhdWRpbyB0cmFjayBmcm9tXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHBhcmFtIGZpbGVJbmZvIC0gRmlsZSBpbmZvcm1hdGlvbiBvYmplY3Qgb3IgTUlNRS10eXBlIHN0cmluZ1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdHJlYW0oc3RyZWFtLCBmaWxlSW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHBhcnNlRnJvbVRva2VuaXplcihzdHJ0b2szLmZyb21TdHJlYW0oc3RyZWFtLCB0eXBlb2YgZmlsZUluZm8gPT09ICdzdHJpbmcnID8geyBtaW1lVHlwZTogZmlsZUluZm8gfSA6IGZpbGVJbmZvKSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhcnNlU3RyZWFtID0gcGFyc2VTdHJlYW07XG4vKipcbiAqIFBhcnNlIGF1ZGlvIGZyb20gTm9kZSBCdWZmZXJcbiAqIEBwYXJhbSBidWYgLSBCdWZmZXIgaG9sZGluZyBhdWRpbyBkYXRhXG4gKiBAcGFyYW0gZmlsZUluZm8gLSBGaWxlIGluZm9ybWF0aW9uIG9iamVjdCBvciBNSU1FLXR5cGUgc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL0JvcmV3aXQvc3RydG9rMy9ibG9iL2U2OTM4YzgxZmY2ODUwNzRkNWViMzA2NGExMWMwYjAzY2E5MzRjMWQvc3JjL2luZGV4LnRzI0wxNVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWYsIGZpbGVJbmZvLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgUmFuZG9tQnVmZmVyUmVhZGVyXzEuUmFuZG9tQnVmZmVyUmVhZGVyKGJ1Zik7XG4gICAgYXdhaXQgc2NhbkFwcGVuZGluZ0hlYWRlcnMoYnVmZmVyUmVhZGVyLCBvcHRpb25zKTtcbiAgICBjb25zdCB0b2tlbml6ZXIgPSBzdHJ0b2szLmZyb21CdWZmZXIoYnVmLCB0eXBlb2YgZmlsZUluZm8gPT09ICdzdHJpbmcnID8geyBtaW1lVHlwZTogZmlsZUluZm8gfSA6IGZpbGVJbmZvKTtcbiAgICByZXR1cm4gcGFyc2VGcm9tVG9rZW5pemVyKHRva2VuaXplciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhcnNlQnVmZmVyID0gcGFyc2VCdWZmZXI7XG4vKipcbiAqIFBhcnNlIGF1ZGlvIGZyb20gSVRva2VuaXplciBzb3VyY2VcbiAqIEBwYXJhbSB0b2tlbml6ZXIgLSBBdWRpbyBzb3VyY2UgaW1wbGVtZW50aW5nIHRoZSB0b2tlbml6ZXIgaW50ZXJmYWNlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5pemVyKHRva2VuaXplciwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXJGYWN0b3J5XzEuUGFyc2VyRmFjdG9yeS5wYXJzZU9uQ29udGVudFR5cGUodG9rZW5pemVyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucGFyc2VGcm9tVG9rZW5pemVyID0gcGFyc2VGcm9tVG9rZW5pemVyO1xuLyoqXG4gKiBDcmVhdGUgYSBkaWN0aW9uYXJ5IG9yZGVyZWQgYnkgdGhlaXIgdGFnIGlkIChrZXkpXG4gKiBAcGFyYW0gbmF0aXZlVGFncyBsaXN0IG9mIHRhZ3NcbiAqIEByZXR1cm5zIHRhZ3MgaW5kZXhlZCBieSBpZFxuICovXG5mdW5jdGlvbiBvcmRlclRhZ3MobmF0aXZlVGFncykge1xuICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBuYXRpdmVUYWdzKSB7XG4gICAgICAgICh0YWdzW3RhZy5pZF0gPSAodGFnc1t0YWcuaWRdIHx8IFtdKSkucHVzaCh0YWcudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cbmV4cG9ydHMub3JkZXJUYWdzID0gb3JkZXJUYWdzO1xuLyoqXG4gKiBDb252ZXJ0IHJhdGluZyB0byAxLTUgc3RhciByYXRpbmdcbiAqIEBwYXJhbSByYXRpbmc6IE5vcm1hbGl6ZWQgcmF0aW5nIFswLi4xXSAoY29tbW9uLnJhdGluZ1tuXS5yYXRpbmcpXG4gKiBAcmV0dXJucyBOdW1iZXIgb2Ygc3RhcnM6IDEsIDIsIDMsIDQgb3IgNSBzdGFyc1xuICovXG5mdW5jdGlvbiByYXRpbmdUb1N0YXJzKHJhdGluZykge1xuICAgIHJldHVybiByYXRpbmcgPT09IHVuZGVmaW5lZCA/IDAgOiAxICsgTWF0aC5yb3VuZChyYXRpbmcgKiA0KTtcbn1cbmV4cG9ydHMucmF0aW5nVG9TdGFycyA9IHJhdGluZ1RvU3RhcnM7XG5hc3luYyBmdW5jdGlvbiBzY2FuQXBwZW5kaW5nSGVhZGVycyhyYW5kb21SZWFkZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBhcGVPZmZzZXQgPSByYW5kb21SZWFkZXIuZmlsZVNpemU7XG4gICAgaWYgKGF3YWl0IElEM3YxUGFyc2VyXzEuaGFzSUQzdjFIZWFkZXIocmFuZG9tUmVhZGVyKSkge1xuICAgICAgICBhcGVPZmZzZXQgLT0gMTI4O1xuICAgICAgICBjb25zdCBseXJpY3NMZW4gPSBhd2FpdCBMeXJpY3MzXzEuZ2V0THlyaWNzSGVhZGVyTGVuZ3RoKHJhbmRvbVJlYWRlcik7XG4gICAgICAgIGFwZU9mZnNldCAtPSBseXJpY3NMZW47XG4gICAgfVxuICAgIG9wdGlvbnMuYXBlSGVhZGVyID0gYXdhaXQgQVBFdjJQYXJzZXJfMS5BUEV2MlBhcnNlci5maW5kQXBlRm9vdGVyT2Zmc2V0KHJhbmRvbVJlYWRlciwgYXBlT2Zmc2V0KTtcbn1cbmV4cG9ydHMuc2NhbkFwcGVuZGluZ0hlYWRlcnMgPSBzY2FuQXBwZW5kaW5nSGVhZGVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/core.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsdiffParser = void 0;\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst DsdiffToken_1 = __webpack_require__(/*! ./DsdiffToken */ \"./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n *  http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n        assert.strictEqual(header.chunkID, 'FRM8');\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw Error(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            case 'PROP': // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n                assert.strictEqual(propType, 'SND ');\n                await this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);\n                break;\n            case 'ID3': // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n            case 'DSD':\n                this.metadata.setFormat('numberOfSamples', header.chunkSize * 8 / this.metadata.format.numberOfChannels);\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                break;\n        }\n        const remaining = header.chunkSize - (this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(remaining);\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                case 'CHNL': // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);\n                    break;\n                case 'CMPR': // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                case 'COMT':\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(sndPropHeader.chunkSize);\n            }\n            const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(remaining);\n            }\n            remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= FourCC_1.FourCcToken.len;\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\nexports.DsdiffParser = DsdiffParser;\n//# sourceMappingURL=DsdiffParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZGlmZi9Ec2RpZmZQYXJzZXIuanM/ZGVlNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBTztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDhFQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFrQjtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLFNBQVMsaUJBQWlCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWUsU0FBUyxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0IsU0FBUyx3QkFBd0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCLElBQUksZ0JBQWdCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0IsU0FBUyx3QkFBd0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXdCLGNBQWMsVUFBVTtBQUM1RztBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNkaWZmL0RzZGlmZlBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ec2RpZmZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBpbml0RGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBEc2RpZmZUb2tlbl8xID0gcmVxdWlyZShcIi4vRHNkaWZmVG9rZW5cIik7XG5jb25zdCBzdHJ0b2szID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBJRDN2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjphaWZmJyk7XG4vKipcbiAqIERTRElGRiAtIERpcmVjdCBTdHJlYW0gRGlnaXRhbCBJbnRlcmNoYW5nZSBGaWxlIEZvcm1hdCAoUGhpbGxpcHMpXG4gKlxuICogUmVmOlxuICogIGh0dHA6Ly93d3cuc29uaWNzdHVkaW8uY29tL3BkZi9kc2QvRFNESUZGXzEuNV9TcGVjLnBkZlxuICovXG5jbGFzcyBEc2RpZmZQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZGlmZlRva2VuXzEuQ2h1bmtIZWFkZXIpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoaGVhZGVyLmNodW5rSUQsICdGUk04Jyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKSkudHJpbSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RTRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsIGBEU0RJRkYvJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGbXQ4Q2h1bmtzKGhlYWRlci5jaHVua1NpemUgLSBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5sZW4pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgRFNESUZGIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkRm10OENodW5rcyhyZW1haW5pbmdTaXplKSB7XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmdTaXplID49IERzZGlmZlRva2VuXzEuQ2h1bmtIZWFkZXIubGVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua0hlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihEc2RpZmZUb2tlbl8xLkNodW5rSGVhZGVyKTtcbiAgICAgICAgICAgIC8vICBJZiB0aGUgZGF0YSBpcyBhbiBvZGQgbnVtYmVyIG9mIGJ5dGVzIGluIGxlbmd0aCwgYSBwYWQgYnl0ZSBtdXN0IGJlIGFkZGVkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGRlYnVnKGBDaHVuayBpZD0ke2NodW5rSGVhZGVyLmNodW5rSUR9YCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhKGNodW5rSGVhZGVyKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ1NpemUgLT0gKERzZGlmZlRva2VuXzEuQ2h1bmtIZWFkZXIubGVuICsgY2h1bmtIZWFkZXIuY2h1bmtTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YShoZWFkZXIpIHtcbiAgICAgICAgZGVidWcoYFJlYWRpbmcgZGF0YSBvZiBjaHVua1tJRD0ke2hlYWRlci5jaHVua0lEfSwgc2l6ZT0ke2hlYWRlci5jaHVua1NpemV9XWApO1xuICAgICAgICBjb25zdCBwMCA9IHRoaXMudG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICBzd2l0Y2ggKGhlYWRlci5jaHVua0lELnRyaW0oKSkge1xuICAgICAgICAgICAgY2FzZSAnRlZFUic6IC8vIDMuMSBGT1JNQVQgVkVSU0lPTiBDSFVOS1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDMyX0xFKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgRFNESUZGIHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUFJPUCc6IC8vIDMuMiBQUk9QRVJUWSBDSFVOS1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BUeXBlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocHJvcFR5cGUsICdTTkQgJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTb3VuZFByb3BlcnR5Q2h1bmtzKGhlYWRlci5jaHVua1NpemUgLSBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5sZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSUQzJzogLy8gVW5vZmZpY2lhbCBJRDMgdGFnIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBjb25zdCBpZDNfZGF0YSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uQnVmZmVyVHlwZShoZWFkZXIuY2h1bmtTaXplKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnN0ID0gc3RydG9rMy5mcm9tQnVmZmVyKGlkM19kYXRhKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgSUQzdjJQYXJzZXJfMS5JRDN2MlBhcnNlcigpLnBhcnNlKHRoaXMubWV0YWRhdGEsIHJzdCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVidWcoYElnbm9yZSBjaHVua1tJRD0ke2hlYWRlci5jaHVua0lEfSwgc2l6ZT0ke2hlYWRlci5jaHVua1NpemV9XWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRFNEJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgaGVhZGVyLmNodW5rU2l6ZSAqIDggLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5udW1iZXJPZkNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCB0aGlzLm1ldGFkYXRhLmZvcm1hdC5udW1iZXJPZlNhbXBsZXMgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBoZWFkZXIuY2h1bmtTaXplIC0gKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gcDApO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgZGVidWcoYEFmdGVyIFBhcnNpbmcgY2h1bmssIHJlbWFpbmluZyAke3JlbWFpbmluZ30gYnl0ZXNgKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShyZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVNvdW5kUHJvcGVydHlDaHVua3MocmVtYWluaW5nU2l6ZSkge1xuICAgICAgICBkZWJ1ZyhgUGFyc2luZyBzb3VuZC1wcm9wZXJ0eS1jaHVua3MsIHJlbWFpbmluZ1NpemU9JHtyZW1haW5pbmdTaXplfWApO1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNuZFByb3BIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRHNkaWZmVG9rZW5fMS5DaHVua0hlYWRlcik7XG4gICAgICAgICAgICBkZWJ1ZyhgU291bmQtcHJvcGVydHktY2h1bmtbSUQ9JHtzbmRQcm9wSGVhZGVyLmNodW5rSUR9LCBzaXplPSR7c25kUHJvcEhlYWRlci5jaHVua1NpemV9XWApO1xuICAgICAgICAgICAgY29uc3QgcDAgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjtcbiAgICAgICAgICAgIHN3aXRjaCAoc25kUHJvcEhlYWRlci5jaHVua0lELnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ZTJzogLy8gMy4yLjEgU2FtcGxlIFJhdGUgQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMzJfQkUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIHNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDSE5MJzogLy8gMy4yLjIgQ2hhbm5lbHMgQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtQ2hhbm5lbHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDE2X0JFKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBudW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlQ2hhbm5lbENodW5rcyhzbmRQcm9wSGVhZGVyLmNodW5rU2l6ZSAtIFRva2VuLlVJTlQxNl9CRS5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDTVBSJzogLy8gMy4yLjMgQ29tcHJlc3Npb24gVHlwZSBDaHVua1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2lvbklkQ29kZSA9IChhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRm91ckNDXzEuRm91ckNjVG9rZW4pKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQ4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3Npb25OYW1lID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKGNvdW50LCAnYXNjaWknKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc2lvbklkQ29kZSA9PT0gJ0RTRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHNQZXJTYW1wbGUnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCBgJHtjb21wcmVzc2lvbklkQ29kZX0gKCR7Y29tcHJlc3Npb25OYW1lfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQUJTUyc6IC8vIDMuMi40IEFic29sdXRlIFN0YXJ0IFRpbWUgQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG91cnMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDE2X0JFKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVzID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9CRSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBBQlNTICR7aG91cnN9OiR7bWludXRlc306JHtzZWNvbmRzfS4ke3NhbXBsZXN9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0xTQ08nOiAvLyAzLjIuNSBMb3Vkc3BlYWtlciBDb25maWd1cmF0aW9uIENodW5rXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxzQ29uZmlnID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQxNl9CRSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBMU0NPIGxzQ29uZmlnPSR7bHNDb25maWd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0NPTVQnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBVbmtub3duIHNvdW5kLXByb3BlcnR5LWNodW5rW0lEPSR7c25kUHJvcEhlYWRlci5jaHVua0lEfSwgc2l6ZT0ke3NuZFByb3BIZWFkZXIuY2h1bmtTaXplfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKHNuZFByb3BIZWFkZXIuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHNuZFByb3BIZWFkZXIuY2h1bmtTaXplIC0gKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gcDApO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgQWZ0ZXIgUGFyc2luZyBzb3VuZC1wcm9wZXJ0eS1jaHVuayAke3NuZFByb3BIZWFkZXIuY2h1bmtTaXplfSwgcmVtYWluaW5nICR7cmVtYWluaW5nfSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBEc2RpZmZUb2tlbl8xLkNodW5rSGVhZGVyLmxlbiArIHNuZFByb3BIZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICAgICAgZGVidWcoYFBhcnNpbmcgc291bmQtcHJvcGVydHktY2h1bmtzLCByZW1haW5pbmdTaXplPSR7cmVtYWluaW5nU2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQubG9zc2xlc3MgJiYgdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5udW1iZXJPZkNoYW5uZWxzICYmIHRoaXMubWV0YWRhdGEuZm9ybWF0LmJpdHNQZXJTYW1wbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHJhdGUgPSB0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlICogdGhpcy5tZXRhZGF0YS5mb3JtYXQubnVtYmVyT2ZDaGFubmVscyAqIHRoaXMubWV0YWRhdGEuZm9ybWF0LmJpdHNQZXJTYW1wbGU7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYW5uZWxDaHVua3MocmVtYWluaW5nU2l6ZSkge1xuICAgICAgICBkZWJ1ZyhgUGFyc2luZyBjaGFubmVsLWNodW5rcywgcmVtYWluaW5nU2l6ZT0ke3JlbWFpbmluZ1NpemV9YCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gW107XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmdTaXplID49IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmxlbikge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbElkID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKTtcbiAgICAgICAgICAgIGRlYnVnKGBDaGFubmVsW0lEPSR7Y2hhbm5lbElkfV1gKTtcbiAgICAgICAgICAgIGNoYW5uZWxzLnB1c2goY2hhbm5lbElkKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ1NpemUgLT0gRm91ckNDXzEuRm91ckNjVG9rZW4ubGVuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKGBDaGFubmVsczogJHtjaGFubmVscy5qb2luKCcsICcpfWApO1xuICAgICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfVxufVxuZXhwb3J0cy5Ec2RpZmZQYXJzZXIgPSBEc2RpZmZQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ec2RpZmZQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js":
/*!***************************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChunkHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * DSDIFF chunk header\n * The data-size encoding is deviating from EA-IFF 85\n * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nexports.ChunkHeader = {\n    len: 12,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: FourCC_1.FourCcToken.get(buf, off),\n            // Size\n            chunkSize: Token.INT64_BE.get(buf, off + 4)\n        };\n    }\n};\n//# sourceMappingURL=DsdiffToken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZGlmZi9Ec2RpZmZUb2tlbi5qcz9jYzA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZGlmZi9Ec2RpZmZUb2tlbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHVua0hlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbi8qKlxuICogRFNESUZGIGNodW5rIGhlYWRlclxuICogVGhlIGRhdGEtc2l6ZSBlbmNvZGluZyBpcyBkZXZpYXRpbmcgZnJvbSBFQS1JRkYgODVcbiAqIFJlZjogaHR0cDovL3d3dy5zb25pY3N0dWRpby5jb20vcGRmL2RzZC9EU0RJRkZfMS41X1NwZWMucGRmXG4gKi9cbmV4cG9ydHMuQ2h1bmtIZWFkZXIgPSB7XG4gICAgbGVuOiAxMixcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gR3JvdXAtSURcbiAgICAgICAgICAgIGNodW5rSUQ6IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBTaXplXG4gICAgICAgICAgICBjaHVua1NpemU6IFRva2VuLklOVDY0X0JFLmdldChidWYsIG9mZiArIDQpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURzZGlmZlRva2VuLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/dsf/DsfChunk.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfChunk.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormatChunk = exports.ChannelType = exports.DsdChunk = exports.ChunkHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.ChunkHeader = {\n    len: 12,\n    get: (buf, off) => {\n        return { id: FourCC_1.FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\n    }\n};\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.DsdChunk = {\n    len: 16,\n    get: (buf, off) => {\n        return {\n            fileSize: Token.INT64_LE.get(buf, off),\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\n        };\n    }\n};\nvar ChannelType;\n(function (ChannelType) {\n    ChannelType[ChannelType[\"mono\"] = 1] = \"mono\";\n    ChannelType[ChannelType[\"stereo\"] = 2] = \"stereo\";\n    ChannelType[ChannelType[\"channels\"] = 3] = \"channels\";\n    ChannelType[ChannelType[\"quad\"] = 4] = \"quad\";\n    ChannelType[ChannelType[\"4 channels\"] = 5] = \"4 channels\";\n    ChannelType[ChannelType[\"5 channels\"] = 6] = \"5 channels\";\n    ChannelType[ChannelType[\"5.1 channels\"] = 7] = \"5.1 channels\";\n})(ChannelType = exports.ChannelType || (exports.ChannelType = {}));\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.FormatChunk = {\n    len: 40,\n    get: (buf, off) => {\n        return {\n            formatVersion: Token.INT32_LE.get(buf, off),\n            formatID: Token.INT32_LE.get(buf, off + 4),\n            channelType: Token.INT32_LE.get(buf, off + 8),\n            channelNum: Token.INT32_LE.get(buf, off + 12),\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\n        };\n    }\n};\n//# sourceMappingURL=DsfChunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZi9Ec2ZDaHVuay5qcz9lMjNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZi9Ec2ZDaHVuay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXRDaHVuayA9IGV4cG9ydHMuQ2hhbm5lbFR5cGUgPSBleHBvcnRzLkRzZENodW5rID0gZXhwb3J0cy5DaHVua0hlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbi8qKlxuICogQ29tbW9uIGNodW5rIERTRCBoZWFkZXI6IHRoZSAnY2h1bmsgbmFtZSAoRm91ci1DQyknICYgY2h1bmsgc2l6ZVxuICovXG5leHBvcnRzLkNodW5rSGVhZGVyID0ge1xuICAgIGxlbjogMTIsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgaWQ6IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksIHNpemU6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA0KSB9O1xuICAgIH1cbn07XG4vKipcbiAqIENvbW1vbiBjaHVuayBEU0QgaGVhZGVyOiB0aGUgJ2NodW5rIG5hbWUgKEZvdXItQ0MpJyAmIGNodW5rIHNpemVcbiAqL1xuZXhwb3J0cy5Ec2RDaHVuayA9IHtcbiAgICBsZW46IDE2LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlU2l6ZTogVG9rZW4uSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIG1ldGFkYXRhUG9pbnRlcjogVG9rZW4uSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgOClcbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIENoYW5uZWxUeXBlO1xuKGZ1bmN0aW9uIChDaGFubmVsVHlwZSkge1xuICAgIENoYW5uZWxUeXBlW0NoYW5uZWxUeXBlW1wibW9ub1wiXSA9IDFdID0gXCJtb25vXCI7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCJzdGVyZW9cIl0gPSAyXSA9IFwic3RlcmVvXCI7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCJjaGFubmVsc1wiXSA9IDNdID0gXCJjaGFubmVsc1wiO1xuICAgIENoYW5uZWxUeXBlW0NoYW5uZWxUeXBlW1wicXVhZFwiXSA9IDRdID0gXCJxdWFkXCI7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCI0IGNoYW5uZWxzXCJdID0gNV0gPSBcIjQgY2hhbm5lbHNcIjtcbiAgICBDaGFubmVsVHlwZVtDaGFubmVsVHlwZVtcIjUgY2hhbm5lbHNcIl0gPSA2XSA9IFwiNSBjaGFubmVsc1wiO1xuICAgIENoYW5uZWxUeXBlW0NoYW5uZWxUeXBlW1wiNS4xIGNoYW5uZWxzXCJdID0gN10gPSBcIjUuMSBjaGFubmVsc1wiO1xufSkoQ2hhbm5lbFR5cGUgPSBleHBvcnRzLkNoYW5uZWxUeXBlIHx8IChleHBvcnRzLkNoYW5uZWxUeXBlID0ge30pKTtcbi8qKlxuICogQ29tbW9uIGNodW5rIERTRCBoZWFkZXI6IHRoZSAnY2h1bmsgbmFtZSAoRm91ci1DQyknICYgY2h1bmsgc2l6ZVxuICovXG5leHBvcnRzLkZvcm1hdENodW5rID0ge1xuICAgIGxlbjogNDAsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdFZlcnNpb246IFRva2VuLklOVDMyX0xFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmb3JtYXRJRDogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICBjaGFubmVsVHlwZTogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICBjaGFubmVsTnVtOiBUb2tlbi5JTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICBzYW1wbGluZ0ZyZXF1ZW5jeTogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTYpLFxuICAgICAgICAgICAgYml0c1BlclNhbXBsZTogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgc2FtcGxlQ291bnQ6IFRva2VuLklOVDY0X0xFLmdldChidWYsIG9mZiArIDI0KSxcbiAgICAgICAgICAgIGJsb2NrU2l6ZVBlckNoYW5uZWw6IFRva2VuLklOVDMyX0xFLmdldChidWYsIG9mZiArIDMyKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ec2ZDaHVuay5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/dsf/DsfChunk.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/dsf/DsfParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfParser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsfParser = void 0;\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst DsfChunk_1 = __webpack_require__(/*! ./DsfChunk */ \"./node_modules/music-metadata/lib/dsf/DsfChunk.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst debug = _debug('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async _parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n        assert.strictEqual(chunkHeader.id, 'DSD ', 'Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n        if (dsdChunk.metadataPointer === 0) {\n            debug(`No ID3v2 tag present`);\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ':\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                default:\n                    this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\nexports.DsfParser = DsfParser;\n//# sourceMappingURL=DsfParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZi9Ec2ZQYXJzZXIuanM/MmNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsNEJBQTRCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQ2hFLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsOEVBQU87QUFDOUIsbUJBQW1CLG1CQUFPLENBQUMscUVBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWUsUUFBUSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2RzZi9Ec2ZQYXJzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRzZlBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IEFic3RyYWN0SUQzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXJcIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgX2RlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgRHNmQ2h1bmtfMSA9IHJlcXVpcmUoXCIuL0RzZkNodW5rXCIpO1xuY29uc3QgSUQzdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2Mi9JRDN2MlBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6RFNGJyk7XG4vKipcbiAqIERTRiAoZHNkIHN0cmVhbSBmaWxlKSBGaWxlIFBhcnNlclxuICogUmVmOiBodHRwczovL2RzZC1ndWlkZS5jb20vc2l0ZXMvZGVmYXVsdC9maWxlcy93aGl0ZS1wYXBlcnMvRFNGRmlsZUZvcm1hdFNwZWNfRS5wZGZcbiAqL1xuY2xhc3MgRHNmUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RJRDNQYXJzZXJfMS5BYnN0cmFjdElEM1BhcnNlciB7XG4gICAgYXN5bmMgX3BhcnNlKCkge1xuICAgICAgICBjb25zdCBwMCA9IHRoaXMudG9rZW5pemVyLnBvc2l0aW9uOyAvLyBtYXJrIHN0YXJ0IHBvc2l0aW9uLCBub3JtYWxseSAwXG4gICAgICAgIGNvbnN0IGNodW5rSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZkNodW5rXzEuQ2h1bmtIZWFkZXIpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2h1bmtIZWFkZXIuaWQsICdEU0QgJywgJ0ludmFsaWQgY2h1bmsgc2lnbmF0dXJlJyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnRFNGJyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIHRydWUpO1xuICAgICAgICBjb25zdCBkc2RDaHVuayA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihEc2ZDaHVua18xLkRzZENodW5rKTtcbiAgICAgICAgaWYgKGRzZENodW5rLm1ldGFkYXRhUG9pbnRlciA9PT0gMCkge1xuICAgICAgICAgICAgZGVidWcoYE5vIElEM3YyIHRhZyBwcmVzZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhgZXhwZWN0IElEM3YyIGF0IG9mZnNldD0ke2RzZENodW5rLm1ldGFkYXRhUG9pbnRlcn1gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VDaHVua3MoZHNkQ2h1bmsuZmlsZVNpemUgLSBjaHVua0hlYWRlci5zaXplKTtcbiAgICAgICAgICAgIC8vIEp1bXAgdG8gSUQzIGhlYWRlclxuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGRzZENodW5rLm1ldGFkYXRhUG9pbnRlciAtIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gcDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRDN2MlBhcnNlcl8xLklEM3YyUGFyc2VyKCkucGFyc2UodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VDaHVua3MoYnl0ZXNSZW1haW5pbmcpIHtcbiAgICAgICAgd2hpbGUgKGJ5dGVzUmVtYWluaW5nID49IERzZkNodW5rXzEuQ2h1bmtIZWFkZXIubGVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua0hlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihEc2ZDaHVua18xLkNodW5rSGVhZGVyKTtcbiAgICAgICAgICAgIGRlYnVnKGBQYXJzaW5nIGNodW5rIG5hbWU9JHtjaHVua0hlYWRlci5pZH0gc2l6ZT0ke2NodW5rSGVhZGVyLnNpemV9YCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rSGVhZGVyLmlkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm10ICc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdENodW5rID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZkNodW5rXzEuRm9ybWF0Q2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGZvcm1hdENodW5rLmNoYW5uZWxOdW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGZvcm1hdENodW5rLnNhbXBsaW5nRnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHNQZXJTYW1wbGUnLCBmb3JtYXRDaHVuay5iaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mU2FtcGxlcycsIGZvcm1hdENodW5rLnNhbXBsZUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgZm9ybWF0Q2h1bmsuc2FtcGxlQ291bnQgLyBmb3JtYXRDaHVuay5zYW1wbGluZ0ZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdHJhdGUgPSBmb3JtYXRDaHVuay5iaXRzUGVyU2FtcGxlICogZm9ybWF0Q2h1bmsuc2FtcGxpbmdGcmVxdWVuY3kgKiBmb3JtYXRDaHVuay5jaGFubmVsTnVtO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGJpdHJhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFdlIGdvdCB3aGF0IHdlIHdhbnQsIHN0b3AgZnVydGhlciBwcm9jZXNzaW5nIG9mIGNodW5rc1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmlnbm9yZShjaHVua0hlYWRlci5zaXplIC0gRHNmQ2h1bmtfMS5DaHVua0hlYWRlci5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzUmVtYWluaW5nIC09IGNodW5rSGVhZGVyLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRzZlBhcnNlciA9IERzZlBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURzZlBhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/dsf/DsfParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/flac/FlacParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/flac/FlacParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlacParser = void 0;\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Vorbis_1 = __webpack_require__(/*! ../ogg/vorbis/Vorbis */ \"./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisParser */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst VorbisDecoder_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisDecoder */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\nconst debug = _debug('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.padding = 0;\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n        return this;\n    }\n    async _parse() {\n        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new Error('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                return this.parsePicture(blockHeader.length).then();\n            default:\n                this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== Metadata.BlockStreamInfo.len)\n            throw new Error('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Token.BufferType(dataLen));\n        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        for (let i = 0; i < commentListLength; i++) {\n            const tag = decoder.parseUserComment();\n            this.vorbisParser.addTag(tag.key, tag.value);\n        }\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        else {\n            const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n            this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n        }\n    }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {\n}\nMetadata.BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),\n            type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),\n            length: Token.UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: Token.UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Token.BufferType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceMappingURL=FlacParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2ZsYWMvRmxhY1BhcnNlci5qcz9hMDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQ2hFLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFrQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsOEVBQU87QUFDOUIsdUJBQXVCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLGtHQUE2QjtBQUM3RDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCLFdBQVcsbUJBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2ZsYWMvRmxhY1BhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmxhY1BhcnNlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgVm9yYmlzXzEgPSByZXF1aXJlKFwiLi4vb2dnL3ZvcmJpcy9Wb3JiaXNcIik7XG5jb25zdCBBYnN0cmFjdElEM1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0Fic3RyYWN0SUQzUGFyc2VyXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbmNvbnN0IF9kZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFZvcmJpc1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL29nZy92b3JiaXMvVm9yYmlzUGFyc2VyXCIpO1xuY29uc3QgVm9yYmlzRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uL29nZy92b3JiaXMvVm9yYmlzRGVjb2RlclwiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6RkxBQycpO1xuLyoqXG4gKiBGTEFDIHN1cHBvcnRzIHVwIHRvIDEyOCBraW5kcyBvZiBtZXRhZGF0YSBibG9ja3M7IGN1cnJlbnRseSB0aGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkOlxuICogcmVmOiBodHRwczovL3hpcGgub3JnL2ZsYWMvZm9ybWF0Lmh0bWwjbWV0YWRhdGFfYmxvY2tcbiAqL1xudmFyIEJsb2NrVHlwZTtcbihmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlNUUkVBTUlORk9cIl0gPSAwXSA9IFwiU1RSRUFNSU5GT1wiO1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJQQURESU5HXCJdID0gMV0gPSBcIlBBRERJTkdcIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiQVBQTElDQVRJT05cIl0gPSAyXSA9IFwiQVBQTElDQVRJT05cIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiU0VFS1RBQkxFXCJdID0gM10gPSBcIlNFRUtUQUJMRVwiO1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJWT1JCSVNfQ09NTUVOVFwiXSA9IDRdID0gXCJWT1JCSVNfQ09NTUVOVFwiO1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJDVUVTSEVFVFwiXSA9IDVdID0gXCJDVUVTSEVFVFwiO1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJQSUNUVVJFXCJdID0gNl0gPSBcIlBJQ1RVUkVcIjtcbn0pKEJsb2NrVHlwZSB8fCAoQmxvY2tUeXBlID0ge30pKTtcbmNsYXNzIEZsYWNQYXJzZXIgZXh0ZW5kcyBBYnN0cmFjdElEM1BhcnNlcl8xLkFic3RyYWN0SUQzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBwYXJzZXIgd2l0aCBvdXRwdXQgKG1ldGFkYXRhKSwgaW5wdXQgKHRva2VuaXplcikgJiBwYXJzaW5nIG9wdGlvbnMgKG9wdGlvbnMpLlxuICAgICAqIEBwYXJhbSB7SU5hdGl2ZU1ldGFkYXRhQ29sbGVjdG9yfSBtZXRhZGF0YSBPdXRwdXRcbiAgICAgKiBAcGFyYW0ge0lUb2tlbml6ZXJ9IHRva2VuaXplciBJbnB1dFxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnMgUGFyc2luZyBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdChtZXRhZGF0YSwgdG9rZW5pemVyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmluaXQobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudm9yYmlzUGFyc2VyID0gbmV3IFZvcmJpc1BhcnNlcl8xLlZvcmJpc1BhcnNlcihtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBfcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGZvdXJDQyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgIGlmIChmb3VyQ0MudG9TdHJpbmcoKSAhPT0gJ2ZMYUMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRkxBQyBwcmVhbWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja0hlYWRlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gUmVhZCBibG9jayBoZWFkZXJcbiAgICAgICAgICAgIGJsb2NrSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKE1ldGFkYXRhLkJsb2NrSGVhZGVyKTtcbiAgICAgICAgICAgIC8vIFBhcnNlIGJsb2NrIGRhdGFcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VEYXRhQmxvY2soYmxvY2tIZWFkZXIpO1xuICAgICAgICB9IHdoaWxlICghYmxvY2tIZWFkZXIubGFzdEJsb2NrKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgJiYgdGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogZGF0YVNpemUgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VEYXRhQmxvY2soYmxvY2tIZWFkZXIpIHtcbiAgICAgICAgZGVidWcoYGJsb2NrSGVhZGVyIHR5cGU9JHtibG9ja0hlYWRlci50eXBlfSwgbGVuZ3RoPSR7YmxvY2tIZWFkZXIubGVuZ3RofWApO1xuICAgICAgICBzd2l0Y2ggKGJsb2NrSGVhZGVyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlNUUkVBTUlORk86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9ja1N0cmVhbUluZm8oYmxvY2tIZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlBBRERJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nICs9IGJsb2NrSGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLkFQUExJQ0FUSU9OOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCbG9ja1R5cGUuU0VFS1RBQkxFOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCbG9ja1R5cGUuVk9SQklTX0NPTU1FTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21tZW50KGJsb2NrSGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIEJsb2NrVHlwZS5DVUVTSEVFVDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlBJQ1RVUkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQaWN0dXJlKGJsb2NrSGVhZGVyLmxlbmd0aCkudGhlbigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ1Vua25vd24gYmxvY2sgdHlwZTogJyArIGJsb2NrSGVhZGVyLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBkYXRhIGJsb2NrXG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuaXplci5pZ25vcmUoYmxvY2tIZWFkZXIubGVuZ3RoKS50aGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIFNUUkVBTUlORk9cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZUJsb2NrU3RyZWFtSW5mbyhkYXRhTGVuKSB7XG4gICAgICAgIGlmIChkYXRhTGVuICE9PSBNZXRhZGF0YS5CbG9ja1N0cmVhbUluZm8ubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGJsb2NrLXN0cmVhbS1pbmZvIGxlbmd0aCcpO1xuICAgICAgICBjb25zdCBzdHJlYW1JbmZvID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKE1ldGFkYXRhLkJsb2NrU3RyZWFtSW5mbyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnRkxBQycpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAnRkxBQycpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBzdHJlYW1JbmZvLmNoYW5uZWxzKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHNQZXJTYW1wbGUnLCBzdHJlYW1JbmZvLmJpdHNQZXJTYW1wbGUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIHN0cmVhbUluZm8uc2FtcGxlUmF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW1JbmZvLnRvdGFsU2FtcGxlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIHN0cmVhbUluZm8udG90YWxTYW1wbGVzIC8gc3RyZWFtSW5mby5zYW1wbGVSYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBWT1JCSVNfQ09NTUVOVFxuICAgICAqIFJlZjogaHR0cHM6Ly93d3cueGlwaC5vcmcvdm9yYmlzL2RvYy9Wb3JiaXNfSV9zcGVjLmh0bWwjeDEtNjQwMDA0LjIuM1xuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQ29tbWVudChkYXRhTGVuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLkJ1ZmZlclR5cGUoZGF0YUxlbikpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFZvcmJpc0RlY29kZXJfMS5Wb3JiaXNEZWNvZGVyKGRhdGEsIDApO1xuICAgICAgICBkZWNvZGVyLnJlYWRTdHJpbmdVdGY4KCk7IC8vIHZlbmRvciAoc2tpcClcbiAgICAgICAgY29uc3QgY29tbWVudExpc3RMZW5ndGggPSBkZWNvZGVyLnJlYWRJbnQzMigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1lbnRMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGRlY29kZXIucGFyc2VVc2VyQ29tbWVudCgpO1xuICAgICAgICAgICAgdGhpcy52b3JiaXNQYXJzZXIuYWRkVGFnKHRhZy5rZXksIHRhZy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VQaWN0dXJlKGRhdGFMZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIuaWdub3JlKGRhdGFMZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGljdHVyZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVm9yYmlzXzEuVm9yYmlzUGljdHVyZVRva2VuKGRhdGFMZW4pKTtcbiAgICAgICAgICAgIHRoaXMudm9yYmlzUGFyc2VyLmFkZFRhZygnTUVUQURBVEFfQkxPQ0tfUElDVFVSRScsIHBpY3R1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GbGFjUGFyc2VyID0gRmxhY1BhcnNlcjtcbmNsYXNzIE1ldGFkYXRhIHtcbn1cbk1ldGFkYXRhLkJsb2NrSGVhZGVyID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdEJsb2NrOiBVdGlsXzEuZGVmYXVsdC5zdHJ0b2tCSVRTRVQuZ2V0KGJ1Ziwgb2ZmLCA3KSxcbiAgICAgICAgICAgIHR5cGU6IFV0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAxLCA3KSxcbiAgICAgICAgICAgIGxlbmd0aDogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogTUVUQURBVEFfQkxPQ0tfREFUQVxuICogUmVmOiBodHRwczovL3hpcGgub3JnL2ZsYWMvZm9ybWF0Lmh0bWwjbWV0YWRhdGFfYmxvY2tfc3RyZWFtaW5mb1xuICovXG5NZXRhZGF0YS5CbG9ja1N0cmVhbUluZm8gPSB7XG4gICAgbGVuOiAzNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhlIG1pbmltdW0gYmxvY2sgc2l6ZSAoaW4gc2FtcGxlcykgdXNlZCBpbiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgbWluaW11bUJsb2NrU2l6ZTogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBibG9jayBzaXplIChpbiBzYW1wbGVzKSB1c2VkIGluIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAvLyAoTWluaW11bSBibG9ja3NpemUgPT0gbWF4aW11bSBibG9ja3NpemUpIGltcGxpZXMgYSBmaXhlZC1ibG9ja3NpemUgc3RyZWFtLlxuICAgICAgICAgICAgbWF4aW11bUJsb2NrU2l6ZTogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDIpIC8gMTAwMCxcbiAgICAgICAgICAgIC8vIFRoZSBtaW5pbXVtIGZyYW1lIHNpemUgKGluIGJ5dGVzKSB1c2VkIGluIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAvLyBNYXkgYmUgMCB0byBpbXBseSB0aGUgdmFsdWUgaXMgbm90IGtub3duLlxuICAgICAgICAgICAgbWluaW11bUZyYW1lU2l6ZTogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZnJhbWUgc2l6ZSAoaW4gYnl0ZXMpIHVzZWQgaW4gdGhlIHN0cmVhbS5cbiAgICAgICAgICAgIC8vIE1heSBiZSAwIHRvIGltcGx5IHRoZSB2YWx1ZSBpcyBub3Qga25vd24uXG4gICAgICAgICAgICBtYXhpbXVtRnJhbWVTaXplOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgNyksXG4gICAgICAgICAgICAvLyBTYW1wbGUgcmF0ZSBpbiBIei4gVGhvdWdoIDIwIGJpdHMgYXJlIGF2YWlsYWJsZSxcbiAgICAgICAgICAgIC8vIHRoZSBtYXhpbXVtIHNhbXBsZSByYXRlIGlzIGxpbWl0ZWQgYnkgdGhlIHN0cnVjdHVyZSBvZiBmcmFtZSBoZWFkZXJzIHRvIDY1NTM1MEh6LlxuICAgICAgICAgICAgLy8gQWxzbywgYSB2YWx1ZSBvZiAwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTApID4+IDQsXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzbG93ZXI6IHNhbXBsZVJhdGU6IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEwLCAwLCAyMCksXG4gICAgICAgICAgICAvLyAobnVtYmVyIG9mIGNoYW5uZWxzKS0xLiBGTEFDIHN1cHBvcnRzIGZyb20gMSB0byA4IGNoYW5uZWxzXG4gICAgICAgICAgICBjaGFubmVsczogVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMiwgNCwgMykgKyAxLFxuICAgICAgICAgICAgLy8gYml0cyBwZXIgc2FtcGxlKS0xLlxuICAgICAgICAgICAgLy8gRkxBQyBzdXBwb3J0cyBmcm9tIDQgdG8gMzIgYml0cyBwZXIgc2FtcGxlLiBDdXJyZW50bHkgdGhlIHJlZmVyZW5jZSBlbmNvZGVyIGFuZCBkZWNvZGVycyBvbmx5IHN1cHBvcnQgdXAgdG8gMjQgYml0cyBwZXIgc2FtcGxlLlxuICAgICAgICAgICAgYml0c1BlclNhbXBsZTogVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMiwgNywgNSkgKyAxLFxuICAgICAgICAgICAgLy8gVG90YWwgc2FtcGxlcyBpbiBzdHJlYW0uXG4gICAgICAgICAgICAvLyAnU2FtcGxlcycgbWVhbnMgaW50ZXItY2hhbm5lbCBzYW1wbGUsIGkuZS4gb25lIHNlY29uZCBvZiA0NC4xS2h6IGF1ZGlvIHdpbGwgaGF2ZSA0NDEwMCBzYW1wbGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIG51bWJlciBvZiBjaGFubmVscy5cbiAgICAgICAgICAgIC8vIEEgdmFsdWUgb2YgemVybyBoZXJlIG1lYW5zIHRoZSBudW1iZXIgb2YgdG90YWwgc2FtcGxlcyBpcyB1bmtub3duLlxuICAgICAgICAgICAgdG90YWxTYW1wbGVzOiBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEzLCA0LCAzNiksXG4gICAgICAgICAgICAvLyB0aGUgTUQ1IGhhc2ggb2YgdGhlIGZpbGUgKHNlZSBub3RlcyBmb3IgdXNhZ2UuLi4gaXQncyBhIGxpdHRseSB0cmlja3kpXG4gICAgICAgICAgICBmaWxlTUQ1OiBuZXcgVG9rZW4uQnVmZmVyVHlwZSgxNikuZ2V0KGJ1Ziwgb2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZsYWNQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/flac/FlacParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasID3v1Header = exports.ID3v1Parser = exports.Genres = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst debug = initDebug('music-metadata:parser:ID3v1');\n/**\n * ID3v1 Genre mappings\n * Ref: https://de.wikipedia.org/wiki/Liste_der_ID3v1-Genres\n */\nexports.Genres = [\n    \"Blues\", \"Classic Rock\", \"Country\", \"Dance\", \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\",\n    \"Jazz\", \"Metal\", \"New Age\", \"Oldies\", \"Other\", \"Pop\", \"R&B\", \"Rap\", \"Reggae\", \"Rock\",\n    \"Techno\", \"Industrial\", \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\", \"Soundtrack\",\n    \"Euro-Techno\", \"Ambient\", \"Trip-Hop\", \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\",\n    \"Classical\", \"Instrumental\", \"Acid\", \"House\", \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\",\n    \"Alt. Rock\", \"Bass\", \"Soul\", \"Punk\", \"Space\", \"Meditative\", \"Instrumental Pop\",\n    \"Instrumental Rock\", \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\",\n    \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\", \"Southern Rock\", \"Comedy\", \"Cult\",\n    \"Gangsta Rap\", \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\", \"Native American\",\n    \"Cabaret\", \"New Wave\", \"Psychedelic\", \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\", \"Tribal\",\n    \"Acid Punk\", \"Acid Jazz\", \"Polka\", \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\",\n    \"Folk\", \"Folk/Rock\", \"National Folk\", \"Swing\", \"Fast-Fusion\", \"Bebob\", \"Latin\", \"Revival\",\n    \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\", \"Progressive Rock\", \"Psychedelic Rock\",\n    \"Symphonic Rock\", \"Slow Rock\", \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\", \"Humour\",\n    \"Speech\", \"Chanson\", \"Opera\", \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\", \"Primus\",\n    \"Porn Groove\", \"Satire\", \"Slow Jam\", \"Club\", \"Tango\", \"Samba\", \"Folklore\",\n    \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\", \"Duet\", \"Punk Rock\", \"Drum Solo\",\n    \"A Cappella\", \"Euro-House\", \"Dance Hall\", \"Goa\", \"Drum & Bass\", \"Club-House\",\n    \"Hardcore\", \"Terror\", \"Indie\", \"BritPop\", \"Negerpunk\", \"Polsk Punk\", \"Beat\",\n    \"Christian Gangsta Rap\", \"Heavy Metal\", \"Black Metal\", \"Crossover\", \"Contemporary Christian\",\n    \"Christian Rock\", \"Merengue\", \"Salsa\", \"Thrash Metal\", \"Anime\", \"JPop\", \"Synthpop\",\n    \"Abstract\", \"Art Rock\", \"Baroque\", \"Bhangra\", \"Big Beat\", \"Breakbeat\", \"Chillout\",\n    \"Downtempo\", \"Dub\", \"EBM\", \"Eclectic\", \"Electro\", \"Electroclash\", \"Emo\", \"Experimental\",\n    \"Garage\", \"Global\", \"IDM\", \"Illbient\", \"Industro-Goth\", \"Jam Band\", \"Krautrock\",\n    \"Leftfield\", \"Lounge\", \"Math Rock\", \"New Romantic\", \"Nu-Breakz\", \"Post-Punk\", \"Post-Rock\",\n    \"Psytrance\", \"Shoegaze\", \"Space Rock\", \"Trop Rock\", \"World Music\", \"Neoclassical\", \"Audiobook\",\n    \"Audio Theatre\", \"Neue Deutsche Welle\", \"Podcast\", \"Indie Rock\", \"G-Funk\", \"Dubstep\",\n    \"Garage Rock\", \"Psybient\"\n];\n/**\n * Spec: http://id3.org/ID3v1\n * Wiki: https://en.wikipedia.org/wiki/ID3\n */\nconst Iid3v1Token = {\n    len: 128,\n    /**\n     * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header\n     * @param off Offset in buffer in bytes\n     * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned\n     */\n    get: (buf, off) => {\n        const header = new Id3v1StringType(3).get(buf, off);\n        return header === \"TAG\" ? {\n            header,\n            title: new Id3v1StringType(30).get(buf, off + 3),\n            artist: new Id3v1StringType(30).get(buf, off + 33),\n            album: new Id3v1StringType(30).get(buf, off + 63),\n            year: new Id3v1StringType(4).get(buf, off + 93),\n            comment: new Id3v1StringType(28).get(buf, off + 97),\n            // ID3v1.1 separator for track\n            zeroByte: Token.UINT8.get(buf, off + 127),\n            // track: ID3v1.1 field added by Michael Mutschler\n            track: Token.UINT8.get(buf, off + 126),\n            genre: Token.UINT8.get(buf, off + 127)\n        } : null;\n    }\n};\nclass Id3v1StringType extends Token.StringType {\n    constructor(len) {\n        super(len, \"binary\");\n    }\n    get(buf, off) {\n        let value = super.get(buf, off);\n        value = Util_1.default.trimRightNull(value);\n        value = value.trim();\n        return value.length > 0 ? value : undefined;\n    }\n}\nclass ID3v1Parser extends BasicParser_1.BasicParser {\n    static getGenre(genreIndex) {\n        if (genreIndex < exports.Genres.length) {\n            return exports.Genres[genreIndex];\n        }\n        return undefined; // ToDO: generate warning\n    }\n    async parse() {\n        if (!this.tokenizer.fileInfo.size) {\n            debug('Skip checking for ID3v1 because the file-size is unknown');\n            return;\n        }\n        if (this.options.apeHeader) {\n            this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);\n            const apeParser = new APEv2Parser_1.APEv2Parser();\n            apeParser.init(this.metadata, this.tokenizer, this.options);\n            await apeParser.parseTags(this.options.apeHeader.footer);\n        }\n        const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;\n        if (this.tokenizer.position > offset) {\n            debug('Already consumed the last 128 bytes');\n            return;\n        }\n        const header = await this.tokenizer.readToken(Iid3v1Token, offset);\n        if (header) {\n            debug(\"ID3v1 header found at: pos=%s\", this.tokenizer.fileInfo.size - Iid3v1Token.len);\n            for (const id of [\"title\", \"artist\", \"album\", \"comment\", \"track\", \"year\"]) {\n                if (header[id] && header[id] !== \"\")\n                    this.addTag(id, header[id]);\n            }\n            const genre = ID3v1Parser.getGenre(header.genre);\n            if (genre)\n                this.addTag('genre', genre);\n        }\n        else {\n            debug(\"ID3v1 header not found at: pos=%s\", this.tokenizer.fileInfo.size - Iid3v1Token.len);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('ID3v1', id, value);\n    }\n}\nexports.ID3v1Parser = ID3v1Parser;\nasync function hasID3v1Header(reader) {\n    if (reader.fileSize >= 128) {\n        const tag = Buffer.alloc(3);\n        await reader.randomRead(tag, 0, tag.length, reader.fileSize - 128);\n        return tag.toString('binary') === 'TAG';\n    }\n    return false;\n}\nexports.hasID3v1Header = hasID3v1Header;\n//# sourceMappingURL=ID3v1Parser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YxL0lEM3YxUGFyc2VyLmpzPzFlNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLHNGQUF1QjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2MS9JRDN2MVBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNJRDN2MUhlYWRlciA9IGV4cG9ydHMuSUQzdjFQYXJzZXIgPSBleHBvcnRzLkdlbnJlcyA9IHZvaWQgMDtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBBUEV2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2FwZXYyL0FQRXYyUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpJRDN2MScpO1xuLyoqXG4gKiBJRDN2MSBHZW5yZSBtYXBwaW5nc1xuICogUmVmOiBodHRwczovL2RlLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0ZV9kZXJfSUQzdjEtR2VucmVzXG4gKi9cbmV4cG9ydHMuR2VucmVzID0gW1xuICAgIFwiQmx1ZXNcIiwgXCJDbGFzc2ljIFJvY2tcIiwgXCJDb3VudHJ5XCIsIFwiRGFuY2VcIiwgXCJEaXNjb1wiLCBcIkZ1bmtcIiwgXCJHcnVuZ2VcIiwgXCJIaXAtSG9wXCIsXG4gICAgXCJKYXp6XCIsIFwiTWV0YWxcIiwgXCJOZXcgQWdlXCIsIFwiT2xkaWVzXCIsIFwiT3RoZXJcIiwgXCJQb3BcIiwgXCJSJkJcIiwgXCJSYXBcIiwgXCJSZWdnYWVcIiwgXCJSb2NrXCIsXG4gICAgXCJUZWNobm9cIiwgXCJJbmR1c3RyaWFsXCIsIFwiQWx0ZXJuYXRpdmVcIiwgXCJTa2FcIiwgXCJEZWF0aCBNZXRhbFwiLCBcIlByYW5rc1wiLCBcIlNvdW5kdHJhY2tcIixcbiAgICBcIkV1cm8tVGVjaG5vXCIsIFwiQW1iaWVudFwiLCBcIlRyaXAtSG9wXCIsIFwiVm9jYWxcIiwgXCJKYXp6K0Z1bmtcIiwgXCJGdXNpb25cIiwgXCJUcmFuY2VcIixcbiAgICBcIkNsYXNzaWNhbFwiLCBcIkluc3RydW1lbnRhbFwiLCBcIkFjaWRcIiwgXCJIb3VzZVwiLCBcIkdhbWVcIiwgXCJTb3VuZCBDbGlwXCIsIFwiR29zcGVsXCIsIFwiTm9pc2VcIixcbiAgICBcIkFsdC4gUm9ja1wiLCBcIkJhc3NcIiwgXCJTb3VsXCIsIFwiUHVua1wiLCBcIlNwYWNlXCIsIFwiTWVkaXRhdGl2ZVwiLCBcIkluc3RydW1lbnRhbCBQb3BcIixcbiAgICBcIkluc3RydW1lbnRhbCBSb2NrXCIsIFwiRXRobmljXCIsIFwiR290aGljXCIsIFwiRGFya3dhdmVcIiwgXCJUZWNobm8tSW5kdXN0cmlhbFwiLFxuICAgIFwiRWxlY3Ryb25pY1wiLCBcIlBvcC1Gb2xrXCIsIFwiRXVyb2RhbmNlXCIsIFwiRHJlYW1cIiwgXCJTb3V0aGVybiBSb2NrXCIsIFwiQ29tZWR5XCIsIFwiQ3VsdFwiLFxuICAgIFwiR2FuZ3N0YSBSYXBcIiwgXCJUb3AgNDBcIiwgXCJDaHJpc3RpYW4gUmFwXCIsIFwiUG9wL0Z1bmtcIiwgXCJKdW5nbGVcIiwgXCJOYXRpdmUgQW1lcmljYW5cIixcbiAgICBcIkNhYmFyZXRcIiwgXCJOZXcgV2F2ZVwiLCBcIlBzeWNoZWRlbGljXCIsIFwiUmF2ZVwiLCBcIlNob3d0dW5lc1wiLCBcIlRyYWlsZXJcIiwgXCJMby1GaVwiLCBcIlRyaWJhbFwiLFxuICAgIFwiQWNpZCBQdW5rXCIsIFwiQWNpZCBKYXp6XCIsIFwiUG9sa2FcIiwgXCJSZXRyb1wiLCBcIk11c2ljYWxcIiwgXCJSb2NrICYgUm9sbFwiLCBcIkhhcmQgUm9ja1wiLFxuICAgIFwiRm9sa1wiLCBcIkZvbGsvUm9ja1wiLCBcIk5hdGlvbmFsIEZvbGtcIiwgXCJTd2luZ1wiLCBcIkZhc3QtRnVzaW9uXCIsIFwiQmVib2JcIiwgXCJMYXRpblwiLCBcIlJldml2YWxcIixcbiAgICBcIkNlbHRpY1wiLCBcIkJsdWVncmFzc1wiLCBcIkF2YW50Z2FyZGVcIiwgXCJHb3RoaWMgUm9ja1wiLCBcIlByb2dyZXNzaXZlIFJvY2tcIiwgXCJQc3ljaGVkZWxpYyBSb2NrXCIsXG4gICAgXCJTeW1waG9uaWMgUm9ja1wiLCBcIlNsb3cgUm9ja1wiLCBcIkJpZyBCYW5kXCIsIFwiQ2hvcnVzXCIsIFwiRWFzeSBMaXN0ZW5pbmdcIiwgXCJBY291c3RpY1wiLCBcIkh1bW91clwiLFxuICAgIFwiU3BlZWNoXCIsIFwiQ2hhbnNvblwiLCBcIk9wZXJhXCIsIFwiQ2hhbWJlciBNdXNpY1wiLCBcIlNvbmF0YVwiLCBcIlN5bXBob255XCIsIFwiQm9vdHkgQmFzc1wiLCBcIlByaW11c1wiLFxuICAgIFwiUG9ybiBHcm9vdmVcIiwgXCJTYXRpcmVcIiwgXCJTbG93IEphbVwiLCBcIkNsdWJcIiwgXCJUYW5nb1wiLCBcIlNhbWJhXCIsIFwiRm9sa2xvcmVcIixcbiAgICBcIkJhbGxhZFwiLCBcIlBvd2VyIEJhbGxhZFwiLCBcIlJoeXRobWljIFNvdWxcIiwgXCJGcmVlc3R5bGVcIiwgXCJEdWV0XCIsIFwiUHVuayBSb2NrXCIsIFwiRHJ1bSBTb2xvXCIsXG4gICAgXCJBIENhcHBlbGxhXCIsIFwiRXVyby1Ib3VzZVwiLCBcIkRhbmNlIEhhbGxcIiwgXCJHb2FcIiwgXCJEcnVtICYgQmFzc1wiLCBcIkNsdWItSG91c2VcIixcbiAgICBcIkhhcmRjb3JlXCIsIFwiVGVycm9yXCIsIFwiSW5kaWVcIiwgXCJCcml0UG9wXCIsIFwiTmVnZXJwdW5rXCIsIFwiUG9sc2sgUHVua1wiLCBcIkJlYXRcIixcbiAgICBcIkNocmlzdGlhbiBHYW5nc3RhIFJhcFwiLCBcIkhlYXZ5IE1ldGFsXCIsIFwiQmxhY2sgTWV0YWxcIiwgXCJDcm9zc292ZXJcIiwgXCJDb250ZW1wb3JhcnkgQ2hyaXN0aWFuXCIsXG4gICAgXCJDaHJpc3RpYW4gUm9ja1wiLCBcIk1lcmVuZ3VlXCIsIFwiU2Fsc2FcIiwgXCJUaHJhc2ggTWV0YWxcIiwgXCJBbmltZVwiLCBcIkpQb3BcIiwgXCJTeW50aHBvcFwiLFxuICAgIFwiQWJzdHJhY3RcIiwgXCJBcnQgUm9ja1wiLCBcIkJhcm9xdWVcIiwgXCJCaGFuZ3JhXCIsIFwiQmlnIEJlYXRcIiwgXCJCcmVha2JlYXRcIiwgXCJDaGlsbG91dFwiLFxuICAgIFwiRG93bnRlbXBvXCIsIFwiRHViXCIsIFwiRUJNXCIsIFwiRWNsZWN0aWNcIiwgXCJFbGVjdHJvXCIsIFwiRWxlY3Ryb2NsYXNoXCIsIFwiRW1vXCIsIFwiRXhwZXJpbWVudGFsXCIsXG4gICAgXCJHYXJhZ2VcIiwgXCJHbG9iYWxcIiwgXCJJRE1cIiwgXCJJbGxiaWVudFwiLCBcIkluZHVzdHJvLUdvdGhcIiwgXCJKYW0gQmFuZFwiLCBcIktyYXV0cm9ja1wiLFxuICAgIFwiTGVmdGZpZWxkXCIsIFwiTG91bmdlXCIsIFwiTWF0aCBSb2NrXCIsIFwiTmV3IFJvbWFudGljXCIsIFwiTnUtQnJlYWt6XCIsIFwiUG9zdC1QdW5rXCIsIFwiUG9zdC1Sb2NrXCIsXG4gICAgXCJQc3l0cmFuY2VcIiwgXCJTaG9lZ2F6ZVwiLCBcIlNwYWNlIFJvY2tcIiwgXCJUcm9wIFJvY2tcIiwgXCJXb3JsZCBNdXNpY1wiLCBcIk5lb2NsYXNzaWNhbFwiLCBcIkF1ZGlvYm9va1wiLFxuICAgIFwiQXVkaW8gVGhlYXRyZVwiLCBcIk5ldWUgRGV1dHNjaGUgV2VsbGVcIiwgXCJQb2RjYXN0XCIsIFwiSW5kaWUgUm9ja1wiLCBcIkctRnVua1wiLCBcIkR1YnN0ZXBcIixcbiAgICBcIkdhcmFnZSBSb2NrXCIsIFwiUHN5YmllbnRcIlxuXTtcbi8qKlxuICogU3BlYzogaHR0cDovL2lkMy5vcmcvSUQzdjFcbiAqIFdpa2k6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lEM1xuICovXG5jb25zdCBJaWQzdjFUb2tlbiA9IHtcbiAgICBsZW46IDEyOCxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYnVmIEJ1ZmZlciBwb3NzaWJseSBob2xkaW5nIHRoZSAxMjggYnl0ZXMgSUQzdjEuMSBtZXRhZGF0YSBoZWFkZXJcbiAgICAgKiBAcGFyYW0gb2ZmIE9mZnNldCBpbiBidWZmZXIgaW4gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyBJRDN2MS4xIGhlYWRlciBpZiBmaXJzdCAzIGJ5dGVzIGVxdWFscyAnVEFHJywgb3RoZXJ3aXNlIG51bGwgaXMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgSWQzdjFTdHJpbmdUeXBlKDMpLmdldChidWYsIG9mZik7XG4gICAgICAgIHJldHVybiBoZWFkZXIgPT09IFwiVEFHXCIgPyB7XG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICB0aXRsZTogbmV3IElkM3YxU3RyaW5nVHlwZSgzMCkuZ2V0KGJ1Ziwgb2ZmICsgMyksXG4gICAgICAgICAgICBhcnRpc3Q6IG5ldyBJZDN2MVN0cmluZ1R5cGUoMzApLmdldChidWYsIG9mZiArIDMzKSxcbiAgICAgICAgICAgIGFsYnVtOiBuZXcgSWQzdjFTdHJpbmdUeXBlKDMwKS5nZXQoYnVmLCBvZmYgKyA2MyksXG4gICAgICAgICAgICB5ZWFyOiBuZXcgSWQzdjFTdHJpbmdUeXBlKDQpLmdldChidWYsIG9mZiArIDkzKSxcbiAgICAgICAgICAgIGNvbW1lbnQ6IG5ldyBJZDN2MVN0cmluZ1R5cGUoMjgpLmdldChidWYsIG9mZiArIDk3KSxcbiAgICAgICAgICAgIC8vIElEM3YxLjEgc2VwYXJhdG9yIGZvciB0cmFja1xuICAgICAgICAgICAgemVyb0J5dGU6IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDEyNyksXG4gICAgICAgICAgICAvLyB0cmFjazogSUQzdjEuMSBmaWVsZCBhZGRlZCBieSBNaWNoYWVsIE11dHNjaGxlclxuICAgICAgICAgICAgdHJhY2s6IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDEyNiksXG4gICAgICAgICAgICBnZW5yZTogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMTI3KVxuICAgICAgICB9IDogbnVsbDtcbiAgICB9XG59O1xuY2xhc3MgSWQzdjFTdHJpbmdUeXBlIGV4dGVuZHMgVG9rZW4uU3RyaW5nVHlwZSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHN1cGVyKGxlbiwgXCJiaW5hcnlcIik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICBsZXQgdmFsdWUgPSBzdXBlci5nZXQoYnVmLCBvZmYpO1xuICAgICAgICB2YWx1ZSA9IFV0aWxfMS5kZWZhdWx0LnRyaW1SaWdodE51bGwodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBJRDN2MVBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIHN0YXRpYyBnZXRHZW5yZShnZW5yZUluZGV4KSB7XG4gICAgICAgIGlmIChnZW5yZUluZGV4IDwgZXhwb3J0cy5HZW5yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5HZW5yZXNbZ2VucmVJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVG9ETzogZ2VuZXJhdGUgd2FybmluZ1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG4gICAgICAgICAgICBkZWJ1ZygnU2tpcCBjaGVja2luZyBmb3IgSUQzdjEgYmVjYXVzZSB0aGUgZmlsZS1zaXplIGlzIHVua25vd24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFwZUhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuaWdub3JlKHRoaXMub3B0aW9ucy5hcGVIZWFkZXIub2Zmc2V0IC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYXBlUGFyc2VyID0gbmV3IEFQRXYyUGFyc2VyXzEuQVBFdjJQYXJzZXIoKTtcbiAgICAgICAgICAgIGFwZVBhcnNlci5pbml0KHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgYXBlUGFyc2VyLnBhcnNlVGFncyh0aGlzLm9wdGlvbnMuYXBlSGVhZGVyLmZvb3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIElpZDN2MVRva2VuLmxlbjtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnQWxyZWFkeSBjb25zdW1lZCB0aGUgbGFzdCAxMjggYnl0ZXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oSWlkM3YxVG9rZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiSUQzdjEgaGVhZGVyIGZvdW5kIGF0OiBwb3M9JXNcIiwgdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIElpZDN2MVRva2VuLmxlbik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIFtcInRpdGxlXCIsIFwiYXJ0aXN0XCIsIFwiYWxidW1cIiwgXCJjb21tZW50XCIsIFwidHJhY2tcIiwgXCJ5ZWFyXCJdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcltpZF0gJiYgaGVhZGVyW2lkXSAhPT0gXCJcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcoaWQsIGhlYWRlcltpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VucmUgPSBJRDN2MVBhcnNlci5nZXRHZW5yZShoZWFkZXIuZ2VucmUpO1xuICAgICAgICAgICAgaWYgKGdlbnJlKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKCdnZW5yZScsIGdlbnJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiSUQzdjEgaGVhZGVyIG5vdCBmb3VuZCBhdDogcG9zPSVzXCIsIHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSBJaWQzdjFUb2tlbi5sZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRhZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoJ0lEM3YxJywgaWQsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLklEM3YxUGFyc2VyID0gSUQzdjFQYXJzZXI7XG5hc3luYyBmdW5jdGlvbiBoYXNJRDN2MUhlYWRlcihyZWFkZXIpIHtcbiAgICBpZiAocmVhZGVyLmZpbGVTaXplID49IDEyOCkge1xuICAgICAgICBjb25zdCB0YWcgPSBCdWZmZXIuYWxsb2MoMyk7XG4gICAgICAgIGF3YWl0IHJlYWRlci5yYW5kb21SZWFkKHRhZywgMCwgdGFnLmxlbmd0aCwgcmVhZGVyLmZpbGVTaXplIC0gMTI4KTtcbiAgICAgICAgcmV0dXJuIHRhZy50b1N0cmluZygnYmluYXJ5JykgPT09ICdUQUcnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmhhc0lEM3YxSGVhZGVyID0gaGFzSUQzdjFIZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JRDN2MVBhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ID3v1TagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * ID3v1 tag mappings\n */\nconst id3v1TagMap = {\n    title: 'title',\n    artist: 'artist',\n    album: 'album',\n    year: 'year',\n    comment: 'comment',\n    track: 'track',\n    genre: 'genre'\n};\nclass ID3v1TagMapper extends GenericTagMapper_1.CommonTagMapper {\n    constructor() {\n        super(['ID3v1'], id3v1TagMap);\n    }\n}\nexports.ID3v1TagMapper = ID3v1TagMapper;\n//# sourceMappingURL=ID3v1TagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YxL0lEM3YxVGFnTWFwLmpzPzM3ZDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLGdHQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjEvSUQzdjFUYWdNYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSUQzdjFUYWdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBHZW5lcmljVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0dlbmVyaWNUYWdNYXBwZXJcIik7XG4vKipcbiAqIElEM3YxIHRhZyBtYXBwaW5nc1xuICovXG5jb25zdCBpZDN2MVRhZ01hcCA9IHtcbiAgICB0aXRsZTogJ3RpdGxlJyxcbiAgICBhcnRpc3Q6ICdhcnRpc3QnLFxuICAgIGFsYnVtOiAnYWxidW0nLFxuICAgIHllYXI6ICd5ZWFyJyxcbiAgICBjb21tZW50OiAnY29tbWVudCcsXG4gICAgdHJhY2s6ICd0cmFjaycsXG4gICAgZ2VucmU6ICdnZW5yZSdcbn07XG5jbGFzcyBJRDN2MVRhZ01hcHBlciBleHRlbmRzIEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0lEM3YxJ10sIGlkM3YxVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLklEM3YxVGFnTWFwcGVyID0gSUQzdjFUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JRDN2MVRhZ01hcC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractID3Parser = void 0;\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ./ID3v2Parser */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst debug = _debug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nclass AbstractID3Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser_1.ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug(\"End of ID3v2 header, go to MPEG-parser: pos=%s\", this.tokenizer.position);\n        await this._parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser_1.ID3v1Parser();\n            await id3v1parser.init(this.metadata, this.tokenizer, this.options).parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header);\n        if (id3Header.fileIdentifier === \"ID3\") {\n            debug(\"Found ID3v2 header, pos=%s\", this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\nexports.AbstractID3Parser = AbstractID3Parser;\n//# sourceMappingURL=AbstractID3Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0Fic3RyYWN0SUQzUGFyc2VyLmpzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0REFBa0I7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsMkVBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsNkVBQWU7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyw4RUFBTztBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0Fic3RyYWN0SUQzUGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0SUQzUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBJRDN2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9JRDN2MlRva2VuXCIpO1xuY29uc3QgSUQzdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0lEM3YyUGFyc2VyXCIpO1xuY29uc3QgSUQzdjFQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2MS9JRDN2MVBhcnNlclwiKTtcbmNvbnN0IF9kZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSBfZGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpJRDMnKTtcbi8qKlxuICogQWJzdHJhY3QgcGFyc2VyIHdoaWNoIHRyaWVzIHRha2UgSUQzdjIgYW5kIElEM3YxIGhlYWRlcnMuXG4gKi9cbmNsYXNzIEFic3RyYWN0SUQzUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQzcGFyc2VyID0gbmV3IElEM3YyUGFyc2VyXzEuSUQzdjJQYXJzZXIoKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHN0YXJ0c1dpdGhJRDN2MkhlYWRlcih0b2tlbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0b2tlbml6ZXIucGVla1Rva2VuKElEM3YyVG9rZW5fMS5JRDN2MkhlYWRlcikpLmZpbGVJZGVudGlmaWVyID09PSAnSUQzJztcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlSUQzdjIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgY29yZV8xLkVuZE9mU3RyZWFtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgRW5kLW9mLXN0cmVhbWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlSUQzdjIoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudHJ5UmVhZElkM3YySGVhZGVycygpO1xuICAgICAgICBkZWJ1ZyhcIkVuZCBvZiBJRDN2MiBoZWFkZXIsIGdvIHRvIE1QRUctcGFyc2VyOiBwb3M9JXNcIiwgdGhpcy50b2tlbml6ZXIucG9zaXRpb24pO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYXJzZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBQb3N0SGVhZGVycyAmJiB0aGlzLm1ldGFkYXRhLmhhc0FueSgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZDN2MXBhcnNlciA9IG5ldyBJRDN2MVBhcnNlcl8xLklEM3YxUGFyc2VyKCk7XG4gICAgICAgICAgICBhd2FpdCBpZDN2MXBhcnNlci5pbml0KHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpLnBhcnNlKCk7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHJ5UmVhZElkM3YySGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaWQzSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla1Rva2VuKElEM3YyVG9rZW5fMS5JRDN2MkhlYWRlcik7XG4gICAgICAgIGlmIChpZDNIZWFkZXIuZmlsZUlkZW50aWZpZXIgPT09IFwiSUQzXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiRm91bmQgSUQzdjIgaGVhZGVyLCBwb3M9JXNcIiwgdGhpcy50b2tlbml6ZXIucG9zaXRpb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pZDNwYXJzZXIucGFyc2UodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cnlSZWFkSWQzdjJIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0SUQzUGFyc2VyID0gQWJzdHJhY3RJRDNQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdElEM1BhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/FrameParser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/FrameParser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FrameParser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nconst debug = initDebug('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'iso-8859-1';\nclass FrameParser {\n    /**\n     * Create id3v2 frame parser\n     * @param major - Major version, e.g. (4) for  id3v2.4\n     * @param warningCollector - Used to collect decode issue\n     */\n    constructor(major, warningCollector) {\n        this.major = major;\n        this.warningCollector = warningCollector;\n    }\n    readData(b, type, includeCovers) {\n        if (b.length === 0) {\n            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n            return;\n        }\n        const { encoding, bom } = ID3v2Token_1.TextEncodingToken.get(b, 0);\n        const length = b.length;\n        let offset = 0;\n        let output = []; // ToDo\n        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n        let fzero;\n        const out = {};\n        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n            case 'T*': // 4.2.1. Text information frames - details\n            case 'IPLS': // v2.3: Involved people list\n            case 'MVIN':\n            case 'MVNM':\n            case 'PCS':\n            case 'PCST':\n                const text = Util_1.default.decodeString(b.slice(1), encoding).replace(/\\x00+$/, '');\n                switch (type) {\n                    case 'TMCL': // Musician credits list\n                    case 'TIPL': // Involved people list\n                    case 'IPLS': // Involved people list\n                        output = this.splitValue(type, text);\n                        output = FrameParser.functionList(output);\n                        break;\n                    case 'TRK':\n                    case 'TRCK':\n                    case 'TPOS':\n                        output = text;\n                        break;\n                    case 'TCOM':\n                    case 'TCON':\n                    case 'TEXT':\n                    case 'TOLY':\n                    case 'TOPE':\n                    case 'TPE1':\n                    case 'TSRC':\n                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n                        output = this.splitValue(type, text);\n                        break;\n                    case 'PCS':\n                    case 'PCST':\n                        // TODO: Why `default` not results `1` but `''`?\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;\n                        break;\n                    default:\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                }\n                break;\n            case 'TXXX':\n                output = FrameParser.readIdentifierAndData(b, offset + 1, length, encoding);\n                output = {\n                    description: output.id,\n                    text: this.splitValue(type, Util_1.default.decodeString(output.data, encoding).replace(/\\x00+$/, ''))\n                };\n                break;\n            case 'PIC':\n            case 'APIC':\n                if (includeCovers) {\n                    const pic = {};\n                    offset += 1;\n                    switch (this.major) {\n                        case 2:\n                            pic.format = Util_1.default.decodeString(b.slice(offset, offset + 3), encoding);\n                            offset += 3;\n                            break;\n                        case 3:\n                        case 4:\n                            fzero = Util_1.default.findZero(b, offset, length, defaultEnc);\n                            pic.format = Util_1.default.decodeString(b.slice(offset, fzero), defaultEnc);\n                            offset = fzero + 1;\n                            break;\n                        default:\n                            throw new Error('Warning: unexpected major versionIndex: ' + this.major);\n                    }\n                    pic.format = FrameParser.fixPictureMimeType(pic.format);\n                    pic.type = ID3v2Token_1.AttachedPictureType[b[offset]];\n                    offset += 1;\n                    fzero = Util_1.default.findZero(b, offset, length, encoding);\n                    pic.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);\n                    offset = fzero + nullTerminatorLength;\n                    pic.data = Buffer.from(b.slice(offset, length));\n                    output = pic;\n                }\n                break;\n            case 'CNT':\n            case 'PCNT':\n                output = Token.UINT32_BE.get(b, 0);\n                break;\n            case 'SYLT':\n                // skip text encoding (1 byte),\n                //      language (3 bytes),\n                //      time stamp format (1 byte),\n                //      content tagTypes (1 byte),\n                //      content descriptor (1 byte)\n                offset += 7;\n                output = [];\n                while (offset < length) {\n                    const txt = b.slice(offset, offset = Util_1.default.findZero(b, offset, length, encoding));\n                    offset += 5; // push offset forward one +  4 byte timestamp\n                    output.push(Util_1.default.decodeString(txt, encoding));\n                }\n                break;\n            case 'ULT':\n            case 'USLT':\n            case 'COM':\n            case 'COMM':\n                offset += 1;\n                out.language = Util_1.default.decodeString(b.slice(offset, offset + 3), defaultEnc);\n                offset += 3;\n                fzero = Util_1.default.findZero(b, offset, length, encoding);\n                out.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);\n                offset = fzero + nullTerminatorLength;\n                out.text = Util_1.default.decodeString(b.slice(offset, length), encoding).replace(/\\x00+$/, '');\n                output = [out];\n                break;\n            case 'UFID':\n                output = FrameParser.readIdentifierAndData(b, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, identifier: output.data };\n                break;\n            case 'PRIV': // private frame\n                output = FrameParser.readIdentifierAndData(b, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, data: output.data };\n                break;\n            case 'POPM': // Popularimeter\n                fzero = Util_1.default.findZero(b, offset, length, defaultEnc);\n                const email = Util_1.default.decodeString(b.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                const dataLen = length - offset;\n                output = {\n                    email,\n                    rating: b.readUInt8(offset),\n                    counter: dataLen >= 5 ? b.readUInt32BE(offset + 1) : undefined\n                };\n                break;\n            case 'GEOB': { // General encapsulated object\n                fzero = Util_1.default.findZero(b, offset + 1, length, encoding);\n                const mimeType = Util_1.default.decodeString(b.slice(offset + 1, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = Util_1.default.findZero(b, offset, length - offset, encoding);\n                const filename = Util_1.default.decodeString(b.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = Util_1.default.findZero(b, offset, length - offset, encoding);\n                const description = Util_1.default.decodeString(b.slice(offset, fzero), defaultEnc);\n                output = {\n                    type: mimeType,\n                    filename,\n                    description,\n                    data: b.slice(offset + 1, length)\n                };\n                break;\n            }\n            // W-Frames:\n            case 'WCOM':\n            case 'WCOP':\n            case 'WOAF':\n            case 'WOAR':\n            case 'WOAS':\n            case 'WORS':\n            case 'WPAY':\n            case 'WPUB':\n                // Decode URL\n                output = Util_1.default.decodeString(b.slice(offset, fzero), defaultEnc);\n                break;\n            case 'WXXX': {\n                // Decode URL\n                fzero = Util_1.default.findZero(b, offset + 1, length, encoding);\n                const description = Util_1.default.decodeString(b.slice(offset + 1, fzero), encoding);\n                offset = fzero + (encoding === 'utf16' ? 2 : 1);\n                output = { description, url: Util_1.default.decodeString(b.slice(offset, length), defaultEnc) };\n                break;\n            }\n            case 'WFD':\n            case 'WFED':\n                output = Util_1.default.decodeString(b.slice(offset + 1, Util_1.default.findZero(b, offset + 1, length, encoding)), encoding);\n                break;\n            case 'MCDI': {\n                // Music CD identifier\n                output = b.slice(0, length);\n                break;\n            }\n            default:\n                debug('Warning: unsupported id3v2-tag-type: ' + type);\n                break;\n        }\n        return output;\n    }\n    static fixPictureMimeType(pictureType) {\n        pictureType = pictureType.toLocaleLowerCase();\n        switch (pictureType) {\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n        }\n        return pictureType;\n    }\n    /**\n     * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n     * @param entries\n     */\n    static functionList(entries) {\n        const res = {};\n        for (let i = 0; i + 1 < entries.length; i += 2) {\n            const names = entries[i + 1].split(',');\n            res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;\n        }\n        return res;\n    }\n    /**\n     * id3v2.4 defines that multiple T* values are separated by 0x00\n     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n     * @param tag - Tag name\n     * @param text - Concatenated tag value\n     * @returns Split tag value\n     */\n    splitValue(tag, text) {\n        let values;\n        if (this.major < 4) {\n            values = text.split(/\\x00/g);\n            if (values.length > 1) {\n                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n            }\n            else {\n                values = text.split(/\\//g);\n            }\n        }\n        else {\n            values = text.split(/\\x00/g);\n        }\n        return FrameParser.trimArray(values);\n    }\n    static trimArray(values) {\n        return values.map(value => value.replace(/\\x00+$/, '').trim());\n    }\n    static readIdentifierAndData(b, offset, length, encoding) {\n        const fzero = Util_1.default.findZero(b, offset, length, encoding);\n        const id = Util_1.default.decodeString(b.slice(offset, fzero), encoding);\n        offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n        return { id, data: b.slice(offset, length) };\n    }\n    static getNullTerminatorLength(enc) {\n        return enc === 'utf16' ? 2 : 1;\n    }\n}\nexports.FrameParser = FrameParser;\n//# sourceMappingURL=FrameParser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0ZyYW1lUGFyc2VyLmpzPzQxZGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDJFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVyw2QkFBNkIsS0FBSztBQUNuRztBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxhQUFhLFNBQVMsUUFBUSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVcsR0FBRyxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0ZyYW1lUGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyYW1lUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBJRDN2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9JRDN2MlRva2VuXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOmlkM3YyOmZyYW1lLXBhcnNlcicpO1xuY29uc3QgZGVmYXVsdEVuYyA9ICdpc28tODg1OS0xJztcbmNsYXNzIEZyYW1lUGFyc2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaWQzdjIgZnJhbWUgcGFyc2VyXG4gICAgICogQHBhcmFtIG1ham9yIC0gTWFqb3IgdmVyc2lvbiwgZS5nLiAoNCkgZm9yICBpZDN2Mi40XG4gICAgICogQHBhcmFtIHdhcm5pbmdDb2xsZWN0b3IgLSBVc2VkIHRvIGNvbGxlY3QgZGVjb2RlIGlzc3VlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFqb3IsIHdhcm5pbmdDb2xsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5tYWpvciA9IG1ham9yO1xuICAgICAgICB0aGlzLndhcm5pbmdDb2xsZWN0b3IgPSB3YXJuaW5nQ29sbGVjdG9yO1xuICAgIH1cbiAgICByZWFkRGF0YShiLCB0eXBlLCBpbmNsdWRlQ292ZXJzKSB7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy53YXJuaW5nQ29sbGVjdG9yLmFkZFdhcm5pbmcoYGlkM3YyLiR7dGhpcy5tYWpvcn0gaGVhZGVyIGhhcyBlbXB0eSB0YWcgdHlwZT0ke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlbmNvZGluZywgYm9tIH0gPSBJRDN2MlRva2VuXzEuVGV4dEVuY29kaW5nVG9rZW4uZ2V0KGIsIDApO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBiLmxlbmd0aDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBvdXRwdXQgPSBbXTsgLy8gVG9Eb1xuICAgICAgICBjb25zdCBudWxsVGVybWluYXRvckxlbmd0aCA9IEZyYW1lUGFyc2VyLmdldE51bGxUZXJtaW5hdG9yTGVuZ3RoKGVuY29kaW5nKTtcbiAgICAgICAgbGV0IGZ6ZXJvO1xuICAgICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgICAgZGVidWcoYFBhcnNpbmcgdGFnIHR5cGU9JHt0eXBlfSwgZW5jb2Rpbmc9JHtlbmNvZGluZ30sIGJvbT0ke2JvbX1gKTtcbiAgICAgICAgc3dpdGNoICh0eXBlICE9PSAnVFhYWCcgJiYgdHlwZVswXSA9PT0gJ1QnID8gJ1QqJyA6IHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1QqJzogLy8gNC4yLjEuIFRleHQgaW5mb3JtYXRpb24gZnJhbWVzIC0gZGV0YWlsc1xuICAgICAgICAgICAgY2FzZSAnSVBMUyc6IC8vIHYyLjM6IEludm9sdmVkIHBlb3BsZSBsaXN0XG4gICAgICAgICAgICBjYXNlICdNVklOJzpcbiAgICAgICAgICAgIGNhc2UgJ01WTk0nOlxuICAgICAgICAgICAgY2FzZSAnUENTJzpcbiAgICAgICAgICAgIGNhc2UgJ1BDU1QnOlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZSgxKSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RNQ0wnOiAvLyBNdXNpY2lhbiBjcmVkaXRzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVElQTCc6IC8vIEludm9sdmVkIHBlb3BsZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0lQTFMnOiAvLyBJbnZvbHZlZCBwZW9wbGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5zcGxpdFZhbHVlKHR5cGUsIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gRnJhbWVQYXJzZXIuZnVuY3Rpb25MaXN0KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFJLJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFJDSyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RQT1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUQ09NJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVENPTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RFWFQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUT0xZJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVE9QRSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RQRTEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUU1JDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkM3YyLjMgZGVmaW5lcyB0aGF0IFRDT00sIFRFWFQsIFRPTFksIFRPUEUgJiBUUEUxIHZhbHVlcyBhcmUgc2VwYXJhdGVkIGJ5IC9cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuc3BsaXRWYWx1ZSh0eXBlLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdQQ1MnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQQ1NUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFdoeSBgZGVmYXVsdGAgbm90IHJlc3VsdHMgYDFgIGJ1dCBgJydgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5tYWpvciA+PSA0ID8gdGhpcy5zcGxpdFZhbHVlKHR5cGUsIHRleHQpIDogW3RleHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gKEFycmF5LmlzQXJyYXkob3V0cHV0KSAmJiBvdXRwdXRbMF0gPT09ICcnKSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLm1ham9yID49IDQgPyB0aGlzLnNwbGl0VmFsdWUodHlwZSwgdGV4dCkgOiBbdGV4dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVFhYWCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gRnJhbWVQYXJzZXIucmVhZElkZW50aWZpZXJBbmREYXRhKGIsIG9mZnNldCArIDEsIGxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG91dHB1dC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zcGxpdFZhbHVlKHR5cGUsIFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhvdXRwdXQuZGF0YSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJykpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BJQyc6XG4gICAgICAgICAgICBjYXNlICdBUElDJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNvdmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tYWpvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpYy5mb3JtYXQgPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZShvZmZzZXQsIG9mZnNldCArIDMpLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnplcm8gPSBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhiLCBvZmZzZXQsIGxlbmd0aCwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljLmZvcm1hdCA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBmemVybyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FybmluZzogdW5leHBlY3RlZCBtYWpvciB2ZXJzaW9uSW5kZXg6ICcgKyB0aGlzLm1ham9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwaWMuZm9ybWF0ID0gRnJhbWVQYXJzZXIuZml4UGljdHVyZU1pbWVUeXBlKHBpYy5mb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBwaWMudHlwZSA9IElEM3YyVG9rZW5fMS5BdHRhY2hlZFBpY3R1cmVUeXBlW2Jbb2Zmc2V0XV07XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBmemVybyA9IFV0aWxfMS5kZWZhdWx0LmZpbmRaZXJvKGIsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHBpYy5kZXNjcmlwdGlvbiA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgbnVsbFRlcm1pbmF0b3JMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBpYy5kYXRhID0gQnVmZmVyLmZyb20oYi5zbGljZShvZmZzZXQsIGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBwaWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ05UJzpcbiAgICAgICAgICAgIGNhc2UgJ1BDTlQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYiwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTWUxUJzpcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRleHQgZW5jb2RpbmcgKDEgYnl0ZSksXG4gICAgICAgICAgICAgICAgLy8gICAgICBsYW5ndWFnZSAoMyBieXRlcyksXG4gICAgICAgICAgICAgICAgLy8gICAgICB0aW1lIHN0YW1wIGZvcm1hdCAoMSBieXRlKSxcbiAgICAgICAgICAgICAgICAvLyAgICAgIGNvbnRlbnQgdGFnVHlwZXMgKDEgYnl0ZSksXG4gICAgICAgICAgICAgICAgLy8gICAgICBjb250ZW50IGRlc2NyaXB0b3IgKDEgYnl0ZSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4dCA9IGIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgPSBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhiLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDU7IC8vIHB1c2ggb2Zmc2V0IGZvcndhcmQgb25lICsgIDQgYnl0ZSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goVXRpbF8xLmRlZmF1bHQuZGVjb2RlU3RyaW5nKHR4dCwgZW5jb2RpbmcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdVTFQnOlxuICAgICAgICAgICAgY2FzZSAnVVNMVCc6XG4gICAgICAgICAgICBjYXNlICdDT00nOlxuICAgICAgICAgICAgY2FzZSAnQ09NTSc6XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgb3V0Lmxhbmd1YWdlID0gVXRpbF8xLmRlZmF1bHQuZGVjb2RlU3RyaW5nKGIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgZnplcm8gPSBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhiLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIG91dC5kZXNjcmlwdGlvbiA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyBudWxsVGVybWluYXRvckxlbmd0aDtcbiAgICAgICAgICAgICAgICBvdXQudGV4dCA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgbGVuZ3RoKSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW291dF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdVRklEJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBGcmFtZVBhcnNlci5yZWFkSWRlbnRpZmllckFuZERhdGEoYiwgb2Zmc2V0LCBsZW5ndGgsIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgb3duZXJfaWRlbnRpZmllcjogb3V0cHV0LmlkLCBpZGVudGlmaWVyOiBvdXRwdXQuZGF0YSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUFJJVic6IC8vIHByaXZhdGUgZnJhbWVcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBGcmFtZVBhcnNlci5yZWFkSWRlbnRpZmllckFuZERhdGEoYiwgb2Zmc2V0LCBsZW5ndGgsIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgb3duZXJfaWRlbnRpZmllcjogb3V0cHV0LmlkLCBkYXRhOiBvdXRwdXQuZGF0YSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUE9QTSc6IC8vIFBvcHVsYXJpbWV0ZXJcbiAgICAgICAgICAgICAgICBmemVybyA9IFV0aWxfMS5kZWZhdWx0LmZpbmRaZXJvKGIsIG9mZnNldCwgbGVuZ3RoLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBmemVybyArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICByYXRpbmc6IGIucmVhZFVJbnQ4KG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXI6IGRhdGFMZW4gPj0gNSA/IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDEpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dFT0InOiB7IC8vIEdlbmVyYWwgZW5jYXBzdWxhdGVkIG9iamVjdFxuICAgICAgICAgICAgICAgIGZ6ZXJvID0gVXRpbF8xLmRlZmF1bHQuZmluZFplcm8oYiwgb2Zmc2V0ICsgMSwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZShvZmZzZXQgKyAxLCBmemVybyksIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgMTtcbiAgICAgICAgICAgICAgICBmemVybyA9IFV0aWxfMS5kZWZhdWx0LmZpbmRaZXJvKGIsIG9mZnNldCwgbGVuZ3RoIC0gb2Zmc2V0LCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyAxO1xuICAgICAgICAgICAgICAgIGZ6ZXJvID0gVXRpbF8xLmRlZmF1bHQuZmluZFplcm8oYiwgb2Zmc2V0LCBsZW5ndGggLSBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGIuc2xpY2Uob2Zmc2V0ICsgMSwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXLUZyYW1lczpcbiAgICAgICAgICAgIGNhc2UgJ1dDT00nOlxuICAgICAgICAgICAgY2FzZSAnV0NPUCc6XG4gICAgICAgICAgICBjYXNlICdXT0FGJzpcbiAgICAgICAgICAgIGNhc2UgJ1dPQVInOlxuICAgICAgICAgICAgY2FzZSAnV09BUyc6XG4gICAgICAgICAgICBjYXNlICdXT1JTJzpcbiAgICAgICAgICAgIGNhc2UgJ1dQQVknOlxuICAgICAgICAgICAgY2FzZSAnV1BVQic6XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIFVSTFxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1dYWFgnOiB7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIFVSTFxuICAgICAgICAgICAgICAgIGZ6ZXJvID0gVXRpbF8xLmRlZmF1bHQuZmluZFplcm8oYiwgb2Zmc2V0ICsgMSwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZShvZmZzZXQgKyAxLCBmemVybyksIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBmemVybyArIChlbmNvZGluZyA9PT0gJ3V0ZjE2JyA/IDIgOiAxKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IGRlc2NyaXB0aW9uLCB1cmw6IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgbGVuZ3RoKSwgZGVmYXVsdEVuYykgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1dGRCc6XG4gICAgICAgICAgICBjYXNlICdXRkVEJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBVdGlsXzEuZGVmYXVsdC5kZWNvZGVTdHJpbmcoYi5zbGljZShvZmZzZXQgKyAxLCBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhiLCBvZmZzZXQgKyAxLCBsZW5ndGgsIGVuY29kaW5nKSksIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01DREknOiB7XG4gICAgICAgICAgICAgICAgLy8gTXVzaWMgQ0QgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVidWcoJ1dhcm5pbmc6IHVuc3VwcG9ydGVkIGlkM3YyLXRhZy10eXBlOiAnICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgc3RhdGljIGZpeFBpY3R1cmVNaW1lVHlwZShwaWN0dXJlVHlwZSkge1xuICAgICAgICBwaWN0dXJlVHlwZSA9IHBpY3R1cmVUeXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAocGljdHVyZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZS9qcGVnJztcbiAgICAgICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZS9wbmcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWN0dXJlVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgVE1DTCAoTXVzaWNpYW4gY3JlZGl0cyBsaXN0KSBvciBUSVBMIChJbnZvbHZlZCBwZW9wbGUgbGlzdClcbiAgICAgKiBAcGFyYW0gZW50cmllc1xuICAgICAqL1xuICAgIHN0YXRpYyBmdW5jdGlvbkxpc3QoZW50cmllcykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyAxIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBlbnRyaWVzW2kgKyAxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgcmVzW2VudHJpZXNbaV1dID0gcmVzLmhhc093blByb3BlcnR5KGVudHJpZXNbaV0pID8gcmVzW2VudHJpZXNbaV1dLmNvbmNhdChuYW1lcykgOiBuYW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpZDN2Mi40IGRlZmluZXMgdGhhdCBtdWx0aXBsZSBUKiB2YWx1ZXMgYXJlIHNlcGFyYXRlZCBieSAweDAwXG4gICAgICogaWQzdjIuMyBkZWZpbmVzIHRoYXQgVENPTSwgVEVYVCwgVE9MWSwgVE9QRSAmIFRQRTEgdmFsdWVzIGFyZSBzZXBhcmF0ZWQgYnkgL1xuICAgICAqIEBwYXJhbSB0YWcgLSBUYWcgbmFtZVxuICAgICAqIEBwYXJhbSB0ZXh0IC0gQ29uY2F0ZW5hdGVkIHRhZyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFNwbGl0IHRhZyB2YWx1ZVxuICAgICAqL1xuICAgIHNwbGl0VmFsdWUodGFnLCB0ZXh0KSB7XG4gICAgICAgIGxldCB2YWx1ZXM7XG4gICAgICAgIGlmICh0aGlzLm1ham9yIDwgNCkge1xuICAgICAgICAgICAgdmFsdWVzID0gdGV4dC5zcGxpdCgvXFx4MDAvZyk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdDb2xsZWN0b3IuYWRkV2FybmluZyhgSUQzdjIuJHt0aGlzLm1ham9yfSAke3RhZ30gdXNlcyBub24gc3RhbmRhcmQgbnVsbC1zZXBhcmF0b3IuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0ZXh0LnNwbGl0KC9cXC8vZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0ZXh0LnNwbGl0KC9cXHgwMC9nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnJhbWVQYXJzZXIudHJpbUFycmF5KHZhbHVlcyk7XG4gICAgfVxuICAgIHN0YXRpYyB0cmltQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHZhbHVlLnJlcGxhY2UoL1xceDAwKyQvLCAnJykudHJpbSgpKTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWRJZGVudGlmaWVyQW5kRGF0YShiLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZnplcm8gPSBVdGlsXzEuZGVmYXVsdC5maW5kWmVybyhiLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICBjb25zdCBpZCA9IFV0aWxfMS5kZWZhdWx0LmRlY29kZVN0cmluZyhiLnNsaWNlKG9mZnNldCwgZnplcm8pLCBlbmNvZGluZyk7XG4gICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgRnJhbWVQYXJzZXIuZ2V0TnVsbFRlcm1pbmF0b3JMZW5ndGgoZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4geyBpZCwgZGF0YTogYi5zbGljZShvZmZzZXQsIGxlbmd0aCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldE51bGxUZXJtaW5hdG9yTGVuZ3RoKGVuYykge1xuICAgICAgICByZXR1cm4gZW5jID09PSAndXRmMTYnID8gMiA6IDE7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFtZVBhcnNlciA9IEZyYW1lUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/FrameParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ID3v22TagMapper = exports.id3v22TagMap = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * ID3v2.2 tag mappings\n */\nexports.id3v22TagMap = {\n    TT2: 'title',\n    TP1: 'artist',\n    TP2: 'albumartist',\n    TAL: 'album',\n    TYE: 'year',\n    COM: 'comment',\n    TRK: 'track',\n    TPA: 'disk',\n    TCO: 'genre',\n    PIC: 'picture',\n    TCM: 'composer',\n    TOR: 'originaldate',\n    TOT: 'originalalbum',\n    TXT: 'lyricist',\n    TP3: 'conductor',\n    TPB: 'label',\n    TT1: 'grouping',\n    TT3: 'subtitle',\n    TLA: 'language',\n    TCR: 'copyright',\n    WCP: 'license',\n    TEN: 'encodedby',\n    TSS: 'encodersettings',\n    WAR: 'website',\n    'COM:iTunPGAP': 'gapless'\n    /* ToDo: iTunes tags:\n    'COM:iTunNORM': ,\n    'COM:iTunSMPB': 'encoder delay',\n    'COM:iTunes_CDDB_IDs'\n    */ ,\n    PCS: 'podcast',\n    TCP: \"compilation\",\n    TDR: 'date',\n    TS2: 'albumartistsort',\n    TSA: 'albumsort',\n    TSC: 'composersort',\n    TSP: 'artistsort',\n    TST: 'titlesort',\n    WFD: 'podcasturl'\n};\nclass ID3v22TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['ID3v2.2'], exports.id3v22TagMap);\n    }\n}\nexports.ID3v22TagMapper = ID3v22TagMapper;\n//# sourceMappingURL=ID3v22TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0lEM3YyMlRhZ01hcHBlci5qcz9lMDM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQywwR0FBaUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2Mi9JRDN2MjJUYWdNYXBwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSUQzdjIyVGFnTWFwcGVyID0gZXhwb3J0cy5pZDN2MjJUYWdNYXAgPSB2b2lkIDA7XG5jb25zdCBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQ2FzZUluc2Vuc2l0aXZlVGFnTWFwXCIpO1xuLyoqXG4gKiBJRDN2Mi4yIHRhZyBtYXBwaW5nc1xuICovXG5leHBvcnRzLmlkM3YyMlRhZ01hcCA9IHtcbiAgICBUVDI6ICd0aXRsZScsXG4gICAgVFAxOiAnYXJ0aXN0JyxcbiAgICBUUDI6ICdhbGJ1bWFydGlzdCcsXG4gICAgVEFMOiAnYWxidW0nLFxuICAgIFRZRTogJ3llYXInLFxuICAgIENPTTogJ2NvbW1lbnQnLFxuICAgIFRSSzogJ3RyYWNrJyxcbiAgICBUUEE6ICdkaXNrJyxcbiAgICBUQ086ICdnZW5yZScsXG4gICAgUElDOiAncGljdHVyZScsXG4gICAgVENNOiAnY29tcG9zZXInLFxuICAgIFRPUjogJ29yaWdpbmFsZGF0ZScsXG4gICAgVE9UOiAnb3JpZ2luYWxhbGJ1bScsXG4gICAgVFhUOiAnbHlyaWNpc3QnLFxuICAgIFRQMzogJ2NvbmR1Y3RvcicsXG4gICAgVFBCOiAnbGFiZWwnLFxuICAgIFRUMTogJ2dyb3VwaW5nJyxcbiAgICBUVDM6ICdzdWJ0aXRsZScsXG4gICAgVExBOiAnbGFuZ3VhZ2UnLFxuICAgIFRDUjogJ2NvcHlyaWdodCcsXG4gICAgV0NQOiAnbGljZW5zZScsXG4gICAgVEVOOiAnZW5jb2RlZGJ5JyxcbiAgICBUU1M6ICdlbmNvZGVyc2V0dGluZ3MnLFxuICAgIFdBUjogJ3dlYnNpdGUnLFxuICAgICdDT006aVR1blBHQVAnOiAnZ2FwbGVzcydcbiAgICAvKiBUb0RvOiBpVHVuZXMgdGFnczpcbiAgICAnQ09NOmlUdW5OT1JNJzogLFxuICAgICdDT006aVR1blNNUEInOiAnZW5jb2RlciBkZWxheScsXG4gICAgJ0NPTTppVHVuZXNfQ0REQl9JRHMnXG4gICAgKi8gLFxuICAgIFBDUzogJ3BvZGNhc3QnLFxuICAgIFRDUDogXCJjb21waWxhdGlvblwiLFxuICAgIFREUjogJ2RhdGUnLFxuICAgIFRTMjogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgVFNBOiAnYWxidW1zb3J0JyxcbiAgICBUU0M6ICdjb21wb3NlcnNvcnQnLFxuICAgIFRTUDogJ2FydGlzdHNvcnQnLFxuICAgIFRTVDogJ3RpdGxlc29ydCcsXG4gICAgV0ZEOiAncG9kY2FzdHVybCdcbn07XG5jbGFzcyBJRDN2MjJUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0lEM3YyLjInXSwgZXhwb3J0cy5pZDN2MjJUYWdNYXApO1xuICAgIH1cbn1cbmV4cG9ydHMuSUQzdjIyVGFnTWFwcGVyID0gSUQzdjIyVGFnTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUQzdjIyVGFnTWFwcGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ID3v24TagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * ID3v2.3/ID3v2.4 tag mappings\n */\nconst id3v24TagMap = {\n    // id3v2.3\n    TIT2: \"title\",\n    TPE1: \"artist\",\n    \"TXXX:Artists\": \"artists\",\n    TPE2: \"albumartist\",\n    TALB: \"album\",\n    TDRV: \"date\",\n    /**\n     * Original release year\n     */\n    TORY: \"originalyear\",\n    TPOS: \"disk\",\n    TCON: \"genre\",\n    APIC: \"picture\",\n    TCOM: \"composer\",\n    \"USLT:description\": \"lyrics\",\n    TSOA: \"albumsort\",\n    TSOT: \"titlesort\",\n    TOAL: \"originalalbum\",\n    TSOP: \"artistsort\",\n    TSO2: \"albumartistsort\",\n    TSOC: \"composersort\",\n    TEXT: \"lyricist\",\n    \"TXXX:Writer\": \"writer\",\n    TPE3: \"conductor\",\n    // 'IPLS:instrument': 'performer:instrument', // ToDo\n    TPE4: \"remixer\",\n    \"IPLS:arranger\": \"arranger\",\n    \"IPLS:engineer\": \"engineer\",\n    \"IPLS:producer\": \"producer\",\n    \"IPLS:DJ-mix\": \"djmixer\",\n    \"IPLS:mix\": \"mixer\",\n    TPUB: \"label\",\n    TIT1: \"grouping\",\n    TIT3: \"subtitle\",\n    TRCK: \"track\",\n    TCMP: \"compilation\",\n    POPM: \"rating\",\n    TBPM: \"bpm\",\n    TMED: \"media\",\n    \"TXXX:CATALOGNUMBER\": \"catalognumber\",\n    \"TXXX:MusicBrainz Album Status\": \"releasestatus\",\n    \"TXXX:MusicBrainz Album Type\": \"releasetype\",\n    /**\n     * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0\n     */\n    \"TXXX:MusicBrainz Album Release Country\": \"releasecountry\",\n    /**\n     * Release country as implemented // ToDo: report\n     */\n    \"TXXX:RELEASECOUNTRY\": \"releasecountry\",\n    \"TXXX:SCRIPT\": \"script\",\n    TLAN: \"language\",\n    TCOP: \"copyright\",\n    WCOP: \"license\",\n    TENC: \"encodedby\",\n    TSSE: \"encodersettings\",\n    \"TXXX:BARCODE\": \"barcode\",\n    TSRC: \"isrc\",\n    \"TXXX:ASIN\": \"asin\",\n    \"TXXX:originalyear\": \"originalyear\",\n    \"UFID:http://musicbrainz.org\": \"musicbrainz_recordingid\",\n    \"TXXX:MusicBrainz Release Track Id\": \"musicbrainz_trackid\",\n    \"TXXX:MusicBrainz Album Id\": \"musicbrainz_albumid\",\n    \"TXXX:MusicBrainz Artist Id\": \"musicbrainz_artistid\",\n    \"TXXX:MusicBrainz Album Artist Id\": \"musicbrainz_albumartistid\",\n    \"TXXX:MusicBrainz Release Group Id\": \"musicbrainz_releasegroupid\",\n    \"TXXX:MusicBrainz Work Id\": \"musicbrainz_workid\",\n    \"TXXX:MusicBrainz TRM Id\": \"musicbrainz_trmid\",\n    \"TXXX:MusicBrainz Disc Id\": \"musicbrainz_discid\",\n    \"TXXX:ACOUSTID_ID\": \"acoustid_id\",\n    \"TXXX:Acoustid Id\": \"acoustid_id\",\n    \"TXXX:Acoustid Fingerprint\": \"acoustid_fingerprint\",\n    \"TXXX:MusicIP PUID\": \"musicip_puid\",\n    \"TXXX:MusicMagic Fingerprint\": \"musicip_fingerprint\",\n    WOAR: \"website\",\n    // id3v2.4\n    // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames\n    TDRC: \"date\",\n    TYER: \"year\",\n    TDOR: \"originaldate\",\n    // 'TMCL:instrument': 'performer:instrument',\n    \"TIPL:arranger\": \"arranger\",\n    \"TIPL:engineer\": \"engineer\",\n    \"TIPL:producer\": \"producer\",\n    \"TIPL:DJ-mix\": \"djmixer\",\n    \"TIPL:mix\": \"mixer\",\n    TMOO: \"mood\",\n    // additional mappings:\n    SYLT: \"lyrics\",\n    TSST: \"discsubtitle\",\n    TKEY: \"key\",\n    COMM: \"comment\",\n    TOPE: \"originalartist\",\n    // Windows Media Player\n    \"PRIV:AverageLevel\": \"averageLevel\",\n    \"PRIV:PeakLevel\": \"peakLevel\",\n    // Discogs\n    \"TXXX:DISCOGS_ARTIST_ID\": \"discogs_artist_id\",\n    \"TXXX:DISCOGS_ARTISTS\": \"artists\",\n    \"TXXX:DISCOGS_ARTIST_NAME\": \"artists\",\n    \"TXXX:DISCOGS_ALBUM_ARTISTS\": \"albumartist\",\n    \"TXXX:DISCOGS_CATALOG\": \"catalognumber\",\n    \"TXXX:DISCOGS_COUNTRY\": \"releasecountry\",\n    \"TXXX:DISCOGS_DATE\": \"originaldate\",\n    \"TXXX:DISCOGS_LABEL\": \"label\",\n    \"TXXX:DISCOGS_LABEL_ID\": \"discogs_label_id\",\n    \"TXXX:DISCOGS_MASTER_RELEASE_ID\": \"discogs_master_release_id\",\n    \"TXXX:DISCOGS_RATING\": \"discogs_rating\",\n    \"TXXX:DISCOGS_RELEASED\": \"date\",\n    \"TXXX:DISCOGS_RELEASE_ID\": \"discogs_release_id\",\n    \"TXXX:DISCOGS_VOTES\": \"discogs_votes\",\n    \"TXXX:CATALOGID\": \"catalognumber\",\n    \"TXXX:STYLE\": \"genre\",\n    \"TXXX:REPLAYGAIN_TRACK_PEAK\": \"replaygain_track_peak\",\n    \"TXXX:REPLAYGAIN_TRACK_GAIN\": \"replaygain_track_gain\",\n    \"TXXX:REPLAYGAIN_ALBUM_PEAK\": \"replaygain_album_peak\",\n    \"TXXX:REPLAYGAIN_ALBUM_GAIN\": \"replaygain_album_gain\",\n    \"TXXX:MP3GAIN_MINMAX\": \"replaygain_track_minmax\",\n    \"TXXX:MP3GAIN_ALBUM_MINMAX\": \"replaygain_album_minmax\",\n    \"TXXX:MP3GAIN_UNDO\": \"replaygain_undo\",\n    MVNM: \"movement\",\n    MVIN: \"movementIndex\",\n    PCST: \"podcast\",\n    TCAT: \"category\",\n    TDES: \"description\",\n    TDRL: \"date\",\n    TGID: \"podcastId\",\n    TKWD: \"keywords\",\n    WFED: \"podcasturl\"\n};\nclass ID3v24TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    static toRating(popm) {\n        return {\n            source: popm.email,\n            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : undefined\n        };\n    }\n    constructor() {\n        super(['ID3v2.3', 'ID3v2.4'], id3v24TagMap);\n    }\n    /**\n     * Handle post mapping exceptions / correction\n     * @param {string} tag to post map\n     * @param warnings USed to register warnings\n     * @return Common value e.g. \"Buena Vista Social Club\"\n     */\n    postMap(tag, warnings) {\n        switch (tag.id) {\n            case 'UFID': // decode MusicBrainz Recording Id\n                if (tag.value.owner_identifier === 'http://musicbrainz.org') {\n                    tag.id += ':' + tag.value.owner_identifier;\n                    tag.value = Util_1.default.decodeString(tag.value.identifier, 'iso-8859-1');\n                }\n                break;\n            case 'PRIV':\n                switch (tag.value.owner_identifier) {\n                    // decode Windows Media Player\n                    case 'AverageLevel':\n                    case 'PeakValue':\n                        tag.id += ':' + tag.value.owner_identifier;\n                        tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE(0) : null;\n                        if (tag.value === null) {\n                            warnings.addWarning(`Failed to parse PRIV:PeakValue`);\n                        }\n                        break;\n                    default:\n                        warnings.addWarning(`Unknown PRIV owner-identifier: ${tag.value.owner_identifier}`);\n                }\n                break;\n            case 'COMM':\n                tag.value = tag.value ? tag.value.text : null;\n                break;\n            case 'POPM':\n                tag.value = ID3v24TagMapper.toRating(tag.value);\n                break;\n            default:\n                break;\n        }\n    }\n}\nexports.ID3v24TagMapper = ID3v24TagMapper;\n//# sourceMappingURL=ID3v24TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0lEM3YyNFRhZ01hcHBlci5qcz9mYTZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxnR0FBNEI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHdFQUFnQjtBQUN2QyxnQ0FBZ0MsbUJBQU8sQ0FBQywwR0FBaUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsMkJBQTJCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjI0VGFnTWFwcGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklEM3YyNFRhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IEdlbmVyaWNUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vR2VuZXJpY1RhZ01hcHBlclwiKTtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIElEM3YyLjMvSUQzdjIuNCB0YWcgbWFwcGluZ3NcbiAqL1xuY29uc3QgaWQzdjI0VGFnTWFwID0ge1xuICAgIC8vIGlkM3YyLjNcbiAgICBUSVQyOiBcInRpdGxlXCIsXG4gICAgVFBFMTogXCJhcnRpc3RcIixcbiAgICBcIlRYWFg6QXJ0aXN0c1wiOiBcImFydGlzdHNcIixcbiAgICBUUEUyOiBcImFsYnVtYXJ0aXN0XCIsXG4gICAgVEFMQjogXCJhbGJ1bVwiLFxuICAgIFREUlY6IFwiZGF0ZVwiLFxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHJlbGVhc2UgeWVhclxuICAgICAqL1xuICAgIFRPUlk6IFwib3JpZ2luYWx5ZWFyXCIsXG4gICAgVFBPUzogXCJkaXNrXCIsXG4gICAgVENPTjogXCJnZW5yZVwiLFxuICAgIEFQSUM6IFwicGljdHVyZVwiLFxuICAgIFRDT006IFwiY29tcG9zZXJcIixcbiAgICBcIlVTTFQ6ZGVzY3JpcHRpb25cIjogXCJseXJpY3NcIixcbiAgICBUU09BOiBcImFsYnVtc29ydFwiLFxuICAgIFRTT1Q6IFwidGl0bGVzb3J0XCIsXG4gICAgVE9BTDogXCJvcmlnaW5hbGFsYnVtXCIsXG4gICAgVFNPUDogXCJhcnRpc3Rzb3J0XCIsXG4gICAgVFNPMjogXCJhbGJ1bWFydGlzdHNvcnRcIixcbiAgICBUU09DOiBcImNvbXBvc2Vyc29ydFwiLFxuICAgIFRFWFQ6IFwibHlyaWNpc3RcIixcbiAgICBcIlRYWFg6V3JpdGVyXCI6IFwid3JpdGVyXCIsXG4gICAgVFBFMzogXCJjb25kdWN0b3JcIixcbiAgICAvLyAnSVBMUzppbnN0cnVtZW50JzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JywgLy8gVG9Eb1xuICAgIFRQRTQ6IFwicmVtaXhlclwiLFxuICAgIFwiSVBMUzphcnJhbmdlclwiOiBcImFycmFuZ2VyXCIsXG4gICAgXCJJUExTOmVuZ2luZWVyXCI6IFwiZW5naW5lZXJcIixcbiAgICBcIklQTFM6cHJvZHVjZXJcIjogXCJwcm9kdWNlclwiLFxuICAgIFwiSVBMUzpESi1taXhcIjogXCJkam1peGVyXCIsXG4gICAgXCJJUExTOm1peFwiOiBcIm1peGVyXCIsXG4gICAgVFBVQjogXCJsYWJlbFwiLFxuICAgIFRJVDE6IFwiZ3JvdXBpbmdcIixcbiAgICBUSVQzOiBcInN1YnRpdGxlXCIsXG4gICAgVFJDSzogXCJ0cmFja1wiLFxuICAgIFRDTVA6IFwiY29tcGlsYXRpb25cIixcbiAgICBQT1BNOiBcInJhdGluZ1wiLFxuICAgIFRCUE06IFwiYnBtXCIsXG4gICAgVE1FRDogXCJtZWRpYVwiLFxuICAgIFwiVFhYWDpDQVRBTE9HTlVNQkVSXCI6IFwiY2F0YWxvZ251bWJlclwiLFxuICAgIFwiVFhYWDpNdXNpY0JyYWlueiBBbGJ1bSBTdGF0dXNcIjogXCJyZWxlYXNlc3RhdHVzXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IEFsYnVtIFR5cGVcIjogXCJyZWxlYXNldHlwZVwiLFxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgY291bnRyeSBhcyBkb2N1bWVudGVkOiBodHRwczovL3BpY2FyZC5tdXNpY2JyYWluei5vcmcvZG9jcy9tYXBwaW5ncy8jY2l0ZV9ub3RlLTBcbiAgICAgKi9cbiAgICBcIlRYWFg6TXVzaWNCcmFpbnogQWxidW0gUmVsZWFzZSBDb3VudHJ5XCI6IFwicmVsZWFzZWNvdW50cnlcIixcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGNvdW50cnkgYXMgaW1wbGVtZW50ZWQgLy8gVG9EbzogcmVwb3J0XG4gICAgICovXG4gICAgXCJUWFhYOlJFTEVBU0VDT1VOVFJZXCI6IFwicmVsZWFzZWNvdW50cnlcIixcbiAgICBcIlRYWFg6U0NSSVBUXCI6IFwic2NyaXB0XCIsXG4gICAgVExBTjogXCJsYW5ndWFnZVwiLFxuICAgIFRDT1A6IFwiY29weXJpZ2h0XCIsXG4gICAgV0NPUDogXCJsaWNlbnNlXCIsXG4gICAgVEVOQzogXCJlbmNvZGVkYnlcIixcbiAgICBUU1NFOiBcImVuY29kZXJzZXR0aW5nc1wiLFxuICAgIFwiVFhYWDpCQVJDT0RFXCI6IFwiYmFyY29kZVwiLFxuICAgIFRTUkM6IFwiaXNyY1wiLFxuICAgIFwiVFhYWDpBU0lOXCI6IFwiYXNpblwiLFxuICAgIFwiVFhYWDpvcmlnaW5hbHllYXJcIjogXCJvcmlnaW5hbHllYXJcIixcbiAgICBcIlVGSUQ6aHR0cDovL211c2ljYnJhaW56Lm9yZ1wiOiBcIm11c2ljYnJhaW56X3JlY29yZGluZ2lkXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IFJlbGVhc2UgVHJhY2sgSWRcIjogXCJtdXNpY2JyYWluel90cmFja2lkXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IEFsYnVtIElkXCI6IFwibXVzaWNicmFpbnpfYWxidW1pZFwiLFxuICAgIFwiVFhYWDpNdXNpY0JyYWlueiBBcnRpc3QgSWRcIjogXCJtdXNpY2JyYWluel9hcnRpc3RpZFwiLFxuICAgIFwiVFhYWDpNdXNpY0JyYWlueiBBbGJ1bSBBcnRpc3QgSWRcIjogXCJtdXNpY2JyYWluel9hbGJ1bWFydGlzdGlkXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IFJlbGVhc2UgR3JvdXAgSWRcIjogXCJtdXNpY2JyYWluel9yZWxlYXNlZ3JvdXBpZFwiLFxuICAgIFwiVFhYWDpNdXNpY0JyYWlueiBXb3JrIElkXCI6IFwibXVzaWNicmFpbnpfd29ya2lkXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IFRSTSBJZFwiOiBcIm11c2ljYnJhaW56X3RybWlkXCIsXG4gICAgXCJUWFhYOk11c2ljQnJhaW56IERpc2MgSWRcIjogXCJtdXNpY2JyYWluel9kaXNjaWRcIixcbiAgICBcIlRYWFg6QUNPVVNUSURfSURcIjogXCJhY291c3RpZF9pZFwiLFxuICAgIFwiVFhYWDpBY291c3RpZCBJZFwiOiBcImFjb3VzdGlkX2lkXCIsXG4gICAgXCJUWFhYOkFjb3VzdGlkIEZpbmdlcnByaW50XCI6IFwiYWNvdXN0aWRfZmluZ2VycHJpbnRcIixcbiAgICBcIlRYWFg6TXVzaWNJUCBQVUlEXCI6IFwibXVzaWNpcF9wdWlkXCIsXG4gICAgXCJUWFhYOk11c2ljTWFnaWMgRmluZ2VycHJpbnRcIjogXCJtdXNpY2lwX2ZpbmdlcnByaW50XCIsXG4gICAgV09BUjogXCJ3ZWJzaXRlXCIsXG4gICAgLy8gaWQzdjIuNFxuICAgIC8vIFRvRG86IEluIHNhbWUgc2VxdWVuY2UgYXMgZGVmaW5lZCBhdCBodHRwOi8vaWQzLm9yZy9pZDN2Mi40LjAtZnJhbWVzXG4gICAgVERSQzogXCJkYXRlXCIsXG4gICAgVFlFUjogXCJ5ZWFyXCIsXG4gICAgVERPUjogXCJvcmlnaW5hbGRhdGVcIixcbiAgICAvLyAnVE1DTDppbnN0cnVtZW50JzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JyxcbiAgICBcIlRJUEw6YXJyYW5nZXJcIjogXCJhcnJhbmdlclwiLFxuICAgIFwiVElQTDplbmdpbmVlclwiOiBcImVuZ2luZWVyXCIsXG4gICAgXCJUSVBMOnByb2R1Y2VyXCI6IFwicHJvZHVjZXJcIixcbiAgICBcIlRJUEw6REotbWl4XCI6IFwiZGptaXhlclwiLFxuICAgIFwiVElQTDptaXhcIjogXCJtaXhlclwiLFxuICAgIFRNT086IFwibW9vZFwiLFxuICAgIC8vIGFkZGl0aW9uYWwgbWFwcGluZ3M6XG4gICAgU1lMVDogXCJseXJpY3NcIixcbiAgICBUU1NUOiBcImRpc2NzdWJ0aXRsZVwiLFxuICAgIFRLRVk6IFwia2V5XCIsXG4gICAgQ09NTTogXCJjb21tZW50XCIsXG4gICAgVE9QRTogXCJvcmlnaW5hbGFydGlzdFwiLFxuICAgIC8vIFdpbmRvd3MgTWVkaWEgUGxheWVyXG4gICAgXCJQUklWOkF2ZXJhZ2VMZXZlbFwiOiBcImF2ZXJhZ2VMZXZlbFwiLFxuICAgIFwiUFJJVjpQZWFrTGV2ZWxcIjogXCJwZWFrTGV2ZWxcIixcbiAgICAvLyBEaXNjb2dzXG4gICAgXCJUWFhYOkRJU0NPR1NfQVJUSVNUX0lEXCI6IFwiZGlzY29nc19hcnRpc3RfaWRcIixcbiAgICBcIlRYWFg6RElTQ09HU19BUlRJU1RTXCI6IFwiYXJ0aXN0c1wiLFxuICAgIFwiVFhYWDpESVNDT0dTX0FSVElTVF9OQU1FXCI6IFwiYXJ0aXN0c1wiLFxuICAgIFwiVFhYWDpESVNDT0dTX0FMQlVNX0FSVElTVFNcIjogXCJhbGJ1bWFydGlzdFwiLFxuICAgIFwiVFhYWDpESVNDT0dTX0NBVEFMT0dcIjogXCJjYXRhbG9nbnVtYmVyXCIsXG4gICAgXCJUWFhYOkRJU0NPR1NfQ09VTlRSWVwiOiBcInJlbGVhc2Vjb3VudHJ5XCIsXG4gICAgXCJUWFhYOkRJU0NPR1NfREFURVwiOiBcIm9yaWdpbmFsZGF0ZVwiLFxuICAgIFwiVFhYWDpESVNDT0dTX0xBQkVMXCI6IFwibGFiZWxcIixcbiAgICBcIlRYWFg6RElTQ09HU19MQUJFTF9JRFwiOiBcImRpc2NvZ3NfbGFiZWxfaWRcIixcbiAgICBcIlRYWFg6RElTQ09HU19NQVNURVJfUkVMRUFTRV9JRFwiOiBcImRpc2NvZ3NfbWFzdGVyX3JlbGVhc2VfaWRcIixcbiAgICBcIlRYWFg6RElTQ09HU19SQVRJTkdcIjogXCJkaXNjb2dzX3JhdGluZ1wiLFxuICAgIFwiVFhYWDpESVNDT0dTX1JFTEVBU0VEXCI6IFwiZGF0ZVwiLFxuICAgIFwiVFhYWDpESVNDT0dTX1JFTEVBU0VfSURcIjogXCJkaXNjb2dzX3JlbGVhc2VfaWRcIixcbiAgICBcIlRYWFg6RElTQ09HU19WT1RFU1wiOiBcImRpc2NvZ3Nfdm90ZXNcIixcbiAgICBcIlRYWFg6Q0FUQUxPR0lEXCI6IFwiY2F0YWxvZ251bWJlclwiLFxuICAgIFwiVFhYWDpTVFlMRVwiOiBcImdlbnJlXCIsXG4gICAgXCJUWFhYOlJFUExBWUdBSU5fVFJBQ0tfUEVBS1wiOiBcInJlcGxheWdhaW5fdHJhY2tfcGVha1wiLFxuICAgIFwiVFhYWDpSRVBMQVlHQUlOX1RSQUNLX0dBSU5cIjogXCJyZXBsYXlnYWluX3RyYWNrX2dhaW5cIixcbiAgICBcIlRYWFg6UkVQTEFZR0FJTl9BTEJVTV9QRUFLXCI6IFwicmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrXCIsXG4gICAgXCJUWFhYOlJFUExBWUdBSU5fQUxCVU1fR0FJTlwiOiBcInJlcGxheWdhaW5fYWxidW1fZ2FpblwiLFxuICAgIFwiVFhYWDpNUDNHQUlOX01JTk1BWFwiOiBcInJlcGxheWdhaW5fdHJhY2tfbWlubWF4XCIsXG4gICAgXCJUWFhYOk1QM0dBSU5fQUxCVU1fTUlOTUFYXCI6IFwicmVwbGF5Z2Fpbl9hbGJ1bV9taW5tYXhcIixcbiAgICBcIlRYWFg6TVAzR0FJTl9VTkRPXCI6IFwicmVwbGF5Z2Fpbl91bmRvXCIsXG4gICAgTVZOTTogXCJtb3ZlbWVudFwiLFxuICAgIE1WSU46IFwibW92ZW1lbnRJbmRleFwiLFxuICAgIFBDU1Q6IFwicG9kY2FzdFwiLFxuICAgIFRDQVQ6IFwiY2F0ZWdvcnlcIixcbiAgICBUREVTOiBcImRlc2NyaXB0aW9uXCIsXG4gICAgVERSTDogXCJkYXRlXCIsXG4gICAgVEdJRDogXCJwb2RjYXN0SWRcIixcbiAgICBUS1dEOiBcImtleXdvcmRzXCIsXG4gICAgV0ZFRDogXCJwb2RjYXN0dXJsXCJcbn07XG5jbGFzcyBJRDN2MjRUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIHN0YXRpYyB0b1JhdGluZyhwb3BtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHBvcG0uZW1haWwsXG4gICAgICAgICAgICByYXRpbmc6IHBvcG0ucmF0aW5nID4gMCA/IChwb3BtLnJhdGluZyAtIDEpIC8gMjU0ICogR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlci5tYXhSYXRpbmdTY29yZSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoWydJRDN2Mi4zJywgJ0lEM3YyLjQnXSwgaWQzdjI0VGFnTWFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBvc3QgbWFwcGluZyBleGNlcHRpb25zIC8gY29ycmVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgdG8gcG9zdCBtYXBcbiAgICAgKiBAcGFyYW0gd2FybmluZ3MgVVNlZCB0byByZWdpc3RlciB3YXJuaW5nc1xuICAgICAqIEByZXR1cm4gQ29tbW9uIHZhbHVlIGUuZy4gXCJCdWVuYSBWaXN0YSBTb2NpYWwgQ2x1YlwiXG4gICAgICovXG4gICAgcG9zdE1hcCh0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIHN3aXRjaCAodGFnLmlkKSB7XG4gICAgICAgICAgICBjYXNlICdVRklEJzogLy8gZGVjb2RlIE11c2ljQnJhaW56IFJlY29yZGluZyBJZFxuICAgICAgICAgICAgICAgIGlmICh0YWcudmFsdWUub3duZXJfaWRlbnRpZmllciA9PT0gJ2h0dHA6Ly9tdXNpY2JyYWluei5vcmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZy5pZCArPSAnOicgKyB0YWcudmFsdWUub3duZXJfaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgdGFnLnZhbHVlID0gVXRpbF8xLmRlZmF1bHQuZGVjb2RlU3RyaW5nKHRhZy52YWx1ZS5pZGVudGlmaWVyLCAnaXNvLTg4NTktMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BSSVYnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnLnZhbHVlLm93bmVyX2lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjb2RlIFdpbmRvd3MgTWVkaWEgUGxheWVyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0F2ZXJhZ2VMZXZlbCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BlYWtWYWx1ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcuaWQgKz0gJzonICsgdGFnLnZhbHVlLm93bmVyX2lkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSB0YWcudmFsdWUuZGF0YS5sZW5ndGggPT09IDQgPyB0YWcudmFsdWUuZGF0YS5yZWFkVUludDMyTEUoMCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLmFkZFdhcm5pbmcoYEZhaWxlZCB0byBwYXJzZSBQUklWOlBlYWtWYWx1ZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5hZGRXYXJuaW5nKGBVbmtub3duIFBSSVYgb3duZXItaWRlbnRpZmllcjogJHt0YWcudmFsdWUub3duZXJfaWRlbnRpZmllcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDT01NJzpcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSB0YWcudmFsdWUgPyB0YWcudmFsdWUudGV4dCA6IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQT1BNJzpcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBJRDN2MjRUYWdNYXBwZXIudG9SYXRpbmcodGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLklEM3YyNFRhZ01hcHBlciA9IElEM3YyNFRhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlEM3YyNFRhZ01hcHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ID3v2Parser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst FrameParser_1 = __webpack_require__(/*! ./FrameParser */ \"./node_modules/music-metadata/lib/id3v2/FrameParser.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nclass ID3v2Parser {\n    static removeUnsyncBytes(buffer) {\n        let readI = 0;\n        let writeI = 0;\n        while (readI < buffer.length - 1) {\n            if (readI !== writeI) {\n                buffer[writeI] = buffer[readI];\n            }\n            readI += (buffer[readI] === 0xFF && buffer[readI + 1] === 0) ? 2 : 1;\n            writeI++;\n        }\n        if (readI < buffer.length) {\n            buffer[writeI++] = buffer[readI];\n        }\n        return buffer.slice(0, writeI);\n    }\n    static readFrameHeader(v, majorVer) {\n        let header;\n        switch (majorVer) {\n            case 2:\n                header = {\n                    id: v.toString('ascii', 0, 3),\n                    length: Token.UINT24_BE.get(v, 3)\n                };\n                break;\n            case 3:\n                header = {\n                    id: v.toString('ascii', 0, 4),\n                    length: Token.UINT32_BE.get(v, 4),\n                    flags: ID3v2Parser.readFrameFlags(v.slice(8, 10))\n                };\n                break;\n            case 4:\n                header = {\n                    id: v.toString('ascii', 0, 4),\n                    length: ID3v2Token_1.UINT32SYNCSAFE.get(v, 4),\n                    flags: ID3v2Parser.readFrameFlags(v.slice(8, 10))\n                };\n                break;\n            default:\n                throw new Error('Unexpected majorVer: ' + majorVer);\n        }\n        return header;\n    }\n    static getFrameHeaderLength(majorVer) {\n        switch (majorVer) {\n            case 2:\n                return 6;\n            case 3:\n            case 4:\n                return 10;\n            default:\n                throw new Error('header versionIndex is incorrect');\n        }\n    }\n    static readFrameFlags(b) {\n        return {\n            status: {\n                tag_alter_preservation: Util_1.default.strtokBITSET.get(b, 0, 6),\n                file_alter_preservation: Util_1.default.strtokBITSET.get(b, 0, 5),\n                read_only: Util_1.default.strtokBITSET.get(b, 0, 4)\n            },\n            format: {\n                grouping_identity: Util_1.default.strtokBITSET.get(b, 1, 7),\n                compression: Util_1.default.strtokBITSET.get(b, 1, 3),\n                encryption: Util_1.default.strtokBITSET.get(b, 1, 2),\n                unsynchronisation: Util_1.default.strtokBITSET.get(b, 1, 1),\n                data_length_indicator: Util_1.default.strtokBITSET.get(b, 1, 0)\n            }\n        };\n    }\n    static readFrameData(buf, frameHeader, majorVer, includeCovers, warningCollector) {\n        const frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);\n        switch (majorVer) {\n            case 2:\n                return frameParser.readData(buf, frameHeader.id, includeCovers);\n            case 3:\n            case 4:\n                if (frameHeader.flags.format.unsynchronisation) {\n                    buf = ID3v2Parser.removeUnsyncBytes(buf);\n                }\n                if (frameHeader.flags.format.data_length_indicator) {\n                    buf = buf.slice(4, buf.length);\n                }\n                return frameParser.readData(buf, frameHeader.id, includeCovers);\n            default:\n                throw new Error('Unexpected majorVer: ' + majorVer);\n        }\n    }\n    /**\n     * Create a combined tag key, of tag & description\n     * @param {string} tag e.g.: COM\n     * @param {string} description e.g. iTunPGAP\n     * @returns {string} e.g. COM:iTunPGAP\n     */\n    static makeDescriptionTagName(tag, description) {\n        return tag + (description ? ':' + description : '');\n    }\n    async parse(metadata, tokenizer, options) {\n        this.tokenizer = tokenizer;\n        this.metadata = metadata;\n        this.options = options;\n        const id3Header = await this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);\n        if (id3Header.fileIdentifier !== 'ID3') {\n            throw new Error('expected ID3-header file-identifier \\'ID3\\' was not found');\n        }\n        this.id3Header = id3Header;\n        this.headerType = ('ID3v2.' + id3Header.version.major);\n        if (id3Header.flags.isExtendedHeader) {\n            return this.parseExtendedHeader();\n        }\n        else {\n            return this.parseId3Data(id3Header.size);\n        }\n    }\n    async parseExtendedHeader() {\n        const extendedHeader = await this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader);\n        const dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;\n        if (dataRemaining > 0) {\n            return this.parseExtendedHeaderData(dataRemaining, extendedHeader.size);\n        }\n        else {\n            return this.parseId3Data(this.id3Header.size - extendedHeader.size);\n        }\n    }\n    async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {\n        const buffer = Buffer.alloc(dataRemaining);\n        await this.tokenizer.readBuffer(buffer, { length: dataRemaining });\n        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);\n    }\n    async parseId3Data(dataLen) {\n        const buffer = Buffer.alloc(dataLen);\n        await this.tokenizer.readBuffer(buffer, { length: dataLen });\n        for (const tag of this.parseMetadata(buffer)) {\n            if (tag.id === 'TXXX') {\n                if (tag.value) {\n                    for (const text of tag.value.text) {\n                        this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);\n                    }\n                }\n            }\n            else if (tag.id === 'COM') {\n                for (const value of tag.value) {\n                    this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);\n                }\n            }\n            else if (tag.id === 'COMM') {\n                for (const value of tag.value) {\n                    this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value);\n                }\n            }\n            else if (Array.isArray(tag.value)) {\n                for (const value of tag.value) {\n                    this.addTag(tag.id, value);\n                }\n            }\n            else {\n                this.addTag(tag.id, tag.value);\n            }\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(this.headerType, id, value);\n    }\n    parseMetadata(data) {\n        let offset = 0;\n        const tags = [];\n        while (true) {\n            if (offset === data.length)\n                break;\n            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);\n            if (offset + frameHeaderLength > data.length) {\n                this.metadata.addWarning('Illegal ID3v2 tag length');\n                break;\n            }\n            const frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);\n            const frameHeader = ID3v2Parser.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);\n            // Last frame. Check first char is a letter, bit of defensive programming\n            if (frameHeader.id === '' || frameHeader.id === '\\u0000\\u0000\\u0000\\u0000' ||\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(frameHeader.id[0]) === -1) {\n                // ToDo: generate WARNING\n                break;\n            }\n            const frameDataBytes = data.slice(offset, offset += frameHeader.length);\n            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);\n            tags.push({ id: frameHeader.id, value: values });\n        }\n        return tags;\n    }\n}\nexports.ID3v2Parser = ID3v2Parser;\n//# sourceMappingURL=ID3v2Parser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0lEM3YyUGFyc2VyLmpzPzY0YTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLDZFQUFlO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLDJFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0lEM3YyUGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklEM3YyUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBGcmFtZVBhcnNlcl8xID0gcmVxdWlyZShcIi4vRnJhbWVQYXJzZXJcIik7XG5jb25zdCBJRDN2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9JRDN2MlRva2VuXCIpO1xuY2xhc3MgSUQzdjJQYXJzZXIge1xuICAgIHN0YXRpYyByZW1vdmVVbnN5bmNCeXRlcyhidWZmZXIpIHtcbiAgICAgICAgbGV0IHJlYWRJID0gMDtcbiAgICAgICAgbGV0IHdyaXRlSSA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkSSA8IGJ1ZmZlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAocmVhZEkgIT09IHdyaXRlSSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclt3cml0ZUldID0gYnVmZmVyW3JlYWRJXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRJICs9IChidWZmZXJbcmVhZEldID09PSAweEZGICYmIGJ1ZmZlcltyZWFkSSArIDFdID09PSAwKSA/IDIgOiAxO1xuICAgICAgICAgICAgd3JpdGVJKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRJIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgYnVmZmVyW3dyaXRlSSsrXSA9IGJ1ZmZlcltyZWFkSV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCB3cml0ZUkpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVhZEZyYW1lSGVhZGVyKHYsIG1ham9yVmVyKSB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIHN3aXRjaCAobWFqb3JWZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2LnRvU3RyaW5nKCdhc2NpaScsIDAsIDMpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IFRva2VuLlVJTlQyNF9CRS5nZXQodiwgMylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHYudG9TdHJpbmcoJ2FzY2lpJywgMCwgNCksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogVG9rZW4uVUlOVDMyX0JFLmdldCh2LCA0KSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IElEM3YyUGFyc2VyLnJlYWRGcmFtZUZsYWdzKHYuc2xpY2UoOCwgMTApKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogdi50b1N0cmluZygnYXNjaWknLCAwLCA0KSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBJRDN2MlRva2VuXzEuVUlOVDMyU1lOQ1NBRkUuZ2V0KHYsIDQpLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogSUQzdjJQYXJzZXIucmVhZEZyYW1lRmxhZ3Modi5zbGljZSg4LCAxMCkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG1ham9yVmVyOiAnICsgbWFqb3JWZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRGcmFtZUhlYWRlckxlbmd0aChtYWpvclZlcikge1xuICAgICAgICBzd2l0Y2ggKG1ham9yVmVyKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciB2ZXJzaW9uSW5kZXggaXMgaW5jb3JyZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlYWRGcmFtZUZsYWdzKGIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIHRhZ19hbHRlcl9wcmVzZXJ2YXRpb246IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYiwgMCwgNiksXG4gICAgICAgICAgICAgICAgZmlsZV9hbHRlcl9wcmVzZXJ2YXRpb246IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYiwgMCwgNSksXG4gICAgICAgICAgICAgICAgcmVhZF9vbmx5OiBVdGlsXzEuZGVmYXVsdC5zdHJ0b2tCSVRTRVQuZ2V0KGIsIDAsIDQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdfaWRlbnRpdHk6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYiwgMSwgNyksXG4gICAgICAgICAgICAgICAgY29tcHJlc3Npb246IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYiwgMSwgMyksXG4gICAgICAgICAgICAgICAgZW5jcnlwdGlvbjogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChiLCAxLCAyKSxcbiAgICAgICAgICAgICAgICB1bnN5bmNocm9uaXNhdGlvbjogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChiLCAxLCAxKSxcbiAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aF9pbmRpY2F0b3I6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYiwgMSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWRGcmFtZURhdGEoYnVmLCBmcmFtZUhlYWRlciwgbWFqb3JWZXIsIGluY2x1ZGVDb3ZlcnMsIHdhcm5pbmdDb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZnJhbWVQYXJzZXIgPSBuZXcgRnJhbWVQYXJzZXJfMS5GcmFtZVBhcnNlcihtYWpvclZlciwgd2FybmluZ0NvbGxlY3Rvcik7XG4gICAgICAgIHN3aXRjaCAobWFqb3JWZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVQYXJzZXIucmVhZERhdGEoYnVmLCBmcmFtZUhlYWRlci5pZCwgaW5jbHVkZUNvdmVycyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lSGVhZGVyLmZsYWdzLmZvcm1hdC51bnN5bmNocm9uaXNhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBJRDN2MlBhcnNlci5yZW1vdmVVbnN5bmNCeXRlcyhidWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVIZWFkZXIuZmxhZ3MuZm9ybWF0LmRhdGFfbGVuZ3RoX2luZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuc2xpY2UoNCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVBhcnNlci5yZWFkRGF0YShidWYsIGZyYW1lSGVhZGVyLmlkLCBpbmNsdWRlQ292ZXJzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG1ham9yVmVyOiAnICsgbWFqb3JWZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbWJpbmVkIHRhZyBrZXksIG9mIHRhZyAmIGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBlLmcuOiBDT01cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb24gZS5nLiBpVHVuUEdBUFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGUuZy4gQ09NOmlUdW5QR0FQXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VEZXNjcmlwdGlvblRhZ05hbWUodGFnLCBkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gdGFnICsgKGRlc2NyaXB0aW9uID8gJzonICsgZGVzY3JpcHRpb24gOiAnJyk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgaWQzSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKElEM3YyVG9rZW5fMS5JRDN2MkhlYWRlcik7XG4gICAgICAgIGlmIChpZDNIZWFkZXIuZmlsZUlkZW50aWZpZXIgIT09ICdJRDMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIElEMy1oZWFkZXIgZmlsZS1pZGVudGlmaWVyIFxcJ0lEM1xcJyB3YXMgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZDNIZWFkZXIgPSBpZDNIZWFkZXI7XG4gICAgICAgIHRoaXMuaGVhZGVyVHlwZSA9ICgnSUQzdjIuJyArIGlkM0hlYWRlci52ZXJzaW9uLm1ham9yKTtcbiAgICAgICAgaWYgKGlkM0hlYWRlci5mbGFncy5pc0V4dGVuZGVkSGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4dGVuZGVkSGVhZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlkM0RhdGEoaWQzSGVhZGVyLnNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlRXh0ZW5kZWRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKElEM3YyVG9rZW5fMS5FeHRlbmRlZEhlYWRlcik7XG4gICAgICAgIGNvbnN0IGRhdGFSZW1haW5pbmcgPSBleHRlbmRlZEhlYWRlci5zaXplIC0gSUQzdjJUb2tlbl8xLkV4dGVuZGVkSGVhZGVyLmxlbjtcbiAgICAgICAgaWYgKGRhdGFSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4dGVuZGVkSGVhZGVyRGF0YShkYXRhUmVtYWluaW5nLCBleHRlbmRlZEhlYWRlci5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWQzRGF0YSh0aGlzLmlkM0hlYWRlci5zaXplIC0gZXh0ZW5kZWRIZWFkZXIuc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VFeHRlbmRlZEhlYWRlckRhdGEoZGF0YVJlbWFpbmluZywgZXh0ZW5kZWRIZWFkZXJTaXplKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhkYXRhUmVtYWluaW5nKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihidWZmZXIsIHsgbGVuZ3RoOiBkYXRhUmVtYWluaW5nIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlkM0RhdGEodGhpcy5pZDNIZWFkZXIuc2l6ZSAtIGV4dGVuZGVkSGVhZGVyU2l6ZSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlSWQzRGF0YShkYXRhTGVuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhkYXRhTGVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihidWZmZXIsIHsgbGVuZ3RoOiBkYXRhTGVuIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnBhcnNlTWV0YWRhdGEoYnVmZmVyKSkge1xuICAgICAgICAgICAgaWYgKHRhZy5pZCA9PT0gJ1RYWFgnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRleHQgb2YgdGFnLnZhbHVlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKElEM3YyUGFyc2VyLm1ha2VEZXNjcmlwdGlvblRhZ05hbWUodGFnLmlkLCB0YWcudmFsdWUuZGVzY3JpcHRpb24pLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhZy5pZCA9PT0gJ0NPTScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRhZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyhJRDN2MlBhcnNlci5tYWtlRGVzY3JpcHRpb25UYWdOYW1lKHRhZy5pZCwgdmFsdWUuZGVzY3JpcHRpb24pLCB2YWx1ZS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWcuaWQgPT09ICdDT01NJykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFnLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKElEM3YyUGFyc2VyLm1ha2VEZXNjcmlwdGlvblRhZ05hbWUodGFnLmlkLCB2YWx1ZS5kZXNjcmlwdGlvbiksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhZy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRhZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWcuaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWcuaWQsIHRhZy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKGlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZyh0aGlzLmhlYWRlclR5cGUsIGlkLCB2YWx1ZSk7XG4gICAgfVxuICAgIHBhcnNlTWV0YWRhdGEoZGF0YSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUhlYWRlckxlbmd0aCA9IElEM3YyUGFyc2VyLmdldEZyYW1lSGVhZGVyTGVuZ3RoKHRoaXMuaWQzSGVhZGVyLnZlcnNpb24ubWFqb3IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCArIGZyYW1lSGVhZGVyTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0lsbGVnYWwgSUQzdjIgdGFnIGxlbmd0aCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhbWVIZWFkZXJCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKz0gZnJhbWVIZWFkZXJMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVIZWFkZXIgPSBJRDN2MlBhcnNlci5yZWFkRnJhbWVIZWFkZXIoZnJhbWVIZWFkZXJCeXRlcywgdGhpcy5pZDNIZWFkZXIudmVyc2lvbi5tYWpvcik7XG4gICAgICAgICAgICAvLyBMYXN0IGZyYW1lLiBDaGVjayBmaXJzdCBjaGFyIGlzIGEgbGV0dGVyLCBiaXQgb2YgZGVmZW5zaXZlIHByb2dyYW1taW5nXG4gICAgICAgICAgICBpZiAoZnJhbWVIZWFkZXIuaWQgPT09ICcnIHx8IGZyYW1lSGVhZGVyLmlkID09PSAnXFx1MDAwMFxcdTAwMDBcXHUwMDAwXFx1MDAwMCcgfHxcbiAgICAgICAgICAgICAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonLmluZGV4T2YoZnJhbWVIZWFkZXIuaWRbMF0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRvRG86IGdlbmVyYXRlIFdBUk5JTkdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYW1lRGF0YUJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArPSBmcmFtZUhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gSUQzdjJQYXJzZXIucmVhZEZyYW1lRGF0YShmcmFtZURhdGFCeXRlcywgZnJhbWVIZWFkZXIsIHRoaXMuaWQzSGVhZGVyLnZlcnNpb24ubWFqb3IsICF0aGlzLm9wdGlvbnMuc2tpcENvdmVycywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICB0YWdzLnB1c2goeyBpZDogZnJhbWVIZWFkZXIuaWQsIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxufVxuZXhwb3J0cy5JRDN2MlBhcnNlciA9IElEM3YyUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUQzdjJQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/ID3v2Token.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v2Token.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextEncodingToken = exports.ExtendedHeader = exports.ID3v2Header = exports.UINT32SYNCSAFE = exports.AttachedPictureType = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * The picture type according to the ID3v2 APIC frame\n * Ref: http://id3.org/id3v2.3.0#Attached_picture\n */\nvar AttachedPictureType;\n(function (AttachedPictureType) {\n    AttachedPictureType[AttachedPictureType[\"Other\"] = 0] = \"Other\";\n    AttachedPictureType[AttachedPictureType[\"32x32 pixels 'file icon' (PNG only)\"] = 1] = \"32x32 pixels 'file icon' (PNG only)\";\n    AttachedPictureType[AttachedPictureType[\"Other file icon\"] = 2] = \"Other file icon\";\n    AttachedPictureType[AttachedPictureType[\"Cover (front)\"] = 3] = \"Cover (front)\";\n    AttachedPictureType[AttachedPictureType[\"Cover (back)\"] = 4] = \"Cover (back)\";\n    AttachedPictureType[AttachedPictureType[\"Leaflet page\"] = 5] = \"Leaflet page\";\n    AttachedPictureType[AttachedPictureType[\"Media (e.g. label side of CD)\"] = 6] = \"Media (e.g. label side of CD)\";\n    AttachedPictureType[AttachedPictureType[\"Lead artist/lead performer/soloist\"] = 7] = \"Lead artist/lead performer/soloist\";\n    AttachedPictureType[AttachedPictureType[\"Artist/performer\"] = 8] = \"Artist/performer\";\n    AttachedPictureType[AttachedPictureType[\"Conductor\"] = 9] = \"Conductor\";\n    AttachedPictureType[AttachedPictureType[\"Band/Orchestra\"] = 10] = \"Band/Orchestra\";\n    AttachedPictureType[AttachedPictureType[\"Composer\"] = 11] = \"Composer\";\n    AttachedPictureType[AttachedPictureType[\"Lyricist/text writer\"] = 12] = \"Lyricist/text writer\";\n    AttachedPictureType[AttachedPictureType[\"Recording Location\"] = 13] = \"Recording Location\";\n    AttachedPictureType[AttachedPictureType[\"During recording\"] = 14] = \"During recording\";\n    AttachedPictureType[AttachedPictureType[\"During performance\"] = 15] = \"During performance\";\n    AttachedPictureType[AttachedPictureType[\"Movie/video screen capture\"] = 16] = \"Movie/video screen capture\";\n    AttachedPictureType[AttachedPictureType[\"A bright coloured fish\"] = 17] = \"A bright coloured fish\";\n    AttachedPictureType[AttachedPictureType[\"Illustration\"] = 18] = \"Illustration\";\n    AttachedPictureType[AttachedPictureType[\"Band/artist logotype\"] = 19] = \"Band/artist logotype\";\n    AttachedPictureType[AttachedPictureType[\"Publisher/Studio logotype\"] = 20] = \"Publisher/Studio logotype\";\n})(AttachedPictureType = exports.AttachedPictureType || (exports.AttachedPictureType = {}));\n/**\n * 28 bits (representing up to 256MB) integer, the msb is 0 to avoid 'false syncsignals'.\n * 4 * %0xxxxxxx\n */\nexports.UINT32SYNCSAFE = {\n    get: (buf, off) => {\n        return buf[off + 3] & 0x7f | ((buf[off + 2]) << 7) |\n            ((buf[off + 1]) << 14) | ((buf[off]) << 21);\n    },\n    len: 4\n};\n/**\n * ID3v2 header\n * Ref: http://id3.org/id3v2.3.0#ID3v2_header\n * ToDo\n */\nexports.ID3v2Header = {\n    len: 10,\n    get: (buf, off) => {\n        return {\n            // ID3v2/file identifier   \"ID3\"\n            fileIdentifier: new Token.StringType(3, 'ascii').get(buf, off),\n            // ID3v2 versionIndex\n            version: {\n                major: Token.INT8.get(buf, off + 3),\n                revision: Token.INT8.get(buf, off + 4)\n            },\n            // ID3v2 flags\n            flags: {\n                // Unsynchronisation\n                unsynchronisation: Util_1.default.strtokBITSET.get(buf, off + 5, 7),\n                // Extended header\n                isExtendedHeader: Util_1.default.strtokBITSET.get(buf, off + 5, 6),\n                // Experimental indicator\n                expIndicator: Util_1.default.strtokBITSET.get(buf, off + 5, 5),\n                footer: Util_1.default.strtokBITSET.get(buf, off + 5, 4)\n            },\n            size: exports.UINT32SYNCSAFE.get(buf, off + 6)\n        };\n    }\n};\nexports.ExtendedHeader = {\n    len: 10,\n    get: (buf, off) => {\n        return {\n            // Extended header size\n            size: Token.UINT32_BE.get(buf, off),\n            // Extended Flags\n            extendedFlags: Token.UINT16_BE.get(buf, off + 4),\n            // Size of padding\n            sizeOfPadding: Token.UINT32_BE.get(buf, off + 6),\n            // CRC data present\n            crcDataPresent: Util_1.default.strtokBITSET.get(buf, off + 4, 31)\n        };\n    }\n};\nexports.TextEncodingToken = {\n    len: 1,\n    get: (buf, off) => {\n        switch (buf.readUInt8(off)) {\n            case 0x00:\n                return { encoding: 'iso-8859-1' }; // binary\n            case 0x01:\n                return { encoding: 'utf16', bom: true };\n            case 0x02:\n                return { encoding: 'utf16', bom: false };\n            case 0x03:\n                return { encoding: 'utf8', bom: false };\n            default:\n                return { encoding: 'utf8', bom: false };\n        }\n    }\n};\n//# sourceMappingURL=ID3v2Token.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lkM3YyL0lEM3YyVG9rZW4uanM/MDY2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3RkFBd0Y7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2Mi9JRDN2MlRva2VuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRFbmNvZGluZ1Rva2VuID0gZXhwb3J0cy5FeHRlbmRlZEhlYWRlciA9IGV4cG9ydHMuSUQzdjJIZWFkZXIgPSBleHBvcnRzLlVJTlQzMlNZTkNTQUZFID0gZXhwb3J0cy5BdHRhY2hlZFBpY3R1cmVUeXBlID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG4vKipcbiAqIFRoZSBwaWN0dXJlIHR5cGUgYWNjb3JkaW5nIHRvIHRoZSBJRDN2MiBBUElDIGZyYW1lXG4gKiBSZWY6IGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMCNBdHRhY2hlZF9waWN0dXJlXG4gKi9cbnZhciBBdHRhY2hlZFBpY3R1cmVUeXBlO1xuKGZ1bmN0aW9uIChBdHRhY2hlZFBpY3R1cmVUeXBlKSB7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiT3RoZXJcIl0gPSAwXSA9IFwiT3RoZXJcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCIzMngzMiBwaXhlbHMgJ2ZpbGUgaWNvbicgKFBORyBvbmx5KVwiXSA9IDFdID0gXCIzMngzMiBwaXhlbHMgJ2ZpbGUgaWNvbicgKFBORyBvbmx5KVwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIk90aGVyIGZpbGUgaWNvblwiXSA9IDJdID0gXCJPdGhlciBmaWxlIGljb25cIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJDb3ZlciAoZnJvbnQpXCJdID0gM10gPSBcIkNvdmVyIChmcm9udClcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJDb3ZlciAoYmFjaylcIl0gPSA0XSA9IFwiQ292ZXIgKGJhY2spXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiTGVhZmxldCBwYWdlXCJdID0gNV0gPSBcIkxlYWZsZXQgcGFnZVwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIk1lZGlhIChlLmcuIGxhYmVsIHNpZGUgb2YgQ0QpXCJdID0gNl0gPSBcIk1lZGlhIChlLmcuIGxhYmVsIHNpZGUgb2YgQ0QpXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiTGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdFwiXSA9IDddID0gXCJMZWFkIGFydGlzdC9sZWFkIHBlcmZvcm1lci9zb2xvaXN0XCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQXJ0aXN0L3BlcmZvcm1lclwiXSA9IDhdID0gXCJBcnRpc3QvcGVyZm9ybWVyXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQ29uZHVjdG9yXCJdID0gOV0gPSBcIkNvbmR1Y3RvclwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkJhbmQvT3JjaGVzdHJhXCJdID0gMTBdID0gXCJCYW5kL09yY2hlc3RyYVwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkNvbXBvc2VyXCJdID0gMTFdID0gXCJDb21wb3NlclwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkx5cmljaXN0L3RleHQgd3JpdGVyXCJdID0gMTJdID0gXCJMeXJpY2lzdC90ZXh0IHdyaXRlclwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIlJlY29yZGluZyBMb2NhdGlvblwiXSA9IDEzXSA9IFwiUmVjb3JkaW5nIExvY2F0aW9uXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiRHVyaW5nIHJlY29yZGluZ1wiXSA9IDE0XSA9IFwiRHVyaW5nIHJlY29yZGluZ1wiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkR1cmluZyBwZXJmb3JtYW5jZVwiXSA9IDE1XSA9IFwiRHVyaW5nIHBlcmZvcm1hbmNlXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiTW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmVcIl0gPSAxNl0gPSBcIk1vdmllL3ZpZGVvIHNjcmVlbiBjYXB0dXJlXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQSBicmlnaHQgY29sb3VyZWQgZmlzaFwiXSA9IDE3XSA9IFwiQSBicmlnaHQgY29sb3VyZWQgZmlzaFwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIklsbHVzdHJhdGlvblwiXSA9IDE4XSA9IFwiSWxsdXN0cmF0aW9uXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQmFuZC9hcnRpc3QgbG9nb3R5cGVcIl0gPSAxOV0gPSBcIkJhbmQvYXJ0aXN0IGxvZ290eXBlXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiUHVibGlzaGVyL1N0dWRpbyBsb2dvdHlwZVwiXSA9IDIwXSA9IFwiUHVibGlzaGVyL1N0dWRpbyBsb2dvdHlwZVwiO1xufSkoQXR0YWNoZWRQaWN0dXJlVHlwZSA9IGV4cG9ydHMuQXR0YWNoZWRQaWN0dXJlVHlwZSB8fCAoZXhwb3J0cy5BdHRhY2hlZFBpY3R1cmVUeXBlID0ge30pKTtcbi8qKlxuICogMjggYml0cyAocmVwcmVzZW50aW5nIHVwIHRvIDI1Nk1CKSBpbnRlZ2VyLCB0aGUgbXNiIGlzIDAgdG8gYXZvaWQgJ2ZhbHNlIHN5bmNzaWduYWxzJy5cbiAqIDQgKiAlMHh4eHh4eHhcbiAqL1xuZXhwb3J0cy5VSU5UMzJTWU5DU0FGRSA9IHtcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4gYnVmW29mZiArIDNdICYgMHg3ZiB8ICgoYnVmW29mZiArIDJdKSA8PCA3KSB8XG4gICAgICAgICAgICAoKGJ1ZltvZmYgKyAxXSkgPDwgMTQpIHwgKChidWZbb2ZmXSkgPDwgMjEpO1xuICAgIH0sXG4gICAgbGVuOiA0XG59O1xuLyoqXG4gKiBJRDN2MiBoZWFkZXJcbiAqIFJlZjogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wI0lEM3YyX2hlYWRlclxuICogVG9Eb1xuICovXG5leHBvcnRzLklEM3YySGVhZGVyID0ge1xuICAgIGxlbjogMTAsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIElEM3YyL2ZpbGUgaWRlbnRpZmllciAgIFwiSUQzXCJcbiAgICAgICAgICAgIGZpbGVJZGVudGlmaWVyOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSgzLCAnYXNjaWknKS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gSUQzdjIgdmVyc2lvbkluZGV4XG4gICAgICAgICAgICB2ZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgbWFqb3I6IFRva2VuLklOVDguZ2V0KGJ1Ziwgb2ZmICsgMyksXG4gICAgICAgICAgICAgICAgcmV2aXNpb246IFRva2VuLklOVDguZ2V0KGJ1Ziwgb2ZmICsgNClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJRDN2MiBmbGFnc1xuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAvLyBVbnN5bmNocm9uaXNhdGlvblxuICAgICAgICAgICAgICAgIHVuc3luY2hyb25pc2F0aW9uOiBVdGlsXzEuZGVmYXVsdC5zdHJ0b2tCSVRTRVQuZ2V0KGJ1Ziwgb2ZmICsgNSwgNyksXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgaXNFeHRlbmRlZEhlYWRlcjogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChidWYsIG9mZiArIDUsIDYpLFxuICAgICAgICAgICAgICAgIC8vIEV4cGVyaW1lbnRhbCBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBleHBJbmRpY2F0b3I6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYnVmLCBvZmYgKyA1LCA1KSxcbiAgICAgICAgICAgICAgICBmb290ZXI6IFV0aWxfMS5kZWZhdWx0LnN0cnRva0JJVFNFVC5nZXQoYnVmLCBvZmYgKyA1LCA0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemU6IGV4cG9ydHMuVUlOVDMyU1lOQ1NBRkUuZ2V0KGJ1Ziwgb2ZmICsgNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5FeHRlbmRlZEhlYWRlciA9IHtcbiAgICBsZW46IDEwLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBFeHRlbmRlZCBoZWFkZXIgc2l6ZVxuICAgICAgICAgICAgc2l6ZTogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBFeHRlbmRlZCBGbGFnc1xuICAgICAgICAgICAgZXh0ZW5kZWRGbGFnczogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gU2l6ZSBvZiBwYWRkaW5nXG4gICAgICAgICAgICBzaXplT2ZQYWRkaW5nOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNiksXG4gICAgICAgICAgICAvLyBDUkMgZGF0YSBwcmVzZW50XG4gICAgICAgICAgICBjcmNEYXRhUHJlc2VudDogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChidWYsIG9mZiArIDQsIDMxKVxuICAgICAgICB9O1xuICAgIH1cbn07XG5leHBvcnRzLlRleHRFbmNvZGluZ1Rva2VuID0ge1xuICAgIGxlbjogMSxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGJ1Zi5yZWFkVUludDgob2ZmKSkge1xuICAgICAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY29kaW5nOiAnaXNvLTg4NTktMScgfTsgLy8gYmluYXJ5XG4gICAgICAgICAgICBjYXNlIDB4MDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZW5jb2Rpbmc6ICd1dGYxNicsIGJvbTogdHJ1ZSB9O1xuICAgICAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY29kaW5nOiAndXRmMTYnLCBib206IGZhbHNlIH07XG4gICAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZW5jb2Rpbmc6ICd1dGY4JywgYm9tOiBmYWxzZSB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlbmNvZGluZzogJ3V0ZjgnLCBib206IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUQzdjJUb2tlbi5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/iff/index.js":
/*!******************************************************!*\
  !*** ./node_modules/music-metadata/lib/iff/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * Common AIFF chunk header\n */\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Chunk type ID\n            chunkID: FourCC_1.FourCcToken.get(buf, off),\n            // Chunk size\n            chunkSize: buf.readUInt32BE(off + 4)\n        };\n    }\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lmZi9pbmRleC5qcz82YTAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZmYvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbi8qKlxuICogQ29tbW9uIEFJRkYgY2h1bmsgaGVhZGVyXG4gKi9cbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gQ2h1bmsgdHlwZSBJRFxuICAgICAgICAgICAgY2h1bmtJRDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIC8vIENodW5rIHNpemVcbiAgICAgICAgICAgIGNodW5rU2l6ZTogYnVmLnJlYWRVSW50MzJCRShvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/iff/index.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/lyrics3/Lyrics3.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/lyrics3/Lyrics3.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLyricsHeaderLength = exports.endTag2 = void 0;\nexports.endTag2 = 'LYRICS200';\nasync function getLyricsHeaderLength(reader) {\n    if (reader.fileSize >= 143) {\n        const buf = Buffer.alloc(15);\n        await reader.randomRead(buf, 0, buf.length, reader.fileSize - 143);\n        const txt = buf.toString('binary');\n        const tag = txt.substr(6);\n        if (tag === exports.endTag2) {\n            return parseInt(txt.substr(0, 6), 10) + 15;\n        }\n    }\n    return 0;\n}\nexports.getLyricsHeaderLength = getLyricsHeaderLength;\n//# sourceMappingURL=Lyrics3.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2x5cmljczMvTHlyaWNzMy5qcz81YTQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2x5cmljczMvTHlyaWNzMy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRMeXJpY3NIZWFkZXJMZW5ndGggPSBleHBvcnRzLmVuZFRhZzIgPSB2b2lkIDA7XG5leHBvcnRzLmVuZFRhZzIgPSAnTFlSSUNTMjAwJztcbmFzeW5jIGZ1bmN0aW9uIGdldEx5cmljc0hlYWRlckxlbmd0aChyZWFkZXIpIHtcbiAgICBpZiAocmVhZGVyLmZpbGVTaXplID49IDE0Mykge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoMTUpO1xuICAgICAgICBhd2FpdCByZWFkZXIucmFuZG9tUmVhZChidWYsIDAsIGJ1Zi5sZW5ndGgsIHJlYWRlci5maWxlU2l6ZSAtIDE0Myk7XG4gICAgICAgIGNvbnN0IHR4dCA9IGJ1Zi50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgIGNvbnN0IHRhZyA9IHR4dC5zdWJzdHIoNik7XG4gICAgICAgIGlmICh0YWcgPT09IGV4cG9ydHMuZW5kVGFnMikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR4dC5zdWJzdHIoMCwgNiksIDEwKSArIDE1O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZXhwb3J0cy5nZXRMeXJpY3NIZWFkZXJMZW5ndGggPSBnZXRMeXJpY3NIZWFkZXJMZW5ndGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MeXJpY3MzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/lyrics3/Lyrics3.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/matroska/MatroskaDtd.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaDtd.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.elements = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/music-metadata/lib/matroska/types.js\");\n/**\n * Elements of document type description\n * Derived from https://github.com/tungol/EBML/blob/master/doctypes/matroska.dtd\n * Extended with:\n *  https://www.matroska.org/technical/specs/index.html\n */\nexports.elements = {\n    0x1a45dfa3: {\n        name: 'ebml',\n        container: {\n            0x4286: { name: 'ebmlVersion', value: types_1.DataType.uint },\n            0x42f7: { name: 'ebmlReadVersion', value: types_1.DataType.uint },\n            0x42f2: { name: 'ebmlMaxIDWidth', value: types_1.DataType.uint },\n            0x42f3: { name: 'ebmlMaxSizeWidth', value: types_1.DataType.uint },\n            0x4282: { name: 'docType', value: types_1.DataType.string },\n            0x4287: { name: 'docTypeVersion', value: types_1.DataType.uint },\n            0x4285: { name: 'docTypeReadVersion', value: types_1.DataType.uint } // 5.1.7\n        }\n    },\n    // Matroska segments\n    0x18538067: {\n        name: 'segment',\n        container: {\n            // Meta Seek Information\n            0x114d9b74: {\n                name: 'seekHead',\n                container: {\n                    0x4dbb: {\n                        name: 'seek',\n                        container: {\n                            0x53ab: { name: 'seekId', value: types_1.DataType.binary },\n                            0x53ac: { name: 'seekPosition', value: types_1.DataType.uint }\n                        }\n                    }\n                }\n            },\n            // Segment Information\n            0x1549a966: {\n                name: 'info',\n                container: {\n                    0x73a4: { name: 'uid', value: types_1.DataType.uid },\n                    0x7384: { name: 'filename', value: types_1.DataType.string },\n                    0x3cb923: { name: 'prevUID', value: types_1.DataType.uid },\n                    0x3c83ab: { name: 'prevFilename', value: types_1.DataType.string },\n                    0x3eb923: { name: 'nextUID', value: types_1.DataType.uid },\n                    0x3e83bb: { name: 'nextFilename', value: types_1.DataType.string },\n                    0x2ad7b1: { name: 'timecodeScale', value: types_1.DataType.uint },\n                    0x4489: { name: 'duration', value: types_1.DataType.float },\n                    0x4461: { name: 'dateUTC', value: types_1.DataType.uint },\n                    0x7ba9: { name: 'title', value: types_1.DataType.string },\n                    0x4d80: { name: 'muxingApp', value: types_1.DataType.string },\n                    0x5741: { name: 'writingApp', value: types_1.DataType.string }\n                }\n            },\n            // Cluster\n            0x1f43b675: {\n                name: 'cluster',\n                multiple: true,\n                container: {\n                    0xe7: { name: 'timecode', value: types_1.DataType.uid },\n                    0xa3: { name: 'unknown', value: types_1.DataType.binary },\n                    0xa7: { name: 'position', value: types_1.DataType.uid },\n                    0xab: { name: 'prevSize', value: types_1.DataType.uid }\n                }\n            },\n            // Track\n            0x1654ae6b: {\n                name: 'tracks',\n                container: {\n                    0xae: {\n                        name: 'entries',\n                        multiple: true,\n                        container: {\n                            0xd7: { name: 'trackNumber', value: types_1.DataType.uint },\n                            0x73c5: { name: 'uid', value: types_1.DataType.uid },\n                            0x83: { name: 'trackType', value: types_1.DataType.uint },\n                            0xb9: { name: 'flagEnabled', value: types_1.DataType.bool },\n                            0x88: { name: 'flagDefault', value: types_1.DataType.bool },\n                            0x55aa: { name: 'flagForced', value: types_1.DataType.bool },\n                            0x9c: { name: 'flagLacing', value: types_1.DataType.bool },\n                            0x6de7: { name: 'minCache', value: types_1.DataType.uint },\n                            0x6de8: { name: 'maxCache', value: types_1.DataType.uint },\n                            0x23e383: { name: 'defaultDuration', value: types_1.DataType.uint },\n                            0x23314f: { name: 'timecodeScale', value: types_1.DataType.float },\n                            0x536e: { name: 'name', value: types_1.DataType.string },\n                            0x22b59c: { name: 'language', value: types_1.DataType.string },\n                            0x86: { name: 'codecID', value: types_1.DataType.string },\n                            0x63a2: { name: 'codecPrivate', value: types_1.DataType.binary },\n                            0x258688: { name: 'codecName', value: types_1.DataType.string },\n                            0x3a9697: { name: 'codecSettings', value: types_1.DataType.string },\n                            0x3b4040: { name: 'codecInfoUrl', value: types_1.DataType.string },\n                            0x26b240: { name: 'codecDownloadUrl', value: types_1.DataType.string },\n                            0xaa: { name: 'codecDecodeAll', value: types_1.DataType.bool },\n                            0x6fab: { name: 'trackOverlay', value: types_1.DataType.uint },\n                            // Video\n                            0xe0: {\n                                name: 'video',\n                                container: {\n                                    0x9a: { name: 'flagInterlaced', value: types_1.DataType.bool },\n                                    0x53b8: { name: 'stereoMode', value: types_1.DataType.uint },\n                                    0xb0: { name: 'pixelWidth', value: types_1.DataType.uint },\n                                    0xba: { name: 'pixelHeight', value: types_1.DataType.uint },\n                                    0x54b0: { name: 'displayWidth', value: types_1.DataType.uint },\n                                    0x54ba: { name: 'displayHeight', value: types_1.DataType.uint },\n                                    0x54b3: { name: 'aspectRatioType', value: types_1.DataType.uint },\n                                    0x2eb524: { name: 'colourSpace', value: types_1.DataType.uint },\n                                    0x2fb523: { name: 'gammaValue', value: types_1.DataType.float }\n                                }\n                            },\n                            // Audio\n                            0xe1: {\n                                name: 'audio',\n                                container: {\n                                    0xb5: { name: 'samplingFrequency', value: types_1.DataType.float },\n                                    0x78b5: { name: 'outputSamplingFrequency', value: types_1.DataType.float },\n                                    0x9f: { name: 'channels', value: types_1.DataType.uint },\n                                    0x94: { name: 'channels', value: types_1.DataType.uint },\n                                    0x7d7b: { name: 'channelPositions', value: types_1.DataType.binary },\n                                    0x6264: { name: 'bitDepth', value: types_1.DataType.uint }\n                                }\n                            },\n                            // Content Encoding\n                            0x6d80: {\n                                name: 'contentEncodings',\n                                container: {\n                                    0x6240: {\n                                        name: 'contentEncoding',\n                                        container: {\n                                            0x5031: { name: 'order', value: types_1.DataType.uint },\n                                            0x5032: { name: 'scope', value: types_1.DataType.bool },\n                                            0x5033: { name: 'type', value: types_1.DataType.uint },\n                                            0x5034: {\n                                                name: 'contentEncoding',\n                                                container: {\n                                                    0x4254: { name: 'contentCompAlgo', value: types_1.DataType.uint },\n                                                    0x4255: { name: 'contentCompSettings', value: types_1.DataType.binary }\n                                                }\n                                            },\n                                            0x5035: {\n                                                name: 'contentEncoding',\n                                                container: {\n                                                    0x47e1: { name: 'contentEncAlgo', value: types_1.DataType.uint },\n                                                    0x47e2: { name: 'contentEncKeyID', value: types_1.DataType.binary },\n                                                    0x47e3: { name: 'contentSignature ', value: types_1.DataType.binary },\n                                                    0x47e4: { name: 'ContentSigKeyID  ', value: types_1.DataType.binary },\n                                                    0x47e5: { name: 'contentSigAlgo ', value: types_1.DataType.uint },\n                                                    0x47e6: { name: 'contentSigHashAlgo ', value: types_1.DataType.uint }\n                                                }\n                                            },\n                                            0x6264: { name: 'bitDepth', value: types_1.DataType.uint }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Cueing Data\n            0x1c53bb6b: {\n                name: 'cues',\n                container: {\n                    0xbb: {\n                        name: 'cuePoint',\n                        container: {\n                            0xb3: { name: 'cueTime', value: types_1.DataType.uid },\n                            0xb7: {\n                                name: 'positions',\n                                container: {\n                                    0xf7: { name: 'track', value: types_1.DataType.uint },\n                                    0xf1: { name: 'clusterPosition', value: types_1.DataType.uint },\n                                    0x5378: { name: 'blockNumber', value: types_1.DataType.uint },\n                                    0xea: { name: 'codecState', value: types_1.DataType.uint },\n                                    0xdb: {\n                                        name: 'reference', container: {\n                                            0x96: { name: 'time', value: types_1.DataType.uint },\n                                            0x97: { name: 'cluster', value: types_1.DataType.uint },\n                                            0x535f: { name: 'number', value: types_1.DataType.uint },\n                                            0xeb: { name: 'codecState', value: types_1.DataType.uint }\n                                        }\n                                    },\n                                    0xf0: { name: 'relativePosition', value: types_1.DataType.uint } // extended\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Attachment\n            0x1941a469: {\n                name: 'attachments',\n                container: {\n                    0x61a7: {\n                        name: 'attachedFiles',\n                        multiple: true,\n                        container: {\n                            0x467e: { name: 'description', value: types_1.DataType.string },\n                            0x466e: { name: 'name', value: types_1.DataType.string },\n                            0x4660: { name: 'mimeType', value: types_1.DataType.string },\n                            0x465c: { name: 'data', value: types_1.DataType.binary },\n                            0x46ae: { name: 'uid', value: types_1.DataType.uid }\n                        }\n                    }\n                }\n            },\n            // Chapters\n            0x1043a770: {\n                name: 'chapters',\n                container: {\n                    0x45b9: {\n                        name: 'editionEntry',\n                        container: {\n                            0xb6: {\n                                name: 'chapterAtom',\n                                container: {\n                                    0x73c4: { name: 'uid', value: types_1.DataType.uid },\n                                    0x91: { name: 'timeStart', value: types_1.DataType.uint },\n                                    0x92: { name: 'timeEnd', value: types_1.DataType.uid },\n                                    0x98: { name: 'hidden', value: types_1.DataType.bool },\n                                    0x4598: { name: 'enabled', value: types_1.DataType.uid },\n                                    0x8f: { name: 'track', container: {\n                                            0x89: { name: 'trackNumber', value: types_1.DataType.uid },\n                                            0x80: {\n                                                name: 'display', container: {\n                                                    0x85: { name: 'string', value: types_1.DataType.string },\n                                                    0x437c: { name: 'language ', value: types_1.DataType.string },\n                                                    0x437e: { name: 'country ', value: types_1.DataType.string }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Tagging\n            0x1254c367: {\n                name: 'tags',\n                container: {\n                    0x7373: {\n                        name: 'tag',\n                        multiple: true,\n                        container: {\n                            0x63c0: {\n                                name: 'target',\n                                container: {\n                                    0x63c5: { name: 'tagTrackUID', value: types_1.DataType.uid },\n                                    0x63c4: { name: 'tagChapterUID', value: types_1.DataType.uint },\n                                    0x63c6: { name: 'tagAttachmentUID', value: types_1.DataType.uid },\n                                    0x63ca: { name: 'targetType', value: types_1.DataType.string },\n                                    0x68ca: { name: 'targetTypeValue', value: types_1.DataType.uint },\n                                    0x63c9: { name: 'tagEditionUID', value: types_1.DataType.uid } // extended\n                                }\n                            },\n                            0x67c8: {\n                                name: 'simpleTags',\n                                multiple: true,\n                                container: {\n                                    0x45a3: { name: 'name', value: types_1.DataType.string },\n                                    0x4487: { name: 'string', value: types_1.DataType.string },\n                                    0x4485: { name: 'binary', value: types_1.DataType.binary },\n                                    0x447a: { name: 'language', value: types_1.DataType.string },\n                                    0x447b: { name: 'languageIETF', value: types_1.DataType.string },\n                                    0x4484: { name: 'default', value: types_1.DataType.bool } // extended\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=MatroskaDtd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL01hdHJvc2thRHRkLmpzP2IxMjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFvRDtBQUN6RSxxQkFBcUIsd0RBQXdEO0FBQzdFLHFCQUFxQix1REFBdUQ7QUFDNUUscUJBQXFCLHlEQUF5RDtBQUM5RSxxQkFBcUIsa0RBQWtEO0FBQ3ZFLHFCQUFxQix1REFBdUQ7QUFDNUUscUJBQXFCLDJEQUEyRDtBQUNoRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFpRDtBQUN0RixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUEyQztBQUN4RSw2QkFBNkIsbURBQW1EO0FBQ2hGLCtCQUErQiwrQ0FBK0M7QUFDOUUsK0JBQStCLHVEQUF1RDtBQUN0RiwrQkFBK0IsK0NBQStDO0FBQzlFLCtCQUErQix1REFBdUQ7QUFDdEYsK0JBQStCLHNEQUFzRDtBQUNyRiw2QkFBNkIsa0RBQWtEO0FBQy9FLDZCQUE2QixnREFBZ0Q7QUFDN0UsNkJBQTZCLGdEQUFnRDtBQUM3RSw2QkFBNkIsb0RBQW9EO0FBQ2pGLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRSwyQkFBMkIsa0RBQWtEO0FBQzdFLDJCQUEyQixnREFBZ0Q7QUFDM0UsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQW9EO0FBQ3ZGLHFDQUFxQywyQ0FBMkM7QUFDaEYsbUNBQW1DLGtEQUFrRDtBQUNyRixtQ0FBbUMsb0RBQW9EO0FBQ3ZGLG1DQUFtQyxvREFBb0Q7QUFDdkYscUNBQXFDLG1EQUFtRDtBQUN4RixtQ0FBbUMsbURBQW1EO0FBQ3RGLHFDQUFxQyxpREFBaUQ7QUFDdEYscUNBQXFDLGlEQUFpRDtBQUN0Rix1Q0FBdUMsd0RBQXdEO0FBQy9GLHVDQUF1Qyx1REFBdUQ7QUFDOUYscUNBQXFDLCtDQUErQztBQUNwRix1Q0FBdUMsbURBQW1EO0FBQzFGLG1DQUFtQyxrREFBa0Q7QUFDckYscUNBQXFDLHVEQUF1RDtBQUM1Rix1Q0FBdUMsb0RBQW9EO0FBQzNGLHVDQUF1Qyx3REFBd0Q7QUFDL0YsdUNBQXVDLHVEQUF1RDtBQUM5Rix1Q0FBdUMsMkRBQTJEO0FBQ2xHLG1DQUFtQyx1REFBdUQ7QUFDMUYscUNBQXFDLHFEQUFxRDtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1REFBdUQ7QUFDbEcsNkNBQTZDLG1EQUFtRDtBQUNoRywyQ0FBMkMsbURBQW1EO0FBQzlGLDJDQUEyQyxvREFBb0Q7QUFDL0YsNkNBQTZDLHFEQUFxRDtBQUNsRyw2Q0FBNkMsc0RBQXNEO0FBQ25HLDZDQUE2Qyx3REFBd0Q7QUFDckcsK0NBQStDLG9EQUFvRDtBQUNuRywrQ0FBK0M7QUFDL0M7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkRBQTJEO0FBQ3RHLDZDQUE2QyxpRUFBaUU7QUFDOUcsMkNBQTJDLGlEQUFpRDtBQUM1RiwyQ0FBMkMsaURBQWlEO0FBQzVGLDZDQUE2QywyREFBMkQ7QUFDeEcsNkNBQTZDO0FBQzdDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhDQUE4QztBQUNuRyxxREFBcUQsOENBQThDO0FBQ25HLHFEQUFxRCw2Q0FBNkM7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdEQUF3RDtBQUNySCw2REFBNkQ7QUFDN0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHVEQUF1RDtBQUNwSCw2REFBNkQsMERBQTBEO0FBQ3ZILDZEQUE2RCw0REFBNEQ7QUFDekgsNkRBQTZELDREQUE0RDtBQUN6SCw2REFBNkQsd0RBQXdEO0FBQ3JILDZEQUE2RDtBQUM3RDtBQUNBLDZDQUE2QztBQUM3QyxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4Q0FBOEM7QUFDekYsMkNBQTJDLHdEQUF3RDtBQUNuRyw2Q0FBNkMsb0RBQW9EO0FBQ2pHLDJDQUEyQyxtREFBbUQ7QUFDOUY7QUFDQTtBQUNBLG1EQUFtRCw2Q0FBNkM7QUFDaEcsbURBQW1ELGdEQUFnRDtBQUNuRyxxREFBcUQsK0NBQStDO0FBQ3BHLG1EQUFtRDtBQUNuRDtBQUNBLHFDQUFxQztBQUNyQywyQ0FBMkMseURBQXlEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBc0Q7QUFDM0YscUNBQXFDLCtDQUErQztBQUNwRixxQ0FBcUMsbURBQW1EO0FBQ3hGLHFDQUFxQywrQ0FBK0M7QUFDcEYscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEYsMkNBQTJDLGtEQUFrRDtBQUM3RiwyQ0FBMkMsK0NBQStDO0FBQzFGLDJDQUEyQywrQ0FBK0M7QUFDMUYsNkNBQTZDLCtDQUErQztBQUM1RiwyQ0FBMkM7QUFDM0MsbURBQW1ELG1EQUFtRDtBQUN0RztBQUNBO0FBQ0EsMkRBQTJELGlEQUFpRDtBQUM1Ryw2REFBNkQsb0RBQW9EO0FBQ2pILDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtREFBbUQ7QUFDaEcsNkNBQTZDLHNEQUFzRDtBQUNuRyw2Q0FBNkMsd0RBQXdEO0FBQ3JHLDZDQUE2QyxxREFBcUQ7QUFDbEcsNkNBQTZDLHdEQUF3RDtBQUNyRyw2Q0FBNkMscURBQXFEO0FBQ2xHO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtDQUErQztBQUM1Riw2Q0FBNkMsaURBQWlEO0FBQzlGLDZDQUE2QyxpREFBaUQ7QUFDOUYsNkNBQTZDLG1EQUFtRDtBQUNoRyw2Q0FBNkMsdURBQXVEO0FBQ3BHLDZDQUE2QyxnREFBZ0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL01hdHJvc2thRHRkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVsZW1lbnRzID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBFbGVtZW50cyBvZiBkb2N1bWVudCB0eXBlIGRlc2NyaXB0aW9uXG4gKiBEZXJpdmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3R1bmdvbC9FQk1ML2Jsb2IvbWFzdGVyL2RvY3R5cGVzL21hdHJvc2thLmR0ZFxuICogRXh0ZW5kZWQgd2l0aDpcbiAqICBodHRwczovL3d3dy5tYXRyb3NrYS5vcmcvdGVjaG5pY2FsL3NwZWNzL2luZGV4Lmh0bWxcbiAqL1xuZXhwb3J0cy5lbGVtZW50cyA9IHtcbiAgICAweDFhNDVkZmEzOiB7XG4gICAgICAgIG5hbWU6ICdlYm1sJyxcbiAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAweDQyODY6IHsgbmFtZTogJ2VibWxWZXJzaW9uJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgMHg0MmY3OiB7IG5hbWU6ICdlYm1sUmVhZFZlcnNpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAweDQyZjI6IHsgbmFtZTogJ2VibWxNYXhJRFdpZHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgMHg0MmYzOiB7IG5hbWU6ICdlYm1sTWF4U2l6ZVdpZHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgMHg0MjgyOiB7IG5hbWU6ICdkb2NUeXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAweDQyODc6IHsgbmFtZTogJ2RvY1R5cGVWZXJzaW9uJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgMHg0Mjg1OiB7IG5hbWU6ICdkb2NUeXBlUmVhZFZlcnNpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0gLy8gNS4xLjdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gTWF0cm9za2Egc2VnbWVudHNcbiAgICAweDE4NTM4MDY3OiB7XG4gICAgICAgIG5hbWU6ICdzZWdtZW50JyxcbiAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAvLyBNZXRhIFNlZWsgSW5mb3JtYXRpb25cbiAgICAgICAgICAgIDB4MTE0ZDliNzQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2Vla0hlYWQnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweDRkYmI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWVrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTNhYjogeyBuYW1lOiAnc2Vla0lkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1M2FjOiB7IG5hbWU6ICdzZWVrUG9zaXRpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTZWdtZW50IEluZm9ybWF0aW9uXG4gICAgICAgICAgICAweDE1NDlhOTY2OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2luZm8nLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweDczYTQ6IHsgbmFtZTogJ3VpZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAweDczODQ6IHsgbmFtZTogJ2ZpbGVuYW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4M2NiOTIzOiB7IG5hbWU6ICdwcmV2VUlEJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4M2M4M2FiOiB7IG5hbWU6ICdwcmV2RmlsZW5hbWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgMHgzZWI5MjM6IHsgbmFtZTogJ25leHRVSUQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHgzZTgzYmI6IHsgbmFtZTogJ25leHRGaWxlbmFtZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAweDJhZDdiMTogeyBuYW1lOiAndGltZWNvZGVTY2FsZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHg0NDg5OiB7IG5hbWU6ICdkdXJhdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmZsb2F0IH0sXG4gICAgICAgICAgICAgICAgICAgIDB4NDQ2MTogeyBuYW1lOiAnZGF0ZVVUQycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHg3YmE5OiB7IG5hbWU6ICd0aXRsZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAweDRkODA6IHsgbmFtZTogJ211eGluZ0FwcCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAweDU3NDE6IHsgbmFtZTogJ3dyaXRpbmdBcHAnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBDbHVzdGVyXG4gICAgICAgICAgICAweDFmNDNiNjc1OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXInLFxuICAgICAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweGU3OiB7IG5hbWU6ICd0aW1lY29kZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAweGEzOiB7IG5hbWU6ICd1bmtub3duJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgIDB4YTc6IHsgbmFtZTogJ3Bvc2l0aW9uJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4YWI6IHsgbmFtZTogJ3ByZXZTaXplJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVHJhY2tcbiAgICAgICAgICAgIDB4MTY1NGFlNmI6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tzJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgMHhhZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2VudHJpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGQ3OiB7IG5hbWU6ICd0cmFja051bWJlcicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDczYzU6IHsgbmFtZTogJ3VpZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODM6IHsgbmFtZTogJ3RyYWNrVHlwZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGI5OiB7IG5hbWU6ICdmbGFnRW5hYmxlZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDg4OiB7IG5hbWU6ICdmbGFnRGVmYXVsdCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDU1YWE6IHsgbmFtZTogJ2ZsYWdGb3JjZWQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5ib29sIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5YzogeyBuYW1lOiAnZmxhZ0xhY2luZycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDZkZTc6IHsgbmFtZTogJ21pbkNhY2hlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NmRlODogeyBuYW1lOiAnbWF4Q2FjaGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyM2UzODM6IHsgbmFtZTogJ2RlZmF1bHREdXJhdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDIzMzE0ZjogeyBuYW1lOiAndGltZWNvZGVTY2FsZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmZsb2F0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MzZlOiB7IG5hbWU6ICduYW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyMmI1OWM6IHsgbmFtZTogJ2xhbmd1YWdlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4NjogeyBuYW1lOiAnY29kZWNJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjNhMjogeyBuYW1lOiAnY29kZWNQcml2YXRlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyNTg2ODg6IHsgbmFtZTogJ2NvZGVjTmFtZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4M2E5Njk3OiB7IG5hbWU6ICdjb2RlY1NldHRpbmdzJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgzYjQwNDA6IHsgbmFtZTogJ2NvZGVjSW5mb1VybCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MjZiMjQwOiB7IG5hbWU6ICdjb2RlY0Rvd25sb2FkVXJsJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhhYTogeyBuYW1lOiAnY29kZWNEZWNvZGVBbGwnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5ib29sIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2ZmFiOiB7IG5hbWU6ICd0cmFja092ZXJsYXknLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGUwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5YTogeyBuYW1lOiAnZmxhZ0ludGVybGFjZWQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5ib29sIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUzYjg6IHsgbmFtZTogJ3N0ZXJlb01vZGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGIwOiB7IG5hbWU6ICdwaXhlbFdpZHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhiYTogeyBuYW1lOiAncGl4ZWxIZWlnaHQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDU0YjA6IHsgbmFtZTogJ2Rpc3BsYXlXaWR0aCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTRiYTogeyBuYW1lOiAnZGlzcGxheUhlaWdodCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTRiMzogeyBuYW1lOiAnYXNwZWN0UmF0aW9UeXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyZWI1MjQ6IHsgbmFtZTogJ2NvbG91clNwYWNlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyZmI1MjM6IHsgbmFtZTogJ2dhbW1hVmFsdWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5mbG9hdCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1ZGlvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhlMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXVkaW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4YjU6IHsgbmFtZTogJ3NhbXBsaW5nRnJlcXVlbmN5JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuZmxvYXQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NzhiNTogeyBuYW1lOiAnb3V0cHV0U2FtcGxpbmdGcmVxdWVuY3knLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5mbG9hdCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5ZjogeyBuYW1lOiAnY2hhbm5lbHMnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDk0OiB7IG5hbWU6ICdjaGFubmVscycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4N2Q3YjogeyBuYW1lOiAnY2hhbm5lbFBvc2l0aW9ucycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJpbmFyeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2MjY0OiB7IG5hbWU6ICdiaXREZXB0aCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50IEVuY29kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2ZDgwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50RW5jb2RpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDYyNDA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29udGVudEVuY29kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MDMxOiB7IG5hbWU6ICdvcmRlcicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MDMyOiB7IG5hbWU6ICdzY29wZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MDMzOiB7IG5hbWU6ICd0eXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUwMzQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50RW5jb2RpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0MjU0OiB7IG5hbWU6ICdjb250ZW50Q29tcEFsZ28nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0MjU1OiB7IG5hbWU6ICdjb250ZW50Q29tcFNldHRpbmdzJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MDM1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29udGVudEVuY29kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDdlMTogeyBuYW1lOiAnY29udGVudEVuY0FsZ28nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0N2UyOiB7IG5hbWU6ICdjb250ZW50RW5jS2V5SUQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ3ZTM6IHsgbmFtZTogJ2NvbnRlbnRTaWduYXR1cmUgJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0N2U0OiB7IG5hbWU6ICdDb250ZW50U2lnS2V5SUQgICcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJpbmFyeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDdlNTogeyBuYW1lOiAnY29udGVudFNpZ0FsZ28gJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDdlNjogeyBuYW1lOiAnY29udGVudFNpZ0hhc2hBbGdvICcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDYyNjQ6IHsgbmFtZTogJ2JpdERlcHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEN1ZWluZyBEYXRhXG4gICAgICAgICAgICAweDFjNTNiYjZiOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2N1ZXMnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweGJiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3VlUG9pbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhiMzogeyBuYW1lOiAnY3VlVGltZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4Yjc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhmNzogeyBuYW1lOiAndHJhY2snLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGYxOiB7IG5hbWU6ICdjbHVzdGVyUG9zaXRpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUzNzg6IHsgbmFtZTogJ2Jsb2NrTnVtYmVyJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhlYTogeyBuYW1lOiAnY29kZWNTdGF0ZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZGI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmZXJlbmNlJywgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4OTY6IHsgbmFtZTogJ3RpbWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4OTc6IHsgbmFtZTogJ2NsdXN0ZXInLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTM1ZjogeyBuYW1lOiAnbnVtYmVyJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGViOiB7IG5hbWU6ICdjb2RlY1N0YXRlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZjA6IHsgbmFtZTogJ3JlbGF0aXZlUG9zaXRpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0gLy8gZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBBdHRhY2htZW50XG4gICAgICAgICAgICAweDE5NDFhNDY5OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2F0dGFjaG1lbnRzJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgMHg2MWE3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXR0YWNoZWRGaWxlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDY3ZTogeyBuYW1lOiAnZGVzY3JpcHRpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ2NmU6IHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ2NjA6IHsgbmFtZTogJ21pbWVUeXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NjVjOiB7IG5hbWU6ICdkYXRhJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NmFlOiB7IG5hbWU6ICd1aWQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIENoYXB0ZXJzXG4gICAgICAgICAgICAweDEwNDNhNzcwOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NoYXB0ZXJzJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgMHg0NWI5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZWRpdGlvbkVudHJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4YjY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NoYXB0ZXJBdG9tJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDczYzQ6IHsgbmFtZTogJ3VpZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5MTogeyBuYW1lOiAndGltZVN0YXJ0JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5MjogeyBuYW1lOiAndGltZUVuZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5ODogeyBuYW1lOiAnaGlkZGVuJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NTk4OiB7IG5hbWU6ICdlbmFibGVkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDhmOiB7IG5hbWU6ICd0cmFjaycsIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDg5OiB7IG5hbWU6ICd0cmFja051bWJlcicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGlzcGxheScsIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODU6IHsgbmFtZTogJ3N0cmluZycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDM3YzogeyBuYW1lOiAnbGFuZ3VhZ2UgJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0MzdlOiB7IG5hbWU6ICdjb3VudHJ5ICcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVGFnZ2luZ1xuICAgICAgICAgICAgMHgxMjU0YzM2Nzoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0YWdzJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgMHg3MzczOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGFnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2MwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0YXJnZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjNjNTogeyBuYW1lOiAndGFnVHJhY2tVSUQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjNjNDogeyBuYW1lOiAndGFnQ2hhcHRlclVJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjNjNjogeyBuYW1lOiAndGFnQXR0YWNobWVudFVJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2NhOiB7IG5hbWU6ICd0YXJnZXRUeXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDY4Y2E6IHsgbmFtZTogJ3RhcmdldFR5cGVWYWx1ZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjNjOTogeyBuYW1lOiAndGFnRWRpdGlvblVJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9IC8vIGV4dGVuZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjdjODoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2ltcGxlVGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDVhMzogeyBuYW1lOiAnbmFtZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NDg3OiB7IG5hbWU6ICdzdHJpbmcnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDQ4NTogeyBuYW1lOiAnYmluYXJ5JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ0N2E6IHsgbmFtZTogJ2xhbmd1YWdlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ0N2I6IHsgbmFtZTogJ2xhbmd1YWdlSUVURicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NDg0OiB7IG5hbWU6ICdkZWZhdWx0JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9IC8vIGV4dGVuZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0cm9za2FEdGQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/matroska/MatroskaDtd.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/matroska/MatroskaParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaParser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatroskaParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/music-metadata/lib/matroska/types.js\");\nconst matroskaDtd = __webpack_require__(/*! ./MatroskaDtd */ \"./node_modules/music-metadata/lib/matroska/MatroskaDtd.js\");\nconst debug = _debug('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n    constructor() {\n        super();\n        this.padding = 0;\n        this.parserMap = new Map();\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        return this;\n    }\n    async parse() {\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n        if (matroska.segment) {\n            const info = matroska.segment.info;\n            if (info) {\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n                const duration = info.duration * timecodeScale / 1000000000;\n                this.addTag('segment:title', info.title);\n                this.metadata.setFormat('duration', duration);\n            }\n            const audioTracks = matroska.segment.tracks;\n            if (audioTracks && audioTracks.entries) {\n                audioTracks.entries.forEach(entry => {\n                    const stream = {\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                        codecSettings: entry.codecSettings,\n                        flagDefault: entry.flagDefault,\n                        flagLacing: entry.flagLacing,\n                        flagEnabled: entry.flagEnabled,\n                        language: entry.language,\n                        name: entry.name,\n                        type: entry.trackType,\n                        audio: entry.audio,\n                        video: entry.video\n                    };\n                    this.metadata.addStreamInfo(stream);\n                });\n                const audioTrack = audioTracks.entries\n                    .filter(entry => {\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\n                })\n                    .reduce((acc, cur) => {\n                    if (!acc) {\n                        return cur;\n                    }\n                    if (!acc.flagDefault && cur.flagDefault) {\n                        return cur;\n                    }\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n                        return cur;\n                    }\n                    return acc;\n                }, null);\n                if (audioTrack) {\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                }\n                if (matroska.segment.tags) {\n                    matroska.segment.tags.tag.forEach(tag => {\n                        const target = tag.target;\n                        const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : (target.targetType ? target.targetType : types_1.TargetType.album);\n                        tag.simpleTags.forEach(simpleTag => {\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\n                        });\n                    });\n                }\n                if (matroska.segment.attachments) {\n                    matroska.segment.attachments.attachedFiles\n                        .filter(file => file.mimeType.startsWith('image/'))\n                        .map(file => {\n                        return {\n                            data: file.data,\n                            format: file.mimeType,\n                            description: file.description,\n                            name: file.name\n                        };\n                    }).forEach(picture => {\n                        this.addTag('picture', picture);\n                    });\n                }\n            }\n        }\n    }\n    async parseContainer(container, posDone, path) {\n        const tree = {};\n        while (this.tokenizer.position < posDone) {\n            const element = await this.readElement();\n            const type = container[element.id];\n            if (type) {\n                if (type.container) {\n                    const res = await this.parseContainer(type.container, this.tokenizer.position + element.len, path.concat([type.name]));\n                    if (type.multiple) {\n                        if (!tree[type.name]) {\n                            tree[type.name] = [];\n                        }\n                        tree[type.name].push(res);\n                    }\n                    else {\n                        tree[type.name] = res;\n                    }\n                }\n                else {\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\n                }\n            }\n            else {\n                switch (element.id) {\n                    case 0xec: // void\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                        break;\n                    default:\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                }\n            }\n        }\n        return tree;\n    }\n    async readVintData() {\n        const msb = await this.tokenizer.peekNumber(Token.UINT8);\n        let mask = 0x80;\n        let ic = 1;\n        // Calculate VINT_WIDTH\n        while ((msb & mask) === 0) {\n            ++ic;\n            mask >>= 1;\n        }\n        const id = Buffer.alloc(ic);\n        await this.tokenizer.readBuffer(id);\n        return id;\n    }\n    async readElement() {\n        const id = await this.readVintData();\n        const lenField = await this.readVintData();\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n        return {\n            id: id.readUIntBE(0, id.length),\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n        };\n    }\n    async readFloat(e) {\n        switch (e.len) {\n            case 0:\n                return 0.0;\n            case 4:\n                return this.tokenizer.readNumber(Token.Float32_BE);\n            case 8:\n                return this.tokenizer.readNumber(Token.Float64_BE);\n            case 10:\n                return this.tokenizer.readNumber(Token.Float64_BE);\n            default:\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n        }\n    }\n    async readFlag(e) {\n        return (await this.readUint(e)) === 1;\n    }\n    async readUint(e) {\n        const buf = await this.readBuffer(e);\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n        return buf.readUIntBE(e.len - nrLen, nrLen);\n    }\n    async readString(e) {\n        return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\n    }\n    async readBuffer(e) {\n        const buf = Buffer.alloc(e.len);\n        await this.tokenizer.readBuffer(buf);\n        return buf;\n    }\n    addTag(tagId, value) {\n        this.metadata.addTag('matroska', tagId, value);\n    }\n}\nexports.MatroskaParser = MatroskaParser;\n//# sourceMappingURL=MatroskaParser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL01hdHJvc2thUGFyc2VyLmpzPzczYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsOEVBQU87QUFDOUIsc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxXQUFXO0FBQzFCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxHQUFHLGVBQWU7QUFDeEUseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlLHdCQUF3Qix3QkFBd0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL01hdHJvc2thUGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hdHJvc2thUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBfZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IG1hdHJvc2thRHRkID0gcmVxdWlyZShcIi4vTWF0cm9za2FEdGRcIik7XG5jb25zdCBkZWJ1ZyA9IF9kZWJ1ZygnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOm1hdHJvc2thJyk7XG4vKipcbiAqIEV4dGVuc2libGUgQmluYXJ5IE1ldGEgTGFuZ3VhZ2UgKEVCTUwpIHBhcnNlclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5zaWJsZV9CaW5hcnlfTWV0YV9MYW5ndWFnZVxuICogaHR0cDovL21hdHJvc2thLnNvdXJjZWZvcmdlLm5ldC90ZWNobmljYWwvc3BlY3MvcmZjL2luZGV4Lmh0bWxcbiAqXG4gKiBXRUJNIFZQOCBBVURJTyBGSUxFXG4gKi9cbmNsYXNzIE1hdHJvc2thUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgICAgIHRoaXMucGFyc2VyTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS51aW50LCBlID0+IHRoaXMucmVhZFVpbnQoZSkpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcsIGUgPT4gdGhpcy5yZWFkU3RyaW5nKGUpKTtcbiAgICAgICAgdGhpcy5wYXJzZXJNYXAuc2V0KHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5LCBlID0+IHRoaXMucmVhZEJ1ZmZlcihlKSk7XG4gICAgICAgIHRoaXMucGFyc2VyTWFwLnNldCh0eXBlc18xLkRhdGFUeXBlLnVpZCwgYXN5bmMgKGUpID0+IGF3YWl0IHRoaXMucmVhZFVpbnQoZSkgPT09IDEpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5ib29sLCBlID0+IHRoaXMucmVhZEZsYWcoZSkpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5mbG9hdCwgZSA9PiB0aGlzLnJlYWRGbG9hdChlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcGFyc2VyIHdpdGggb3V0cHV0IChtZXRhZGF0YSksIGlucHV0ICh0b2tlbml6ZXIpICYgcGFyc2luZyBvcHRpb25zIChvcHRpb25zKS5cbiAgICAgKiBAcGFyYW0ge0lOYXRpdmVNZXRhZGF0YUNvbGxlY3Rvcn0gbWV0YWRhdGEgT3V0cHV0XG4gICAgICogQHBhcmFtIHtJVG9rZW5pemVyfSB0b2tlbml6ZXIgSW5wdXRcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zIFBhcnNpbmcgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5pbml0KG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IG1hdHJvc2thID0gYXdhaXQgdGhpcy5wYXJzZUNvbnRhaW5lcihtYXRyb3NrYUR0ZC5lbGVtZW50cywgdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSwgW10pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgYEVCTUwvJHttYXRyb3NrYS5lYm1sLmRvY1R5cGV9YCk7XG4gICAgICAgIGlmIChtYXRyb3NrYS5zZWdtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gbWF0cm9za2Euc2VnbWVudC5pbmZvO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lY29kZVNjYWxlID0gaW5mby50aW1lY29kZVNjYWxlID8gaW5mby50aW1lY29kZVNjYWxlIDogMTAwMDAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGluZm8uZHVyYXRpb24gKiB0aW1lY29kZVNjYWxlIC8gMTAwMDAwMDAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZygnc2VnbWVudDp0aXRsZScsIGluZm8udGl0bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gbWF0cm9za2Euc2VnbWVudC50cmFja3M7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFja3MgJiYgYXVkaW9UcmFja3MuZW50cmllcykge1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjTmFtZTogZW50cnkuY29kZWNJRC5yZXBsYWNlKCdBXycsICcnKS5yZXBsYWNlKCdWXycsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjU2V0dGluZ3M6IGVudHJ5LmNvZGVjU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnRGVmYXVsdDogZW50cnkuZmxhZ0RlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnTGFjaW5nOiBlbnRyeS5mbGFnTGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ0VuYWJsZWQ6IGVudHJ5LmZsYWdFbmFibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGVudHJ5Lmxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBlbnRyeS5hdWRpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvOiBlbnRyeS52aWRlb1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFN0cmVhbUluZm8oc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gYXVkaW9UcmFja3MuZW50cmllc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnRyYWNrVHlwZSA9PT0gdHlwZXNfMS5UcmFja1R5cGUuYXVkaW8udmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWNjLmZsYWdEZWZhdWx0ICYmIGN1ci5mbGFnRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLnRyYWNrTnVtYmVyICYmIGN1ci50cmFja051bWJlciA8IGFjYy50cmFja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIGF1ZGlvVHJhY2suY29kZWNJRC5yZXBsYWNlKCdBXycsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgYXVkaW9UcmFjay5hdWRpby5zYW1wbGluZ0ZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgYXVkaW9UcmFjay5hdWRpby5jaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRyb3NrYS5zZWdtZW50LnRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cm9za2Euc2VnbWVudC50YWdzLnRhZy5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YWcudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHRhcmdldC50YXJnZXRUeXBlVmFsdWUgPyB0eXBlc18xLlRhcmdldFR5cGVbdGFyZ2V0LnRhcmdldFR5cGVWYWx1ZV0gOiAodGFyZ2V0LnRhcmdldFR5cGUgPyB0YXJnZXQudGFyZ2V0VHlwZSA6IHR5cGVzXzEuVGFyZ2V0VHlwZS5hbGJ1bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcuc2ltcGxlVGFncy5mb3JFYWNoKHNpbXBsZVRhZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzaW1wbGVUYWcuc3RyaW5nID8gc2ltcGxlVGFnLnN0cmluZyA6IHNpbXBsZVRhZy5iaW5hcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcoYCR7dGFyZ2V0VHlwZX06JHtzaW1wbGVUYWcubmFtZX1gLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRyb3NrYS5zZWdtZW50LmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJvc2thLnNlZ21lbnQuYXR0YWNobWVudHMuYXR0YWNoZWRGaWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmaWxlID0+IGZpbGUubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmaWxlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmaWxlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmaWxlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZm9yRWFjaChwaWN0dXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKCdwaWN0dXJlJywgcGljdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZUNvbnRhaW5lcihjb250YWluZXIsIHBvc0RvbmUsIHBhdGgpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IHt9O1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlbml6ZXIucG9zaXRpb24gPCBwb3NEb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gYXdhaXQgdGhpcy5yZWFkRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNvbnRhaW5lcltlbGVtZW50LmlkXTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucGFyc2VDb250YWluZXIodHlwZS5jb250YWluZXIsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uICsgZWxlbWVudC5sZW4sIHBhdGguY29uY2F0KFt0eXBlLm5hbWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyZWVbdHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHlwZS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVt0eXBlLm5hbWVdLnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHlwZS5uYW1lXSA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJlZVt0eXBlLm5hbWVdID0gYXdhaXQgdGhpcy5wYXJzZXJNYXAuZ2V0KHR5cGUudmFsdWUpKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4ZWM6IC8vIHZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFkZGluZyArPSBlbGVtZW50LmxlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShlbGVtZW50Lmxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKGBwYXJzZUVibWw6IHBhdGg9JHtwYXRoLmpvaW4oJy8nKX0sIHVua25vd24gZWxlbWVudDogaWQ9JHtlbGVtZW50LmlkLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFkZGluZyArPSBlbGVtZW50LmxlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShlbGVtZW50Lmxlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICBhc3luYyByZWFkVmludERhdGEoKSB7XG4gICAgICAgIGNvbnN0IG1zYiA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtOdW1iZXIoVG9rZW4uVUlOVDgpO1xuICAgICAgICBsZXQgbWFzayA9IDB4ODA7XG4gICAgICAgIGxldCBpYyA9IDE7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBWSU5UX1dJRFRIXG4gICAgICAgIHdoaWxlICgobXNiICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgICAgICsraWM7XG4gICAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gQnVmZmVyLmFsbG9jKGljKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihpZCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgdGhpcy5yZWFkVmludERhdGEoKTtcbiAgICAgICAgY29uc3QgbGVuRmllbGQgPSBhd2FpdCB0aGlzLnJlYWRWaW50RGF0YSgpO1xuICAgICAgICBsZW5GaWVsZFswXSBePSAweDgwID4+IChsZW5GaWVsZC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgbnJMZW4gPSBNYXRoLm1pbig2LCBsZW5GaWVsZC5sZW5ndGgpOyAvLyBKYXZhU2NyaXB0IGNhbiBtYXggcmVhZCA2IGJ5dGVzIGludGVnZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZC5yZWFkVUludEJFKDAsIGlkLmxlbmd0aCksXG4gICAgICAgICAgICBsZW46IGxlbkZpZWxkLnJlYWRVSW50QkUobGVuRmllbGQubGVuZ3RoIC0gbnJMZW4sIG5yTGVuKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyByZWFkRmxvYXQoZSkge1xuICAgICAgICBzd2l0Y2ggKGUubGVuKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5GbG9hdDMyX0JFKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5GbG9hdDY0X0JFKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlYWROdW1iZXIoVG9rZW4uRmxvYXQ2NF9CRSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJRUVFLTc1NCBmbG9hdCBsZW5ndGg6ICR7ZS5sZW59YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZEZsYWcoZSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVhZFVpbnQoZSkpID09PSAxO1xuICAgIH1cbiAgICBhc3luYyByZWFkVWludChlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMucmVhZEJ1ZmZlcihlKTtcbiAgICAgICAgY29uc3QgbnJMZW4gPSBNYXRoLm1pbig2LCBlLmxlbik7IC8vIEphdmFTY3JpcHQgY2FuIG1heCByZWFkIDYgYnl0ZXMgaW50ZWdlclxuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50QkUoZS5sZW4gLSBuckxlbiwgbnJMZW4pO1xuICAgIH1cbiAgICBhc3luYyByZWFkU3RyaW5nKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShlLmxlbiwgJ3V0Zi04JykpO1xuICAgIH1cbiAgICBhc3luYyByZWFkQnVmZmVyKGUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGUubGVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihidWYpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBhZGRUYWcodGFnSWQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuYWRkVGFnKCdtYXRyb3NrYScsIHRhZ0lkLCB2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NYXRyb3NrYVBhcnNlciA9IE1hdHJvc2thUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0cm9za2FQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/matroska/MatroskaParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatroskaTagMapper = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * EBML Tag map\n */\nconst ebmlTagMap = {\n    'segment:title': 'title',\n    'album:ARITST': 'albumartist',\n    'album:ARITSTSORT': 'albumartistsort',\n    'album:TITLE': 'album',\n    'album:DATE_RECORDED': 'originaldate',\n    'track:ARTIST': 'artist',\n    'track:ARTISTSORT': 'artistsort',\n    'track:TITLE': 'title',\n    'track:PART_NUMBER': 'track',\n    'track:MUSICBRAINZ_TRACKID': 'musicbrainz_recordingid',\n    'track:MUSICBRAINZ_ALBUMID': 'musicbrainz_albumid',\n    'track:MUSICBRAINZ_ARTISTID': 'musicbrainz_artistid',\n    'track:PUBLISHER': 'label',\n    picture: 'picture'\n};\nclass MatroskaTagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['matroska'], ebmlTagMap);\n    }\n}\nexports.MatroskaTagMapper = MatroskaTagMapper;\n//# sourceMappingURL=MatroskaTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL01hdHJvc2thVGFnTWFwcGVyLmpzPzdlMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDBHQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tYXRyb3NrYS9NYXRyb3NrYVRhZ01hcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRyb3NrYVRhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIEVCTUwgVGFnIG1hcFxuICovXG5jb25zdCBlYm1sVGFnTWFwID0ge1xuICAgICdzZWdtZW50OnRpdGxlJzogJ3RpdGxlJyxcbiAgICAnYWxidW06QVJJVFNUJzogJ2FsYnVtYXJ0aXN0JyxcbiAgICAnYWxidW06QVJJVFNUU09SVCc6ICdhbGJ1bWFydGlzdHNvcnQnLFxuICAgICdhbGJ1bTpUSVRMRSc6ICdhbGJ1bScsXG4gICAgJ2FsYnVtOkRBVEVfUkVDT1JERUQnOiAnb3JpZ2luYWxkYXRlJyxcbiAgICAndHJhY2s6QVJUSVNUJzogJ2FydGlzdCcsXG4gICAgJ3RyYWNrOkFSVElTVFNPUlQnOiAnYXJ0aXN0c29ydCcsXG4gICAgJ3RyYWNrOlRJVExFJzogJ3RpdGxlJyxcbiAgICAndHJhY2s6UEFSVF9OVU1CRVInOiAndHJhY2snLFxuICAgICd0cmFjazpNVVNJQ0JSQUlOWl9UUkFDS0lEJzogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICAndHJhY2s6TVVTSUNCUkFJTlpfQUxCVU1JRCc6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICAndHJhY2s6TVVTSUNCUkFJTlpfQVJUSVNUSUQnOiAnbXVzaWNicmFpbnpfYXJ0aXN0aWQnLFxuICAgICd0cmFjazpQVUJMSVNIRVInOiAnbGFiZWwnLFxuICAgIHBpY3R1cmU6ICdwaWN0dXJlJ1xufTtcbmNsYXNzIE1hdHJvc2thVGFnTWFwcGVyIGV4dGVuZHMgQ2FzZUluc2Vuc2l0aXZlVGFnTWFwXzEuQ2FzZUluc2Vuc2l0aXZlVGFnTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoWydtYXRyb3NrYSddLCBlYm1sVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLk1hdHJvc2thVGFnTWFwcGVyID0gTWF0cm9za2FUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyb3NrYVRhZ01hcHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/matroska/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/types.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrackType = exports.TargetType = exports.DataType = void 0;\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"string\"] = 0] = \"string\";\n    DataType[DataType[\"uint\"] = 1] = \"uint\";\n    DataType[DataType[\"uid\"] = 2] = \"uid\";\n    DataType[DataType[\"bool\"] = 3] = \"bool\";\n    DataType[DataType[\"binary\"] = 4] = \"binary\";\n    DataType[DataType[\"float\"] = 5] = \"float\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nvar TargetType;\n(function (TargetType) {\n    TargetType[TargetType[\"shot\"] = 10] = \"shot\";\n    TargetType[TargetType[\"scene\"] = 20] = \"scene\";\n    TargetType[TargetType[\"track\"] = 30] = \"track\";\n    TargetType[TargetType[\"part\"] = 40] = \"part\";\n    TargetType[TargetType[\"album\"] = 50] = \"album\";\n    TargetType[TargetType[\"edition\"] = 60] = \"edition\";\n    TargetType[TargetType[\"collection\"] = 70] = \"collection\";\n})(TargetType = exports.TargetType || (exports.TargetType = {}));\nvar TrackType;\n(function (TrackType) {\n    TrackType[TrackType[\"video\"] = 1] = \"video\";\n    TrackType[TrackType[\"audio\"] = 2] = \"audio\";\n    TrackType[TrackType[\"complex\"] = 3] = \"complex\";\n    TrackType[TrackType[\"logo\"] = 4] = \"logo\";\n    TrackType[TrackType[\"subtitle\"] = 17] = \"subtitle\";\n    TrackType[TrackType[\"button\"] = 18] = \"button\";\n    TrackType[TrackType[\"control\"] = 32] = \"control\";\n})(TrackType = exports.TrackType || (exports.TrackType = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL3R5cGVzLmpzPzMxZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVEQUF1RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZEQUE2RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbWF0cm9za2EvdHlwZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhY2tUeXBlID0gZXhwb3J0cy5UYXJnZXRUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcInN0cmluZ1wiXSA9IDBdID0gXCJzdHJpbmdcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcInVpbnRcIl0gPSAxXSA9IFwidWludFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1widWlkXCJdID0gMl0gPSBcInVpZFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiYm9vbFwiXSA9IDNdID0gXCJib29sXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJiaW5hcnlcIl0gPSA0XSA9IFwiYmluYXJ5XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJmbG9hdFwiXSA9IDVdID0gXCJmbG9hdFwiO1xufSkoRGF0YVR5cGUgPSBleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcbnZhciBUYXJnZXRUeXBlO1xuKGZ1bmN0aW9uIChUYXJnZXRUeXBlKSB7XG4gICAgVGFyZ2V0VHlwZVtUYXJnZXRUeXBlW1wic2hvdFwiXSA9IDEwXSA9IFwic2hvdFwiO1xuICAgIFRhcmdldFR5cGVbVGFyZ2V0VHlwZVtcInNjZW5lXCJdID0gMjBdID0gXCJzY2VuZVwiO1xuICAgIFRhcmdldFR5cGVbVGFyZ2V0VHlwZVtcInRyYWNrXCJdID0gMzBdID0gXCJ0cmFja1wiO1xuICAgIFRhcmdldFR5cGVbVGFyZ2V0VHlwZVtcInBhcnRcIl0gPSA0MF0gPSBcInBhcnRcIjtcbiAgICBUYXJnZXRUeXBlW1RhcmdldFR5cGVbXCJhbGJ1bVwiXSA9IDUwXSA9IFwiYWxidW1cIjtcbiAgICBUYXJnZXRUeXBlW1RhcmdldFR5cGVbXCJlZGl0aW9uXCJdID0gNjBdID0gXCJlZGl0aW9uXCI7XG4gICAgVGFyZ2V0VHlwZVtUYXJnZXRUeXBlW1wiY29sbGVjdGlvblwiXSA9IDcwXSA9IFwiY29sbGVjdGlvblwiO1xufSkoVGFyZ2V0VHlwZSA9IGV4cG9ydHMuVGFyZ2V0VHlwZSB8fCAoZXhwb3J0cy5UYXJnZXRUeXBlID0ge30pKTtcbnZhciBUcmFja1R5cGU7XG4oZnVuY3Rpb24gKFRyYWNrVHlwZSkge1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJ2aWRlb1wiXSA9IDFdID0gXCJ2aWRlb1wiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJhdWRpb1wiXSA9IDJdID0gXCJhdWRpb1wiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJjb21wbGV4XCJdID0gM10gPSBcImNvbXBsZXhcIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wibG9nb1wiXSA9IDRdID0gXCJsb2dvXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcInN1YnRpdGxlXCJdID0gMTddID0gXCJzdWJ0aXRsZVwiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJidXR0b25cIl0gPSAxOF0gPSBcImJ1dHRvblwiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJjb250cm9sXCJdID0gMzJdID0gXCJjb250cm9sXCI7XG59KShUcmFja1R5cGUgPSBleHBvcnRzLlRyYWNrVHlwZSB8fCAoZXhwb3J0cy5UcmFja1R5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/matroska/types.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/Atom.js":
/*!*****************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/Atom.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Atom = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst AtomToken = __webpack_require__(/*! ./AtomToken */ \"./node_modules/music-metadata/lib/mp4/AtomToken.js\");\nconst debug = initDebug('music-metadata:parser:MP4:Atom');\nclass Atom {\n    constructor(header, extended, parent) {\n        this.header = header;\n        this.extended = extended;\n        this.parent = parent;\n        this.children = [];\n        this.atomPath = (this.parent ? this.parent.atomPath + '.' : '') + this.header.name;\n    }\n    static async readAtom(tokenizer, dataHandler, parent) {\n        // Parse atom header\n        const offset = tokenizer.position;\n        // debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\n        const header = await tokenizer.readToken(AtomToken.Header);\n        const extended = header.length === 1;\n        if (extended) {\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\n        }\n        const extendToEOF = ((header.length === 0) && (header.name === 'mdat') && !parent);\n        if (extendToEOF) {\n            header.length = tokenizer.fileInfo.size - tokenizer.position + 8;\n        }\n        const atomBean = new Atom(header, extended, parent);\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\n        await atomBean.readData(tokenizer, dataHandler);\n        return atomBean;\n    }\n    getHeaderLength() {\n        return this.extended ? 16 : 8;\n    }\n    getPayloadLength() {\n        return this.header.length - this.getHeaderLength();\n    }\n    async readAtoms(tokenizer, dataHandler, size) {\n        while (size > 0) {\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this);\n            this.children.push(atomBean);\n            size -= atomBean.header.length;\n        }\n    }\n    async readData(tokenizer, dataHandler) {\n        switch (this.header.name) {\n            // \"Container\" atoms, contains nested atoms\n            case 'moov': // The Movie Atom: contains other atoms\n            case 'udta': // User defined atom\n            case 'trak':\n            case 'mdia': // Media atom\n            case 'minf': // Media Information Atom\n            case 'stbl': // The Sample Table Atom\n            case '<id>':\n            case 'ilst':\n            case 'tref':\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength());\n            case 'meta': // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n                // meta has 4 bytes of padding, ignore\n                await tokenizer.ignore(4);\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength() - 4);\n            case 'mdhd': // Media header atom\n            case 'mvhd': // 'movie' => 'mvhd': movie header atom; child of Movie Atom\n            case 'tkhd':\n            case 'stsz':\n            case 'mdat':\n            default:\n                return dataHandler(this);\n        }\n    }\n}\nexports.Atom = Atom;\n//# sourceMappingURL=Atom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wNC9BdG9tLmpzP2JlZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCLGFBQWEsa0JBQWtCLFdBQVcsT0FBTyxRQUFRLHVCQUF1QixHQUFHO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcDQvQXRvbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdG9tID0gdm9pZCAwO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgQXRvbVRva2VuID0gcmVxdWlyZShcIi4vQXRvbVRva2VuXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpNUDQ6QXRvbScpO1xuY2xhc3MgQXRvbSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyLCBleHRlbmRlZCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gZXh0ZW5kZWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuYXRvbVBhdGggPSAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5hdG9tUGF0aCArICcuJyA6ICcnKSArIHRoaXMuaGVhZGVyLm5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyByZWFkQXRvbSh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCBwYXJlbnQpIHtcbiAgICAgICAgLy8gUGFyc2UgYXRvbSBoZWFkZXJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICAvLyBkZWJ1ZyhgUmVhZGluZyBuZXh0IHRva2VuIG9uIG9mZnNldD0ke29mZnNldH0uLi5gKTsgLy8gIGJ1Zi50b1N0cmluZygnYXNjaWknKVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKEF0b21Ub2tlbi5IZWFkZXIpO1xuICAgICAgICBjb25zdCBleHRlbmRlZCA9IGhlYWRlci5sZW5ndGggPT09IDE7XG4gICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgaGVhZGVyLmxlbmd0aCA9IGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4oQXRvbVRva2VuLkV4dGVuZGVkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5kVG9FT0YgPSAoKGhlYWRlci5sZW5ndGggPT09IDApICYmIChoZWFkZXIubmFtZSA9PT0gJ21kYXQnKSAmJiAhcGFyZW50KTtcbiAgICAgICAgaWYgKGV4dGVuZFRvRU9GKSB7XG4gICAgICAgICAgICBoZWFkZXIubGVuZ3RoID0gdG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0b2tlbml6ZXIucG9zaXRpb24gKyA4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0b21CZWFuID0gbmV3IEF0b20oaGVhZGVyLCBleHRlbmRlZCwgcGFyZW50KTtcbiAgICAgICAgZGVidWcoYHBhcnNlIGF0b20gbmFtZT0ke2F0b21CZWFuLmF0b21QYXRofSwgZXh0ZW5kZWQ9JHthdG9tQmVhbi5leHRlbmRlZH0sIG9mZnNldD0ke29mZnNldH0sIGxlbj0ke2F0b21CZWFuLmhlYWRlci5sZW5ndGh9YCk7IC8vICBidWYudG9TdHJpbmcoJ2FzY2lpJylcbiAgICAgICAgYXdhaXQgYXRvbUJlYW4ucmVhZERhdGEodG9rZW5pemVyLCBkYXRhSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBhdG9tQmVhbjtcbiAgICB9XG4gICAgZ2V0SGVhZGVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRlZCA/IDE2IDogODtcbiAgICB9XG4gICAgZ2V0UGF5bG9hZExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyLmxlbmd0aCAtIHRoaXMuZ2V0SGVhZGVyTGVuZ3RoKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRBdG9tcyh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCBzaXplKSB7XG4gICAgICAgIHdoaWxlIChzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXRvbUJlYW4gPSBhd2FpdCBBdG9tLnJlYWRBdG9tKHRva2VuaXplciwgZGF0YUhhbmRsZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGF0b21CZWFuKTtcbiAgICAgICAgICAgIHNpemUgLT0gYXRvbUJlYW4uaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YSh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5oZWFkZXIubmFtZSkge1xuICAgICAgICAgICAgLy8gXCJDb250YWluZXJcIiBhdG9tcywgY29udGFpbnMgbmVzdGVkIGF0b21zXG4gICAgICAgICAgICBjYXNlICdtb292JzogLy8gVGhlIE1vdmllIEF0b206IGNvbnRhaW5zIG90aGVyIGF0b21zXG4gICAgICAgICAgICBjYXNlICd1ZHRhJzogLy8gVXNlciBkZWZpbmVkIGF0b21cbiAgICAgICAgICAgIGNhc2UgJ3RyYWsnOlxuICAgICAgICAgICAgY2FzZSAnbWRpYSc6IC8vIE1lZGlhIGF0b21cbiAgICAgICAgICAgIGNhc2UgJ21pbmYnOiAvLyBNZWRpYSBJbmZvcm1hdGlvbiBBdG9tXG4gICAgICAgICAgICBjYXNlICdzdGJsJzogLy8gVGhlIFNhbXBsZSBUYWJsZSBBdG9tXG4gICAgICAgICAgICBjYXNlICc8aWQ+JzpcbiAgICAgICAgICAgIGNhc2UgJ2lsc3QnOlxuICAgICAgICAgICAgY2FzZSAndHJlZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEF0b21zKHRva2VuaXplciwgZGF0YUhhbmRsZXIsIHRoaXMuZ2V0UGF5bG9hZExlbmd0aCgpKTtcbiAgICAgICAgICAgIGNhc2UgJ21ldGEnOiAvLyBNZXRhZGF0YSBBdG9tLCByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1c4XG4gICAgICAgICAgICAgICAgLy8gbWV0YSBoYXMgNCBieXRlcyBvZiBwYWRkaW5nLCBpZ25vcmVcbiAgICAgICAgICAgICAgICBhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRBdG9tcyh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCB0aGlzLmdldFBheWxvYWRMZW5ndGgoKSAtIDQpO1xuICAgICAgICAgICAgY2FzZSAnbWRoZCc6IC8vIE1lZGlhIGhlYWRlciBhdG9tXG4gICAgICAgICAgICBjYXNlICdtdmhkJzogLy8gJ21vdmllJyA9PiAnbXZoZCc6IG1vdmllIGhlYWRlciBhdG9tOyBjaGlsZCBvZiBNb3ZpZSBBdG9tXG4gICAgICAgICAgICBjYXNlICd0a2hkJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0c3onOlxuICAgICAgICAgICAgY2FzZSAnbWRhdCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSGFuZGxlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXRvbSA9IEF0b207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdG9tLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mp4/Atom.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/AtomToken.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/AtomToken.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChapterText = exports.StcoAtom = exports.StszAtom = exports.StscAtom = exports.SampleToChunkToken = exports.SttsAtom = exports.TimeToSampleToken = exports.SoundSampleDescriptionV0 = exports.SoundSampleDescriptionVersion = exports.StsdAtom = exports.TrackHeaderAtom = exports.NameAtom = exports.DataAtom = exports.MvhdAtom = exports.MdhdAtom = exports.FixedLengthAtom = exports.mhdr = exports.tkhd = exports.ftyp = exports.ExtendedSize = exports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst debug = initDebug('music-metadata:parser:MP4:atom');\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        const length = Token.UINT32_BE.get(buf, off);\n        if (length < 0)\n            throw new Error('Invalid atom header length');\n        return {\n            length,\n            name: new Token.StringType(4, 'binary').get(buf, off + 4)\n        };\n    },\n    put: (buf, off, hdr) => {\n        Token.UINT32_BE.put(buf, off, hdr.length);\n        return FourCC_1.FourCcToken.put(buf, off + 4, hdr.name);\n    }\n};\n/**\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\n */\nexports.ExtendedSize = Token.UINT64_BE;\nexports.ftyp = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\nexports.tkhd = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\n/**\n * Token: Movie Header Atom\n */\nexports.mhdr = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Base class for 'fixed' length atoms.\n * In some cases these atoms are longer then the sum of the described fields.\n * Issue: https://github.com/Borewit/music-metadata/issues/120\n */\nclass FixedLengthAtom {\n    /**\n     *\n     * @param {number} len Length as specified in the size field\n     * @param {number} expLen Total length of sum of specified fields in the standard\n     */\n    constructor(len, expLen, atomId) {\n        this.len = len;\n        if (len < expLen) {\n            throw new Error(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\n        }\n        else if (len > expLen) {\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\n        }\n    }\n}\nexports.FixedLengthAtom = FixedLengthAtom;\n/**\n * Token: Media Header Atom\n * Ref:\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\n *   https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\n */\nclass MdhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 24, 'mdhd');\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: Token.UINT32_BE.get(buf, off + 4),\n            modificationTime: Token.UINT32_BE.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            language: Token.UINT16_BE.get(buf, off + 20),\n            quality: Token.UINT16_BE.get(buf, off + 22)\n        };\n    }\n}\nexports.MdhdAtom = MdhdAtom;\n/**\n * Token: Movie Header Atom\n */\nclass MvhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 100, 'mvhd');\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: Token.UINT32_BE.get(buf, off + 4),\n            modificationTime: Token.UINT32_BE.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\n            // ignore reserver: 10 bytes\n            // ignore matrix structure: 36 bytes\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\n        };\n    }\n}\nexports.MvhdAtom = MvhdAtom;\n/**\n * Data Atom Structure\n */\nclass DataAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            type: {\n                set: Token.UINT8.get(buf, off + 0),\n                type: Token.UINT24_BE.get(buf, off + 1)\n            },\n            locale: Token.UINT24_BE.get(buf, off + 4),\n            value: new Token.BufferType(this.len - 8).get(buf, off + 8)\n        };\n    }\n}\nexports.DataAtom = DataAtom;\n/**\n * Data Atom Structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\n */\nclass NameAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\n        };\n    }\n}\nexports.NameAtom = NameAtom;\n/**\n * Track Header Atoms structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\n */\nclass TrackHeaderAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: Token.UINT32_BE.get(buf, off + 4),\n            modificationTime: Token.UINT32_BE.get(buf, off + 8),\n            trackId: Token.UINT32_BE.get(buf, off + 12),\n            // reserved 4 bytes\n            duration: Token.UINT32_BE.get(buf, off + 20),\n            layer: Token.UINT16_BE.get(buf, off + 24),\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\n            // ToDo: add remaining fields\n        };\n    }\n}\nexports.TrackHeaderAtom = TrackHeaderAtom;\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nconst stsdHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nclass SampleDescriptionTable {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            dataFormat: FourCC_1.FourCcToken.get(buf, off),\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\n            description: new Token.BufferType(this.len - 12).get(buf, off + 12)\n        };\n    }\n}\n/**\n * Atom: Sample-description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nclass StsdAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const header = stsdHeader.get(buf, off);\n        off += stsdHeader.len;\n        const table = [];\n        for (let n = 0; n < header.numberOfEntries; ++n) {\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\n            off += Token.UINT32_BE.len;\n            table.push(new SampleDescriptionTable(size).get(buf, off));\n            off += size;\n        }\n        return {\n            header,\n            table\n        };\n    }\n}\nexports.StsdAtom = StsdAtom;\n/**\n * Common Sound Sample Description (version & revision)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\n */\nexports.SoundSampleDescriptionVersion = {\n    len: 8,\n    get(buf, off) {\n        return {\n            version: Token.INT16_BE.get(buf, off),\n            revision: Token.INT16_BE.get(buf, off + 2),\n            vendor: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Sound Sample Description (Version 0)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\n */\nexports.SoundSampleDescriptionV0 = {\n    len: 12,\n    get(buf, off) {\n        return {\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\n            compressionId: Token.INT16_BE.get(buf, off + 4),\n            packetSize: Token.INT16_BE.get(buf, off + 6),\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\n        };\n    }\n};\nclass SimpleTableAtom {\n    constructor(len, token) {\n        this.len = len;\n        this.token = token;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\n        return {\n            version: Token.INT8.get(buf, off + 0),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\n        };\n    }\n}\nexports.TimeToSampleToken = {\n    len: 8,\n    get(buf, off) {\n        return {\n            count: Token.INT32_BE.get(buf, off + 0),\n            duration: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Time-to-sample('stts') atom.\n * Store duration information for a media’s samples.\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\n */\nclass SttsAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, exports.TimeToSampleToken);\n        this.len = len;\n    }\n}\nexports.SttsAtom = SttsAtom;\nexports.SampleToChunkToken = {\n    len: 12,\n    get(buf, off) {\n        return {\n            firstChunk: Token.INT32_BE.get(buf, off),\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\n        };\n    }\n};\n/**\n * Sample-to-Chunk ('stsc') atom interface\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\n */\nclass StscAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, exports.SampleToChunkToken);\n        this.len = len;\n    }\n}\nexports.StscAtom = StscAtom;\n/**\n * Sample-size ('stsz') atom\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\n */\nclass StszAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\n        };\n    }\n}\nexports.StszAtom = StszAtom;\n/**\n * Chunk offset atom, 'stco'\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\n */\nclass StcoAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, Token.INT32_BE);\n        this.len = len;\n    }\n}\nexports.StcoAtom = StcoAtom;\n/**\n * Token used to decode text-track from 'mdat' atom (raw data stream)\n */\nclass ChapterText {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\n        const str = new Token.StringType(titleLen, 'utf-8');\n        return str.get(buf, off + 2);\n    }\n}\nexports.ChapterText = ChapterText;\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\n    if (remainingLen === 0)\n        return [];\n    assert.equal(remainingLen, numberOfEntries * token.len, 'mismatch number-of-entries with remaining atom-length');\n    const entries = [];\n    // parse offset-table\n    for (let n = 0; n < numberOfEntries; ++n) {\n        entries.push(token.get(buf, off));\n        off += token.len;\n    }\n    return entries;\n}\n//# sourceMappingURL=AtomToken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wNC9BdG9tVG9rZW4uanM/MTUwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFrQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsOEVBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyxrQkFBa0IsT0FBTyxrQkFBa0IsSUFBSTtBQUMxRjtBQUNBO0FBQ0EsbUNBQW1DLE9BQU8sa0JBQWtCLE9BQU8scUJBQXFCLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLG9CQUFvQixnQkFBZ0IsZUFBZSxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L0F0b21Ub2tlbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFwdGVyVGV4dCA9IGV4cG9ydHMuU3Rjb0F0b20gPSBleHBvcnRzLlN0c3pBdG9tID0gZXhwb3J0cy5TdHNjQXRvbSA9IGV4cG9ydHMuU2FtcGxlVG9DaHVua1Rva2VuID0gZXhwb3J0cy5TdHRzQXRvbSA9IGV4cG9ydHMuVGltZVRvU2FtcGxlVG9rZW4gPSBleHBvcnRzLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WMCA9IGV4cG9ydHMuU291bmRTYW1wbGVEZXNjcmlwdGlvblZlcnNpb24gPSBleHBvcnRzLlN0c2RBdG9tID0gZXhwb3J0cy5UcmFja0hlYWRlckF0b20gPSBleHBvcnRzLk5hbWVBdG9tID0gZXhwb3J0cy5EYXRhQXRvbSA9IGV4cG9ydHMuTXZoZEF0b20gPSBleHBvcnRzLk1kaGRBdG9tID0gZXhwb3J0cy5GaXhlZExlbmd0aEF0b20gPSBleHBvcnRzLm1oZHIgPSBleHBvcnRzLnRraGQgPSBleHBvcnRzLmZ0eXAgPSBleHBvcnRzLkV4dGVuZGVkU2l6ZSA9IGV4cG9ydHMuSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6TVA0OmF0b20nKTtcbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXRvbSBoZWFkZXIgbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBuYW1lOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg0LCAnYmluYXJ5JykuZ2V0KGJ1Ziwgb2ZmICsgNClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHB1dDogKGJ1Ziwgb2ZmLCBoZHIpID0+IHtcbiAgICAgICAgVG9rZW4uVUlOVDMyX0JFLnB1dChidWYsIG9mZiwgaGRyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5wdXQoYnVmLCBvZmYgKyA0LCBoZHIubmFtZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAxL3F0ZmYxLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjAzLTM4MTkwXG4gKi9cbmV4cG9ydHMuRXh0ZW5kZWRTaXplID0gVG9rZW4uVUlOVDY0X0JFO1xuZXhwb3J0cy5mdHlwID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbmV3IFRva2VuLlN0cmluZ1R5cGUoNCwgJ2FzY2lpJykuZ2V0KGJ1Ziwgb2ZmKVxuICAgICAgICB9O1xuICAgIH1cbn07XG5leHBvcnRzLnRraGQgPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg0LCAnYXNjaWknKS5nZXQoYnVmLCBvZmYpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogVG9rZW46IE1vdmllIEhlYWRlciBBdG9tXG4gKi9cbmV4cG9ydHMubWhkciA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDApLFxuICAgICAgICAgICAgZmxhZ3M6IFRva2VuLlVJTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAxKSxcbiAgICAgICAgICAgIG5leHRJdGVtSUQ6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yICdmaXhlZCcgbGVuZ3RoIGF0b21zLlxuICogSW4gc29tZSBjYXNlcyB0aGVzZSBhdG9tcyBhcmUgbG9uZ2VyIHRoZW4gdGhlIHN1bSBvZiB0aGUgZGVzY3JpYmVkIGZpZWxkcy5cbiAqIElzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vQm9yZXdpdC9tdXNpYy1tZXRhZGF0YS9pc3N1ZXMvMTIwXG4gKi9cbmNsYXNzIEZpeGVkTGVuZ3RoQXRvbSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIExlbmd0aCBhcyBzcGVjaWZpZWQgaW4gdGhlIHNpemUgZmllbGRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwTGVuIFRvdGFsIGxlbmd0aCBvZiBzdW0gb2Ygc3BlY2lmaWVkIGZpZWxkcyBpbiB0aGUgc3RhbmRhcmRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZW4sIGV4cExlbiwgYXRvbUlkKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgICBpZiAobGVuIDwgZXhwTGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0b20gJHthdG9tSWR9IGV4cGVjdGVkIHRvIGJlICR7ZXhwTGVufSwgYnV0IHNwZWNpZmllcyAke2xlbn0gYnl0ZXMgbG9uZy5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBleHBMZW4pIHtcbiAgICAgICAgICAgIGRlYnVnKGBXYXJuaW5nOiBhdG9tICR7YXRvbUlkfSBleHBlY3RlZCB0byBiZSAke2V4cExlbn0sIGJ1dCB3YXMgYWN0dWFsbHkgJHtsZW59IGJ5dGVzIGxvbmcuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZpeGVkTGVuZ3RoQXRvbSA9IEZpeGVkTGVuZ3RoQXRvbTtcbi8qKlxuICogVG9rZW46IE1lZGlhIEhlYWRlciBBdG9tXG4gKiBSZWY6XG4gKiAgIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtU1czNFxuICogICBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHAvUXVpY2tUaW1lX2NvbnRhaW5lciNtZGhkXG4gKi9cbmNsYXNzIE1kaGRBdG9tIGV4dGVuZHMgRml4ZWRMZW5ndGhBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgc3VwZXIobGVuLCAyNCwgJ21kaGQnKTtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMCksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgY3JlYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICBtb2RpZmljYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICB0aW1lU2NhbGU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICBkdXJhdGlvbjogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgcXVhbGl0eTogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDIyKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWRoZEF0b20gPSBNZGhkQXRvbTtcbi8qKlxuICogVG9rZW46IE1vdmllIEhlYWRlciBBdG9tXG4gKi9cbmNsYXNzIE12aGRBdG9tIGV4dGVuZHMgRml4ZWRMZW5ndGhBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgc3VwZXIobGVuLCAxMDAsICdtdmhkJyk7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgY3JlYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICBtb2RpZmljYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICB0aW1lU2NhbGU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICBkdXJhdGlvbjogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIHByZWZlcnJlZFJhdGU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAyMCksXG4gICAgICAgICAgICBwcmVmZXJyZWRWb2x1bWU6IFRva2VuLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAyNCksXG4gICAgICAgICAgICAvLyBpZ25vcmUgcmVzZXJ2ZXI6IDEwIGJ5dGVzXG4gICAgICAgICAgICAvLyBpZ25vcmUgbWF0cml4IHN0cnVjdHVyZTogMzYgYnl0ZXNcbiAgICAgICAgICAgIHByZXZpZXdUaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNzIpLFxuICAgICAgICAgICAgcHJldmlld0R1cmF0aW9uOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNzYpLFxuICAgICAgICAgICAgcG9zdGVyVGltZTogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDgwKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblRpbWU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA4NCksXG4gICAgICAgICAgICBzZWxlY3Rpb25EdXJhdGlvbjogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDg4KSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOTIpLFxuICAgICAgICAgICAgbmV4dFRyYWNrSUQ6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA5NilcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk12aGRBdG9tID0gTXZoZEF0b207XG4vKipcbiAqIERhdGEgQXRvbSBTdHJ1Y3R1cmVcbiAqL1xuY2xhc3MgRGF0YUF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhbGU6IFRva2VuLlVJTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVG9rZW4uQnVmZmVyVHlwZSh0aGlzLmxlbiAtIDgpLmdldChidWYsIG9mZiArIDgpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhQXRvbSA9IERhdGFBdG9tO1xuLyoqXG4gKiBEYXRhIEF0b20gU3RydWN0dXJlXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1czMVxuICovXG5jbGFzcyBOYW1lQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgbmFtZTogbmV3IFRva2VuLlN0cmluZ1R5cGUodGhpcy5sZW4gLSA0LCAndXRmLTgnKS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZUF0b20gPSBOYW1lQXRvbTtcbi8qKlxuICogVHJhY2sgSGVhZGVyIEF0b21zIHN0cnVjdHVyZVxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9jb250ZW50L2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAyL3F0ZmYyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA0LTI1NTUwXG4gKi9cbmNsYXNzIFRyYWNrSGVhZGVyQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgY3JlYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICBtb2RpZmljYXRpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICB0cmFja0lkOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgLy8gcmVzZXJ2ZWQgNCBieXRlc1xuICAgICAgICAgICAgZHVyYXRpb246IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAyMCksXG4gICAgICAgICAgICBsYXllcjogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDI0KSxcbiAgICAgICAgICAgIGFsdGVybmF0ZUdyb3VwOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjYpLFxuICAgICAgICAgICAgdm9sdW1lOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjgpIC8vIFRvRG86IGZpeGVkIHBvaW50XG4gICAgICAgICAgICAvLyBUb0RvOiBhZGQgcmVtYWluaW5nIGZpZWxkc1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhY2tIZWFkZXJBdG9tID0gVHJhY2tIZWFkZXJBdG9tO1xuLyoqXG4gKiBBdG9tOiBTYW1wbGUgRGVzY3JpcHRpb24gQXRvbSAoJ3N0c2QnKVxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAyL3F0ZmYyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA0LTI1NjkxXG4gKi9cbmNvbnN0IHN0c2RIZWFkZXIgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgZmxhZ3M6IFRva2VuLlVJTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAxKSxcbiAgICAgICAgICAgIG51bWJlck9mRW50cmllczogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDQpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogQXRvbTogU2FtcGxlIERlc2NyaXB0aW9uIEF0b20gKCdzdHNkJylcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTY5MVxuICovXG5jbGFzcyBTYW1wbGVEZXNjcmlwdGlvblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUZvcm1hdDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGRhdGFSZWZlcmVuY2VJbmRleDogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDEwKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBuZXcgVG9rZW4uQnVmZmVyVHlwZSh0aGlzLmxlbiAtIDEyKS5nZXQoYnVmLCBvZmYgKyAxMilcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEF0b206IFNhbXBsZS1kZXNjcmlwdGlvbiBBdG9tICgnc3RzZCcpXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU2OTFcbiAqL1xuY2xhc3MgU3RzZEF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHN0c2RIZWFkZXIuZ2V0KGJ1Ziwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IHN0c2RIZWFkZXIubGVuO1xuICAgICAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlci5udW1iZXJPZkVudHJpZXM7ICsrbikge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYpOyAvLyBTYW1wbGUgZGVzY3JpcHRpb24gc2l6ZVxuICAgICAgICAgICAgb2ZmICs9IFRva2VuLlVJTlQzMl9CRS5sZW47XG4gICAgICAgICAgICB0YWJsZS5wdXNoKG5ldyBTYW1wbGVEZXNjcmlwdGlvblRhYmxlKHNpemUpLmdldChidWYsIG9mZikpO1xuICAgICAgICAgICAgb2ZmICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdHNkQXRvbSA9IFN0c2RBdG9tO1xuLyoqXG4gKiBDb21tb24gU291bmQgU2FtcGxlIERlc2NyaXB0aW9uICh2ZXJzaW9uICYgcmV2aXNpb24pXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDMvcXRmZjMuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDUtNTczMTdcbiAqL1xuZXhwb3J0cy5Tb3VuZFNhbXBsZURlc2NyaXB0aW9uVmVyc2lvbiA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5JTlQxNl9CRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgcmV2aXNpb246IFRva2VuLklOVDE2X0JFLmdldChidWYsIG9mZiArIDIpLFxuICAgICAgICAgICAgdmVuZG9yOiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFNvdW5kIFNhbXBsZSBEZXNjcmlwdGlvbiAoVmVyc2lvbiAwKVxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAzL3F0ZmYzLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA1LTEzMDczNlxuICovXG5leHBvcnRzLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WMCA9IHtcbiAgICBsZW46IDEyLFxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtQXVkaW9DaGFubmVsczogVG9rZW4uSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMCksXG4gICAgICAgICAgICBzYW1wbGVTaXplOiBUb2tlbi5JTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAyKSxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uSWQ6IFRva2VuLklOVDE2X0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgcGFja2V0U2l6ZTogVG9rZW4uSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgNiksXG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgOCkgKyBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTApIC8gMTAwMDBcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY2xhc3MgU2ltcGxlVGFibGVBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4sIHRva2VuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICBjb25zdCBuck9mRW50cmllcyA9IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiArIDQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogVG9rZW4uSU5UOC5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgIGZsYWdzOiBUb2tlbi5JTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAxKSxcbiAgICAgICAgICAgIG51bWJlck9mRW50cmllczogbnJPZkVudHJpZXMsXG4gICAgICAgICAgICBlbnRyaWVzOiByZWFkVG9rZW5UYWJsZShidWYsIHRoaXMudG9rZW4sIG9mZiArIDgsIHRoaXMubGVuIC0gOCwgbnJPZkVudHJpZXMpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lVG9TYW1wbGVUb2tlbiA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudDogVG9rZW4uSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMCksXG4gICAgICAgICAgICBkdXJhdGlvbjogVG9rZW4uSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBUaW1lLXRvLXNhbXBsZSgnc3R0cycpIGF0b20uXG4gKiBTdG9yZSBkdXJhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBtZWRpYeKAmXMgc2FtcGxlcy5cbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTY5NlxuICovXG5jbGFzcyBTdHRzQXRvbSBleHRlbmRzIFNpbXBsZVRhYmxlQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHN1cGVyKGxlbiwgZXhwb3J0cy5UaW1lVG9TYW1wbGVUb2tlbik7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbn1cbmV4cG9ydHMuU3R0c0F0b20gPSBTdHRzQXRvbTtcbmV4cG9ydHMuU2FtcGxlVG9DaHVua1Rva2VuID0ge1xuICAgIGxlbjogMTIsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdENodW5rOiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgc2FtcGxlc1BlckNodW5rOiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIHNhbXBsZURlc2NyaXB0aW9uSWQ6IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiArIDgpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogU2FtcGxlLXRvLUNodW5rICgnc3RzYycpIGF0b20gaW50ZXJmYWNlXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU3MDZcbiAqL1xuY2xhc3MgU3RzY0F0b20gZXh0ZW5kcyBTaW1wbGVUYWJsZUF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICBzdXBlcihsZW4sIGV4cG9ydHMuU2FtcGxlVG9DaHVua1Rva2VuKTtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxufVxuZXhwb3J0cy5TdHNjQXRvbSA9IFN0c2NBdG9tO1xuLyoqXG4gKiBTYW1wbGUtc2l6ZSAoJ3N0c3onKSBhdG9tXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU3MTBcbiAqL1xuY2xhc3MgU3RzekF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IG5yT2ZFbnRyaWVzID0gVG9rZW4uSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5JTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMSksXG4gICAgICAgICAgICBzYW1wbGVTaXplOiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIG51bWJlck9mRW50cmllczogbnJPZkVudHJpZXMsXG4gICAgICAgICAgICBlbnRyaWVzOiByZWFkVG9rZW5UYWJsZShidWYsIFRva2VuLklOVDMyX0JFLCBvZmYgKyAxMiwgdGhpcy5sZW4gLSAxMiwgbnJPZkVudHJpZXMpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdHN6QXRvbSA9IFN0c3pBdG9tO1xuLyoqXG4gKiBDaHVuayBvZmZzZXQgYXRvbSwgJ3N0Y28nXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU3MTVcbiAqL1xuY2xhc3MgU3Rjb0F0b20gZXh0ZW5kcyBTaW1wbGVUYWJsZUF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICBzdXBlcihsZW4sIFRva2VuLklOVDMyX0JFKTtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxufVxuZXhwb3J0cy5TdGNvQXRvbSA9IFN0Y29BdG9tO1xuLyoqXG4gKiBUb2tlbiB1c2VkIHRvIGRlY29kZSB0ZXh0LXRyYWNrIGZyb20gJ21kYXQnIGF0b20gKHJhdyBkYXRhIHN0cmVhbSlcbiAqL1xuY2xhc3MgQ2hhcHRlclRleHQge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlTGVuID0gVG9rZW4uSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMCk7XG4gICAgICAgIGNvbnN0IHN0ciA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKHRpdGxlTGVuLCAndXRmLTgnKTtcbiAgICAgICAgcmV0dXJuIHN0ci5nZXQoYnVmLCBvZmYgKyAyKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXB0ZXJUZXh0ID0gQ2hhcHRlclRleHQ7XG5mdW5jdGlvbiByZWFkVG9rZW5UYWJsZShidWYsIHRva2VuLCBvZmYsIHJlbWFpbmluZ0xlbiwgbnVtYmVyT2ZFbnRyaWVzKSB7XG4gICAgZGVidWcoYHJlbWFpbmluZ0xlbj0ke3JlbWFpbmluZ0xlbn0sIG51bWJlck9mRW50cmllcz0ke251bWJlck9mRW50cmllc30gKiB0b2tlbi1sZW49JHt0b2tlbi5sZW59YCk7XG4gICAgaWYgKHJlbWFpbmluZ0xlbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGFzc2VydC5lcXVhbChyZW1haW5pbmdMZW4sIG51bWJlck9mRW50cmllcyAqIHRva2VuLmxlbiwgJ21pc21hdGNoIG51bWJlci1vZi1lbnRyaWVzIHdpdGggcmVtYWluaW5nIGF0b20tbGVuZ3RoJyk7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIC8vIHBhcnNlIG9mZnNldC10YWJsZVxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbnVtYmVyT2ZFbnRyaWVzOyArK24pIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHRva2VuLmdldChidWYsIG9mZikpO1xuICAgICAgICBvZmYgKz0gdG9rZW4ubGVuO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0b21Ub2tlbi5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mp4/AtomToken.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/MP4Parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/MP4Parser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MP4Parser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst Atom_1 = __webpack_require__(/*! ./Atom */ \"./node_modules/music-metadata/lib/mp4/Atom.js\");\nconst AtomToken = __webpack_require__(/*! ./AtomToken */ \"./node_modules/music-metadata/lib/mp4/AtomToken.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst type_1 = __webpack_require__(/*! ../type */ \"./node_modules/music-metadata/lib/type.js\");\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n    static read_BE_Signed_Integer(value) {\n        return Token.readIntBE(value, 0, value.length);\n    }\n    static read_BE_Unsigned_Integer(value) {\n        return Token.readUIntBE(value, 0, value.length);\n    }\n    async parse() {\n        this.tracks = [];\n        let remainingFileSize = this.tokenizer.fileInfo.size;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                debug(errMsg);\n                this.addWarning(errMsg);\n                break;\n            }\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, atom => this.handleAtom(atom), null);\n            remainingFileSize -= rootAtom.header.length;\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = type_1.TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = this.tracks.filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.sampleRate > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            const duration = audioTrack.duration / audioTrack.timeScale;\n            this.metadata.setFormat('duration', duration); // calculate duration in seconds\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n    }\n    async handleAtom(atom) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n                case 'stbl': // The Sample Table Atom\n                    switch (atom.header.name) {\n                        case 'stsd': // sample descriptions\n                            return this.parseAtom_stsd(atom.getPayloadLength());\n                        case 'stsc': // sample-to-Chunk Atoms\n                            return this.parseAtom_stsc(atom.getPayloadLength());\n                        case 'stts': // time to sample\n                            return this.parseAtom_stts(atom.getPayloadLength());\n                        case 'stsz': // sample sizes\n                            return this.parseAtom_stsz(atom.getPayloadLength());\n                        case 'stco':\n                            return this.parseAtom_stco(atom.getPayloadLength());\n                        default:\n                            debug(`Ignore: stbl/${atom.header.name} atom`);\n                    }\n                    break;\n            }\n        }\n        switch (atom.header.name) {\n            case 'ftyp':\n                const types = await this.parseAtom_ftyp(atom.getPayloadLength());\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n                return;\n            case 'mdhd': // Media header atom\n                return this.parseAtom_mdhd(atom);\n            case 'mvhd': // 'movie' => 'mvhd': movie header atom; child of Movie Atom\n                return this.parseAtom_mvhd(atom);\n            case 'chap': // Chapter or scene list atom. Usually references a text track.\n                const td = this.getTrackDescription();\n                td.chapterList = await this.parseAtom_chap(atom);\n                return;\n            case 'tkhd': // Chapter or scene list atom. Usually references a text track.\n                await this.parseAtom_tkhd(atom.getPayloadLength());\n                return;\n            case 'mdat': // media data atom:\n                this.audioLengthInBytes = atom.getPayloadLength();\n                this.calculateBitRate();\n                return this.parseAtom_mdat(atom.getPayloadLength());\n        }\n        await this.tokenizer.ignore(atom.getPayloadLength());\n        debug(`Ignore atom data: path=${atom.atomPath}, payload-len=${atom.getPayloadLength()}`);\n    }\n    getTrackDescription() {\n        return this.tracks[this.tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug('Warning: ' + message);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child) => {\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength()));\n                    tagKey += ':' + name.name;\n                    break;\n                case 'mean': // name atom (optional)\n                    const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength()));\n                    // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\n                    tagKey += ':' + mean.name;\n                    break;\n                default:\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(child.getPayloadLength()));\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n            }\n        }, metaAtom.getPayloadLength());\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk':\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        this.addTag(tagKey, num + '/' + of);\n                        break;\n                    case 'gnre':\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        this.addTag(tagKey, genreStr);\n                        break;\n                    default:\n                    // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\n                    // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\n                break;\n            case 22: // BE Unsigned Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\n                break;\n            case 65: // An 8-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    /**\n     * Parse movie header (mvhd) atom\n     * @param mvhd mvhd atom\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n     */\n    async parseAtom_mvhd(mvhd) {\n        // await this.tokenizer.readToken<AtomToken.IAtomMvhd>(new AtomToken.MvhdAtom(mvhd.getPayloadLength()));\n        // ToDo: export movie metadata\n        await this.tokenizer.ignore((mvhd.getPayloadLength()));\n    }\n    /**\n     * Parse media header (mdhd) atom\n     * @param mdhd mdhd atom\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n     */\n    async parseAtom_mdhd(mdhd) {\n        const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(mdhd.getPayloadLength()));\n        // this.parse_mxhd(mdhd_data, this.currentTrack);\n        const td = this.getTrackDescription();\n        td.creationTime = mdhd_data.creationTime;\n        td.modificationTime = mdhd_data.modificationTime;\n        td.timeScale = mdhd_data.timeScale;\n        td.duration = mdhd_data.duration;\n    }\n    async parseAtom_ftyp(len) {\n        const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n        len -= AtomToken.ftyp.len;\n        if (len > 0) {\n            const types = await this.parseAtom_ftyp(len);\n            const value = ftype.type.replace(/\\W/g, '');\n            if (value.length > 0) {\n                types.push(value);\n            }\n            return types;\n        }\n        return [];\n    }\n    async parseAtom_tkhd(len) {\n        const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\n        this.tracks.push(track);\n    }\n    /**\n     * Parse sample description atom\n     * @param len\n     */\n    async parseAtom_stsd(len) {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n    }\n    async parseAtom_stsc(len) {\n        const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n        this.getTrackDescription().sampleToChunkTable = stsc.entries;\n    }\n    async parseAtom_stts(len) {\n        const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n        this.getTrackDescription().timeToSampleTable = stts.entries;\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\n        if (version.version === 0 || version.version === 1) {\n            // Sound Sample Description (Version 0)\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n        }\n        else {\n            debug(`Warning: sound-sample-description ${version} not implemented`);\n        }\n        return ssd;\n    }\n    /**\n     * Parse chapter-list atom\n     * @param chap chap atom\n     */\n    async parseAtom_chap(chap) {\n        const trackIds = [];\n        let len = chap.getPayloadLength();\n        while (len >= Token.UINT32_BE.len) {\n            trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n            len -= Token.UINT32_BE.len;\n        }\n        return trackIds;\n    }\n    /**\n     * Parse sample-sizes atom ('stsz')\n     * @param len\n     */\n    async parseAtom_stsz(len) {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n    }\n    /**\n     * Parse chunk-offset atom ('stco')\n     * @param len\n     */\n    async parseAtom_stco(len) {\n        const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n        this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n    }\n    /**\n     * Parse mdat atom.\n     * Will scan for chapters\n     * @param len\n     */\n    async parseAtom_mdat(len) {\n        if (this.options.includeChapters) {\n            const trackWithChapters = this.tracks.filter(track => track.chapterList);\n            if (trackWithChapters.length === 1) {\n                const chapterTrackIds = trackWithChapters[0].chapterList;\n                const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n                if (chapterTracks.length === 1) {\n                    return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                }\n            }\n        }\n        await this.tokenizer.ignore(len);\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            assert.equal(chapterTrack.chunkOffsetTable.length, chapterTrack.sampleSizeTable.length, 'chunk-offset-table & sample-size-table length');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            assert.ok(len >= 0, 'Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let totalDuration = 0;\n        track.timeToSampleTable.forEach(e => {\n            totalDuration += e.count * e.duration;\n        });\n        debug(`Total duration=${totalDuration}`);\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\nexports.MP4Parser = MP4Parser;\n//# sourceMappingURL=MP4Parser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wNC9NUDRQYXJzZXIuanM/NWVhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakMsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUTtBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDZEQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFhO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsMERBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsSUFBSSxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWMsZ0JBQWdCLHdCQUF3QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxtQkFBbUI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPLDZDQUE2QyxtQkFBbUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFxRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNLElBQUksTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLFdBQVcscUJBQXFCLEdBQUcsd0JBQXdCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcDQvTVA0UGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1QNFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgQXRvbV8xID0gcmVxdWlyZShcIi4vQXRvbVwiKTtcbmNvbnN0IEF0b21Ub2tlbiA9IHJlcXVpcmUoXCIuL0F0b21Ub2tlblwiKTtcbmNvbnN0IElEM3YxUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjEvSUQzdjFQYXJzZXJcIik7XG5jb25zdCB0eXBlXzEgPSByZXF1aXJlKFwiLi4vdHlwZVwiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6TVA0Jyk7XG5jb25zdCB0YWdGb3JtYXQgPSAnaVR1bmVzJztcbmNvbnN0IGVuY29kZXJEaWN0ID0ge1xuICAgIHJhdzoge1xuICAgICAgICBsb3NzeTogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogJ3JhdydcbiAgICB9LFxuICAgIE1BQzM6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ01BQ0UgMzoxJ1xuICAgIH0sXG4gICAgTUFDNjoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnTUFDRSA2OjEnXG4gICAgfSxcbiAgICBpbWE0OiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdJTUEgNDoxJ1xuICAgIH0sXG4gICAgdWxhdzoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAndUxhdyAyOjEnXG4gICAgfSxcbiAgICBhbGF3OiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICd1TGF3IDI6MSdcbiAgICB9LFxuICAgIFFjbHA6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ1FVQUxDT01NIFB1cmVWb2ljZSdcbiAgICB9LFxuICAgICcubXAzJzoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnTVBFRy0xIGxheWVyIDMnXG4gICAgfSxcbiAgICBhbGFjOiB7XG4gICAgICAgIGxvc3N5OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiAnQUxBQydcbiAgICB9LFxuICAgICdhYy0zJzoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnQUMtMydcbiAgICB9LFxuICAgIG1wNGE6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ01QRUctNC9BQUMnXG4gICAgfSxcbiAgICBtcDRzOiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdNUDRTJ1xuICAgIH0sXG4gICAgLy8gQ2xvc2VkIENhcHRpb25pbmcgTWVkaWEsIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDMvcXRmZjMuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDUtU1c4N1xuICAgIGM2MDg6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ0NFQS02MDgnXG4gICAgfSxcbiAgICBjNzA4OiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdDRUEtNzA4J1xuICAgIH1cbn07XG5mdW5jdGlvbiBkaXN0aW5jdCh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG59XG4vKlxuICogUGFyc2VyIGZvciB0aGUgTVA0IChNUEVHLTQgUGFydCAxNCkgY29udGFpbmVyIGZvcm1hdFxuICogU3RhbmRhcmQ6IElTTy9JRUMgMTQ0OTYtMTRcbiAqIHN1cHBvcnRpbmc6XG4gKiAtIFF1aWNrVGltZSBjb250YWluZXJcbiAqIC0gTVA0IEZpbGUgRm9ybWF0XG4gKiAtIDNHUFAgZmlsZSBmb3JtYXRcbiAqIC0gM0dQUDIgZmlsZSBmb3JtYXRcbiAqXG4gKiBNUEVHLTQgQXVkaW8gLyBQYXJ0IDMgKC5tNGEpJiBNUEVHIDQgVmlkZW8gKG00diwgbXA0KSBleHRlbnNpb24uXG4gKiBTdXBwb3J0IGZvciBBcHBsZSBpVHVuZXMgdGFncyBhcyBmb3VuZCBpbiBhIE00QS9NNFYgZmlsZXMuXG4gKiBSZWY6XG4gKiAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT19iYXNlX21lZGlhX2ZpbGVfZm9ybWF0XG4gKiAgIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sXG4gKiAgIGh0dHA6Ly9hdG9taWNwYXJzbGV5LnNvdXJjZWZvcmdlLm5ldC9tcGVnLTRmaWxlcy5odG1sXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXJnaW9tYjIvbGlibXA0djIvd2lraS9pVHVuZXNNZXRhZGF0YVxuICogICBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHAvUXVpY2tUaW1lX2NvbnRhaW5lclxuICovXG5jbGFzcyBNUDRQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBzdGF0aWMgcmVhZF9CRV9TaWduZWRfSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVG9rZW4ucmVhZEludEJFKHZhbHVlLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVhZF9CRV9VbnNpZ25lZF9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUb2tlbi5yZWFkVUludEJFKHZhbHVlLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0ZpbGVTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIHx8IHJlbWFpbmluZ0ZpbGVTaXplID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtUb2tlbihBdG9tVG9rZW4uSGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ1xcMFxcMFxcMFxcMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYEVycm9yIGF0IG9mZnNldD0ke3RoaXMudG9rZW5pemVyLnBvc2l0aW9ufTogYm94LmlkPTBgO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFdhcm5pbmcoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYEVycm9yIGF0IG9mZnNldD0ke3RoaXMudG9rZW5pemVyLnBvc2l0aW9ufTogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgZGVidWcoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFdhcm5pbmcoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvb3RBdG9tID0gYXdhaXQgQXRvbV8xLkF0b20ucmVhZEF0b20odGhpcy50b2tlbml6ZXIsIGF0b20gPT4gdGhpcy5oYW5kbGVBdG9tKGF0b20pLCBudWxsKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0ZpbGVTaXplIC09IHJvb3RBdG9tLmhlYWRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9zdCBwcm9jZXNzIG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFja0Zvcm1hdHMgPSBbXTtcbiAgICAgICAgICAgIHRyYWNrLnNvdW5kU2FtcGxlRGVzY3JpcHRpb24uZm9yRWFjaChzc2QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVySW5mbyA9IGVuY29kZXJEaWN0W3NzZC5kYXRhRm9ybWF0XTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tGb3JtYXRzLnB1c2goZW5jb2RlckluZm8uZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mby5jb2RlY05hbWUgPSBlbmNvZGVySW5mby5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1JbmZvLmNvZGVjTmFtZSA9IGA8JHtzc2QuZGF0YUZvcm1hdH0+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNzZC5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlc2NyaXB0aW9uIH0gPSBzc2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi5zYW1wbGVSYXRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mby50eXBlID0gdHlwZV8xLlRyYWNrVHlwZS5hdWRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbUluZm8uYXVkaW8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmdGcmVxdWVuY3k6IGRlc2NyaXB0aW9uLnNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0RGVwdGg6IGRlc2NyaXB0aW9uLnNhbXBsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IGRlc2NyaXB0aW9uLm51bUF1ZGlvQ2hhbm5lbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRTdHJlYW1JbmZvKHN0cmVhbUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhY2tGb3JtYXRzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0TGlzdC5wdXNoKHRyYWNrRm9ybWF0cy5qb2luKCcvJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvcm1hdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgZm9ybWF0TGlzdC5maWx0ZXIoZGlzdGluY3QpLmpvaW4oJysnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrLnNvdW5kU2FtcGxlRGVzY3JpcHRpb24ubGVuZ3RoID49IDEgJiYgdHJhY2suc291bmRTYW1wbGVEZXNjcmlwdGlvblswXS5kZXNjcmlwdGlvbiAmJiB0cmFjay5zb3VuZFNhbXBsZURlc2NyaXB0aW9uWzBdLmRlc2NyaXB0aW9uLnNhbXBsZVJhdGUgPiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gYXVkaW9UcmFja3NbMF07XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gLyBhdWRpb1RyYWNrLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGR1cmF0aW9uKTsgLy8gY2FsY3VsYXRlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgICAgICAgIGNvbnN0IHNzZCA9IGF1ZGlvVHJhY2suc291bmRTYW1wbGVEZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgIGlmIChzc2QuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIHNzZC5kZXNjcmlwdGlvbi5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIHNzZC5kZXNjcmlwdGlvbi5zYW1wbGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIHNzZC5kZXNjcmlwdGlvbi5udW1BdWRpb0NoYW5uZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXJJbmZvID0gZW5jb2RlckRpY3Rbc3NkLmRhdGFGb3JtYXRdO1xuICAgICAgICAgICAgaWYgKGVuY29kZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgIWVuY29kZXJJbmZvLmxvc3N5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQml0UmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUF0b20oYXRvbSkge1xuICAgICAgICBpZiAoYXRvbS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXRvbS5wYXJlbnQuaGVhZGVyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbHN0JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8aWQ+JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhZGF0YUl0ZW1EYXRhKGF0b20pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YmwnOiAvLyBUaGUgU2FtcGxlIFRhYmxlIEF0b21cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhdG9tLmhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHNkJzogLy8gc2FtcGxlIGRlc2NyaXB0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXRvbV9zdHNkKGF0b20uZ2V0UGF5bG9hZExlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0c2MnOiAvLyBzYW1wbGUtdG8tQ2h1bmsgQXRvbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF0b21fc3RzYyhhdG9tLmdldFBheWxvYWRMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHRzJzogLy8gdGltZSB0byBzYW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF0b21fc3R0cyhhdG9tLmdldFBheWxvYWRMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHN6JzogLy8gc2FtcGxlIHNpemVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBdG9tX3N0c3ooYXRvbS5nZXRQYXlsb2FkTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3Rjbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBdG9tX3N0Y28oYXRvbS5nZXRQYXlsb2FkTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlOiBzdGJsLyR7YXRvbS5oZWFkZXIubmFtZX0gYXRvbWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXRvbS5oZWFkZXIubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZnR5cCc6XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBhd2FpdCB0aGlzLnBhcnNlQXRvbV9mdHlwKGF0b20uZ2V0UGF5bG9hZExlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgZnR5cDogJHt0eXBlcy5qb2luKCcvJyl9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHR5cGVzLmZpbHRlcihkaXN0aW5jdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCB4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdtZGhkJzogLy8gTWVkaWEgaGVhZGVyIGF0b21cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF0b21fbWRoZChhdG9tKTtcbiAgICAgICAgICAgIGNhc2UgJ212aGQnOiAvLyAnbW92aWUnID0+ICdtdmhkJzogbW92aWUgaGVhZGVyIGF0b207IGNoaWxkIG9mIE1vdmllIEF0b21cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF0b21fbXZoZChhdG9tKTtcbiAgICAgICAgICAgIGNhc2UgJ2NoYXAnOiAvLyBDaGFwdGVyIG9yIHNjZW5lIGxpc3QgYXRvbS4gVXN1YWxseSByZWZlcmVuY2VzIGEgdGV4dCB0cmFjay5cbiAgICAgICAgICAgICAgICBjb25zdCB0ZCA9IHRoaXMuZ2V0VHJhY2tEZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHRkLmNoYXB0ZXJMaXN0ID0gYXdhaXQgdGhpcy5wYXJzZUF0b21fY2hhcChhdG9tKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICd0a2hkJzogLy8gQ2hhcHRlciBvciBzY2VuZSBsaXN0IGF0b20uIFVzdWFsbHkgcmVmZXJlbmNlcyBhIHRleHQgdHJhY2suXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXJzZUF0b21fdGtoZChhdG9tLmdldFBheWxvYWRMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnbWRhdCc6IC8vIG1lZGlhIGRhdGEgYXRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvTGVuZ3RoSW5CeXRlcyA9IGF0b20uZ2V0UGF5bG9hZExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQml0UmF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXRvbV9tZGF0KGF0b20uZ2V0UGF5bG9hZExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoYXRvbS5nZXRQYXlsb2FkTGVuZ3RoKCkpO1xuICAgICAgICBkZWJ1ZyhgSWdub3JlIGF0b20gZGF0YTogcGF0aD0ke2F0b20uYXRvbVBhdGh9LCBwYXlsb2FkLWxlbj0ke2F0b20uZ2V0UGF5bG9hZExlbmd0aCgpfWApO1xuICAgIH1cbiAgICBnZXRUcmFja0Rlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja3NbdGhpcy50cmFja3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNhbGN1bGF0ZUJpdFJhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvTGVuZ3RoSW5CeXRlcyAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogdGhpcy5hdWRpb0xlbmd0aEluQnl0ZXMgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKGlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZyh0YWdGb3JtYXQsIGlkLCB2YWx1ZSk7XG4gICAgfVxuICAgIGFkZFdhcm5pbmcobWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnV2FybmluZzogJyArIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGRhdGEgb2YgTWV0YS1pdGVtLWxpc3QtYXRvbSAoaXRlbSBvZiAnaWxzdCcgYXRvbSlcbiAgICAgKiBAcGFyYW0gbWV0YUF0b21cbiAgICAgKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1c4XG4gICAgICovXG4gICAgcGFyc2VNZXRhZGF0YUl0ZW1EYXRhKG1ldGFBdG9tKSB7XG4gICAgICAgIGxldCB0YWdLZXkgPSBtZXRhQXRvbS5oZWFkZXIubmFtZTtcbiAgICAgICAgcmV0dXJuIG1ldGFBdG9tLnJlYWRBdG9tcyh0aGlzLnRva2VuaXplciwgYXN5bmMgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoaWxkLmhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0YSc6IC8vIHZhbHVlIGF0b21cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZUF0b20odGFnS2V5LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6IC8vIG5hbWUgYXRvbSAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5OYW1lQXRvbShjaGlsZC5nZXRQYXlsb2FkTGVuZ3RoKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGFnS2V5ICs9ICc6JyArIG5hbWUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVhbic6IC8vIG5hbWUgYXRvbSAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lYW4gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5OYW1lQXRvbShjaGlsZC5nZXRQYXlsb2FkTGVuZ3RoKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgICVzWyVzXSA9ICVzXCIsIHRhZ0tleSwgaGVhZGVyLm5hbWUsIG1lYW4ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRhZ0tleSArPSAnOicgKyBtZWFuLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFBdG9tID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5CdWZmZXJUeXBlKGNoaWxkLmdldFBheWxvYWRMZW5ndGgoKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFdhcm5pbmcoJ1Vuc3VwcG9ydGVkIG1ldGEtaXRlbTogJyArIHRhZ0tleSArICdbJyArIGNoaWxkLmhlYWRlci5uYW1lICsgJ10gPT4gdmFsdWU9JyArIGRhdGFBdG9tLnRvU3RyaW5nKCdoZXgnKSArICcgYXNjaWk9JyArIGRhdGFBdG9tLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbWV0YUF0b20uZ2V0UGF5bG9hZExlbmd0aCgpKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VWYWx1ZUF0b20odGFnS2V5LCBtZXRhQXRvbSkge1xuICAgICAgICBjb25zdCBkYXRhQXRvbSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXRvbVRva2VuLkRhdGFBdG9tKG1ldGFBdG9tLmhlYWRlci5sZW5ndGggLSBBdG9tVG9rZW4uSGVhZGVyLmxlbikpO1xuICAgICAgICBpZiAoZGF0YUF0b20udHlwZS5zZXQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZS1zZXQgIT0gMDogJyArIGRhdGFBdG9tLnR5cGUuc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugd2VsbC1rbm93bi10eXBlIHRhYmxlXG4gICAgICAgIC8vIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvY29udGVudC9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL01ldGFkYXRhL01ldGFkYXRhLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMS1TVzM1XG4gICAgICAgIHN3aXRjaCAoZGF0YUF0b20udHlwZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIHJlc2VydmVkOiBSZXNlcnZlZCBmb3IgdXNlIHdoZXJlIG5vIHR5cGUgbmVlZHMgdG8gYmUgaW5kaWNhdGVkXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWdLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJrbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2snOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gVG9rZW4uVUlOVDguZ2V0KGRhdGFBdG9tLnZhbHVlLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mID0gVG9rZW4uVUlOVDguZ2V0KGRhdGFBdG9tLnZhbHVlLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiICAlc1tkYXRhXSA9ICVzLyVzXCIsIHRhZ0tleSwgbnVtLCBvZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIG51bSArICcvJyArIG9mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnbnJlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbnJlSW50ID0gVG9rZW4uVUlOVDguZ2V0KGRhdGFBdG9tLnZhbHVlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbnJlU3RyID0gSUQzdjFQYXJzZXJfMS5HZW5yZXNbZ2VucmVJbnQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiICAlc1tkYXRhXSA9ICVzXCIsIHRhZ0tleSwgZ2VucmVTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBnZW5yZVN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgIHJlc2VydmVkLWRhdGE6IG5hbWU9JXMsIGxlbj0lcywgc2V0PSVzLCB0eXBlPSVzLCBsb2NhbGU9JXMsIHZhbHVleyBoZXg9JXMsIGFzY2lpPSVzIH1cIixcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyLm5hbWUsIGhlYWRlci5sZW5ndGgsIGRhdGFBdG9tLnR5cGUuc2V0LCBkYXRhQXRvbS50eXBlLnR5cGUsIGRhdGFBdG9tLmxvY2FsZSwgZGF0YUF0b20udmFsdWUudG9TdHJpbmcoJ2hleCcpLCBkYXRhQXRvbS52YWx1ZS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBVVEYtODogV2l0aG91dCBhbnkgY291bnQgb3IgTlVMTCB0ZXJtaW5hdG9yXG4gICAgICAgICAgICBjYXNlIDE4OiAvLyBVbmtub3duOiBGb3VuZCBpbiBtNGIgaW4gY29tYmluYXRpb24gd2l0aCBhICfCqWdlbicgdGFnXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS50b1N0cmluZygndXRmLTgnKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOiAvLyBKUEVHXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGFBdG9tLnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gUE5HXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YUF0b20udmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIxOiAvLyBCRSBTaWduZWQgSW50ZWdlclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZ0tleSwgTVA0UGFyc2VyLnJlYWRfQkVfU2lnbmVkX0ludGVnZXIoZGF0YUF0b20udmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjI6IC8vIEJFIFVuc2lnbmVkIEludGVnZXJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIE1QNFBhcnNlci5yZWFkX0JFX1Vuc2lnbmVkX0ludGVnZXIoZGF0YUF0b20udmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjU6IC8vIEFuIDgtYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50OCgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY2OiAvLyBBIGJpZy1lbmRpYW4gMTYtYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50MTZCRSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY3OiAvLyBBIGJpZy1lbmRpYW4gMzItYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50MzJCRSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2FybmluZyhgYXRvbSBrZXk9JHt0YWdLZXl9LCBoYXMgdW5rbm93biB3ZWxsLWtub3duLXR5cGUgKGRhdGEtdHlwZSk6ICR7ZGF0YUF0b20udHlwZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIG1vdmllIGhlYWRlciAobXZoZCkgYXRvbVxuICAgICAqIEBwYXJhbSBtdmhkIG12aGQgYXRvbVxuICAgICAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC01NjMxM1xuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQXRvbV9tdmhkKG12aGQpIHtcbiAgICAgICAgLy8gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuPEF0b21Ub2tlbi5JQXRvbU12aGQ+KG5ldyBBdG9tVG9rZW4uTXZoZEF0b20obXZoZC5nZXRQYXlsb2FkTGVuZ3RoKCkpKTtcbiAgICAgICAgLy8gVG9EbzogZXhwb3J0IG1vdmllIG1ldGFkYXRhXG4gICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSgobXZoZC5nZXRQYXlsb2FkTGVuZ3RoKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgbWVkaWEgaGVhZGVyIChtZGhkKSBhdG9tXG4gICAgICogQHBhcmFtIG1kaGQgbWRoZCBhdG9tXG4gICAgICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAyL3F0ZmYyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA0LTI1NjE1XG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VBdG9tX21kaGQobWRoZCkge1xuICAgICAgICBjb25zdCBtZGhkX2RhdGEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5NZGhkQXRvbShtZGhkLmdldFBheWxvYWRMZW5ndGgoKSkpO1xuICAgICAgICAvLyB0aGlzLnBhcnNlX214aGQobWRoZF9kYXRhLCB0aGlzLmN1cnJlbnRUcmFjayk7XG4gICAgICAgIGNvbnN0IHRkID0gdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRkLmNyZWF0aW9uVGltZSA9IG1kaGRfZGF0YS5jcmVhdGlvblRpbWU7XG4gICAgICAgIHRkLm1vZGlmaWNhdGlvblRpbWUgPSBtZGhkX2RhdGEubW9kaWZpY2F0aW9uVGltZTtcbiAgICAgICAgdGQudGltZVNjYWxlID0gbWRoZF9kYXRhLnRpbWVTY2FsZTtcbiAgICAgICAgdGQuZHVyYXRpb24gPSBtZGhkX2RhdGEuZHVyYXRpb247XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXRvbV9mdHlwKGxlbikge1xuICAgICAgICBjb25zdCBmdHlwZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBdG9tVG9rZW4uZnR5cCk7XG4gICAgICAgIGxlbiAtPSBBdG9tVG9rZW4uZnR5cC5sZW47XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlcyA9IGF3YWl0IHRoaXMucGFyc2VBdG9tX2Z0eXAobGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZnR5cGUudHlwZS5yZXBsYWNlKC9cXFcvZywgJycpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXRvbV90a2hkKGxlbikge1xuICAgICAgICBjb25zdCB0cmFjayA9IChhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5UcmFja0hlYWRlckF0b20obGVuKSkpO1xuICAgICAgICB0aGlzLnRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2Ugc2FtcGxlIGRlc2NyaXB0aW9uIGF0b21cbiAgICAgKiBAcGFyYW0gbGVuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VBdG9tX3N0c2QobGVuKSB7XG4gICAgICAgIGNvbnN0IHN0c2QgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5TdHNkQXRvbShsZW4pKTtcbiAgICAgICAgY29uc3QgdHJhY2tEZXNjcmlwdGlvbiA9IHRoaXMuZ2V0VHJhY2tEZXNjcmlwdGlvbigpO1xuICAgICAgICB0cmFja0Rlc2NyaXB0aW9uLnNvdW5kU2FtcGxlRGVzY3JpcHRpb24gPSBzdHNkLnRhYmxlLm1hcChkZkVudHJ5ID0+IHRoaXMucGFyc2VTb3VuZFNhbXBsZURlc2NyaXB0aW9uKGRmRW50cnkpKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VBdG9tX3N0c2MobGVuKSB7XG4gICAgICAgIGNvbnN0IHN0c2MgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5TdHNjQXRvbShsZW4pKTtcbiAgICAgICAgdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCkuc2FtcGxlVG9DaHVua1RhYmxlID0gc3RzYy5lbnRyaWVzO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUF0b21fc3R0cyhsZW4pIHtcbiAgICAgICAgY29uc3Qgc3R0cyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXRvbVRva2VuLlN0dHNBdG9tKGxlbikpO1xuICAgICAgICB0aGlzLmdldFRyYWNrRGVzY3JpcHRpb24oKS50aW1lVG9TYW1wbGVUYWJsZSA9IHN0dHMuZW50cmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNhbXBsZURlc2NyaXB0aW9uXG4gICAgICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAzL3F0ZmYzLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA1LTEyODkxNlxuICAgICAqL1xuICAgIHBhcnNlU291bmRTYW1wbGVEZXNjcmlwdGlvbihzYW1wbGVEZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBzc2QgPSB7XG4gICAgICAgICAgICBkYXRhRm9ybWF0OiBzYW1wbGVEZXNjcmlwdGlvbi5kYXRhRm9ybWF0LFxuICAgICAgICAgICAgZGF0YVJlZmVyZW5jZUluZGV4OiBzYW1wbGVEZXNjcmlwdGlvbi5kYXRhUmVmZXJlbmNlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBBdG9tVG9rZW4uU291bmRTYW1wbGVEZXNjcmlwdGlvblZlcnNpb24uZ2V0KHNhbXBsZURlc2NyaXB0aW9uLmRlc2NyaXB0aW9uLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gQXRvbVRva2VuLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WZXJzaW9uLmxlbjtcbiAgICAgICAgaWYgKHZlcnNpb24udmVyc2lvbiA9PT0gMCB8fCB2ZXJzaW9uLnZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFNvdW5kIFNhbXBsZSBEZXNjcmlwdGlvbiAoVmVyc2lvbiAwKVxuICAgICAgICAgICAgc3NkLmRlc2NyaXB0aW9uID0gQXRvbVRva2VuLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WMC5nZXQoc2FtcGxlRGVzY3JpcHRpb24uZGVzY3JpcHRpb24sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhgV2FybmluZzogc291bmQtc2FtcGxlLWRlc2NyaXB0aW9uICR7dmVyc2lvbn0gbm90IGltcGxlbWVudGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNzZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgY2hhcHRlci1saXN0IGF0b21cbiAgICAgKiBAcGFyYW0gY2hhcCBjaGFwIGF0b21cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZUF0b21fY2hhcChjaGFwKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrSWRzID0gW107XG4gICAgICAgIGxldCBsZW4gPSBjaGFwLmdldFBheWxvYWRMZW5ndGgoKTtcbiAgICAgICAgd2hpbGUgKGxlbiA+PSBUb2tlbi5VSU5UMzJfQkUubGVuKSB7XG4gICAgICAgICAgICB0cmFja0lkcy5wdXNoKGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWROdW1iZXIoVG9rZW4uVUlOVDMyX0JFKSk7XG4gICAgICAgICAgICBsZW4gLT0gVG9rZW4uVUlOVDMyX0JFLmxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2tJZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIHNhbXBsZS1zaXplcyBhdG9tICgnc3RzeicpXG4gICAgICogQHBhcmFtIGxlblxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQXRvbV9zdHN6KGxlbikge1xuICAgICAgICBjb25zdCBzdHN6ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uU3RzekF0b20obGVuKSk7XG4gICAgICAgIGNvbnN0IHRkID0gdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRkLnNhbXBsZVNpemUgPSBzdHN6LnNhbXBsZVNpemU7XG4gICAgICAgIHRkLnNhbXBsZVNpemVUYWJsZSA9IHN0c3ouZW50cmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgY2h1bmstb2Zmc2V0IGF0b20gKCdzdGNvJylcbiAgICAgKiBAcGFyYW0gbGVuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VBdG9tX3N0Y28obGVuKSB7XG4gICAgICAgIGNvbnN0IHN0Y28gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5TdGNvQXRvbShsZW4pKTtcbiAgICAgICAgdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCkuY2h1bmtPZmZzZXRUYWJsZSA9IHN0Y28uZW50cmllczsgLy8gcmVtZW1iZXIgY2h1bmsgb2Zmc2V0c1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtZGF0IGF0b20uXG4gICAgICogV2lsbCBzY2FuIGZvciBjaGFwdGVyc1xuICAgICAqIEBwYXJhbSBsZW5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZUF0b21fbWRhdChsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlQ2hhcHRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrV2l0aENoYXB0ZXJzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmNoYXB0ZXJMaXN0KTtcbiAgICAgICAgICAgIGlmICh0cmFja1dpdGhDaGFwdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFwdGVyVHJhY2tJZHMgPSB0cmFja1dpdGhDaGFwdGVyc1swXS5jaGFwdGVyTGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFwdGVyVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+IGNoYXB0ZXJUcmFja0lkcy5pbmRleE9mKHRyYWNrLnRyYWNrSWQpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXB0ZXJUcmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2hhcHRlclRyYWNrKGNoYXB0ZXJUcmFja3NbMF0sIHRyYWNrV2l0aENoYXB0ZXJzWzBdLCBsZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUobGVuKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VDaGFwdGVyVHJhY2soY2hhcHRlclRyYWNrLCB0cmFjaywgbGVuKSB7XG4gICAgICAgIGlmICghY2hhcHRlclRyYWNrLnNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFwdGVyVHJhY2suY2h1bmtPZmZzZXRUYWJsZS5sZW5ndGgsIGNoYXB0ZXJUcmFjay5zYW1wbGVTaXplVGFibGUubGVuZ3RoLCAnY2h1bmstb2Zmc2V0LXRhYmxlICYgc2FtcGxlLXNpemUtdGFibGUgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcHRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFwdGVyVHJhY2suY2h1bmtPZmZzZXRUYWJsZS5sZW5ndGggJiYgbGVuID4gMDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua09mZnNldCA9IGNoYXB0ZXJUcmFjay5jaHVua09mZnNldFRhYmxlW2ldO1xuICAgICAgICAgICAgY29uc3QgbmV4dENodW5rTGVuID0gY2h1bmtPZmZzZXQgLSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSBjaGFwdGVyVHJhY2suc2FtcGxlU2l6ZSA+IDAgPyBjaGFwdGVyVHJhY2suc2FtcGxlU2l6ZSA6IGNoYXB0ZXJUcmFjay5zYW1wbGVTaXplVGFibGVbaV07XG4gICAgICAgICAgICBsZW4gLT0gbmV4dENodW5rTGVuICsgc2FtcGxlU2l6ZTtcbiAgICAgICAgICAgIGFzc2VydC5vayhsZW4gPj0gMCwgJ0NoYXB0ZXIgY2h1bmsgZXhjZWVkaW5nIHRva2VuIGxlbmd0aCcpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKG5leHRDaHVua0xlbik7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXRvbVRva2VuLkNoYXB0ZXJUZXh0KHNhbXBsZVNpemUpKTtcbiAgICAgICAgICAgIGRlYnVnKGBDaGFwdGVyICR7aSArIDF9OiAke3RpdGxlfWApO1xuICAgICAgICAgICAgY29uc3QgY2hhcHRlciA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQ6IHRoaXMuZmluZFNhbXBsZU9mZnNldCh0cmFjaywgdGhpcy50b2tlbml6ZXIucG9zaXRpb24pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVidWcoYENoYXB0ZXIgdGl0bGU9JHtjaGFwdGVyLnRpdGxlfSwgb2Zmc2V0PSR7Y2hhcHRlci5zYW1wbGVPZmZzZXR9LyR7dGhpcy50cmFja3NbMF0uZHVyYXRpb259YCk7XG4gICAgICAgICAgICBjaGFwdGVycy5wdXNoKGNoYXB0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjaGFwdGVycycsIGNoYXB0ZXJzKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGxlbik7XG4gICAgfVxuICAgIGZpbmRTYW1wbGVPZmZzZXQodHJhY2ssIGNoYXB0ZXJPZmZzZXQpIHtcbiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSAwO1xuICAgICAgICB0cmFjay50aW1lVG9TYW1wbGVUYWJsZS5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSBlLmNvdW50ICogZS5kdXJhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlYnVnKGBUb3RhbCBkdXJhdGlvbj0ke3RvdGFsRHVyYXRpb259YCk7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGNodW5rSW5kZXggPCB0cmFjay5jaHVua09mZnNldFRhYmxlLmxlbmd0aCAmJiB0cmFjay5jaHVua09mZnNldFRhYmxlW2NodW5rSW5kZXhdIDwgY2hhcHRlck9mZnNldCkge1xuICAgICAgICAgICAgKytjaHVua0luZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldENodW5rRHVyYXRpb24oY2h1bmtJbmRleCArIDEsIHRyYWNrKTtcbiAgICB9XG4gICAgZ2V0Q2h1bmtEdXJhdGlvbihjaHVua0lkLCB0cmFjaykge1xuICAgICAgICBsZXQgdHRzaSA9IDA7XG4gICAgICAgIGxldCB0dHNjID0gdHJhY2sudGltZVRvU2FtcGxlVGFibGVbdHRzaV0uY291bnQ7XG4gICAgICAgIGxldCB0dHNkID0gdHJhY2sudGltZVRvU2FtcGxlVGFibGVbdHRzaV0uZHVyYXRpb247XG4gICAgICAgIGxldCBjdXJDaHVua0lkID0gMTtcbiAgICAgICAgbGV0IHNhbXBsZXNQZXJDaHVuayA9IHRoaXMuZ2V0U2FtcGxlc1BlckNodW5rKGN1ckNodW5rSWQsIHRyYWNrLnNhbXBsZVRvQ2h1bmtUYWJsZSk7XG4gICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gMDtcbiAgICAgICAgd2hpbGUgKGN1ckNodW5rSWQgPCBjaHVua0lkKSB7XG4gICAgICAgICAgICBjb25zdCBuck9mU2FtcGxlcyA9IE1hdGgubWluKHR0c2MsIHNhbXBsZXNQZXJDaHVuayk7XG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uICs9IG5yT2ZTYW1wbGVzICogdHRzZDtcbiAgICAgICAgICAgIHR0c2MgLT0gbnJPZlNhbXBsZXM7XG4gICAgICAgICAgICBzYW1wbGVzUGVyQ2h1bmsgLT0gbnJPZlNhbXBsZXM7XG4gICAgICAgICAgICBpZiAoc2FtcGxlc1BlckNodW5rID09PSAwKSB7XG4gICAgICAgICAgICAgICAgKytjdXJDaHVua0lkO1xuICAgICAgICAgICAgICAgIHNhbXBsZXNQZXJDaHVuayA9IHRoaXMuZ2V0U2FtcGxlc1BlckNodW5rKGN1ckNodW5rSWQsIHRyYWNrLnNhbXBsZVRvQ2h1bmtUYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3R0c2k7XG4gICAgICAgICAgICAgICAgdHRzYyA9IHRyYWNrLnRpbWVUb1NhbXBsZVRhYmxlW3R0c2ldLmNvdW50O1xuICAgICAgICAgICAgICAgIHR0c2QgPSB0cmFjay50aW1lVG9TYW1wbGVUYWJsZVt0dHNpXS5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxEdXJhdGlvbjtcbiAgICB9XG4gICAgZ2V0U2FtcGxlc1BlckNodW5rKGNodW5rSWQsIHN0Y1RhYmxlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RjVGFibGUubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtJZCA+PSBzdGNUYWJsZVtpXS5maXJzdENodW5rICYmIGNodW5rSWQgPCBzdGNUYWJsZVtpICsgMV0uZmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGNUYWJsZVtpXS5zYW1wbGVzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0Y1RhYmxlW3N0Y1RhYmxlLmxlbmd0aCAtIDFdLnNhbXBsZXNQZXJDaHVuaztcbiAgICB9XG59XG5leHBvcnRzLk1QNFBhcnNlciA9IE1QNFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1QNFBhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mp4/MP4Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/MP4TagMapper.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/MP4TagMapper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MP4TagMapper = exports.tagType = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * Ref: https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n */\nconst mp4TagMap = {\n    '©nam': 'title',\n    '©ART': 'artist',\n    aART: 'albumartist',\n    /**\n     * ToDo: Album artist seems to be stored here while Picard documentation says: aART\n     */\n    '----:com.apple.iTunes:Band': 'albumartist',\n    '©alb': 'album',\n    '©day': 'date',\n    '©cmt': 'comment',\n    '©com': 'comment',\n    trkn: 'track',\n    disk: 'disk',\n    '©gen': 'genre',\n    covr: 'picture',\n    '©wrt': 'composer',\n    '©lyr': 'lyrics',\n    soal: 'albumsort',\n    sonm: 'titlesort',\n    soar: 'artistsort',\n    soaa: 'albumartistsort',\n    soco: 'composersort',\n    '----:com.apple.iTunes:LYRICIST': 'lyricist',\n    '----:com.apple.iTunes:CONDUCTOR': 'conductor',\n    '----:com.apple.iTunes:REMIXER': 'remixer',\n    '----:com.apple.iTunes:ENGINEER': 'engineer',\n    '----:com.apple.iTunes:PRODUCER': 'producer',\n    '----:com.apple.iTunes:DJMIXER': 'djmixer',\n    '----:com.apple.iTunes:MIXER': 'mixer',\n    '----:com.apple.iTunes:LABEL': 'label',\n    '©grp': 'grouping',\n    '----:com.apple.iTunes:SUBTITLE': 'subtitle',\n    '----:com.apple.iTunes:DISCSUBTITLE': 'discsubtitle',\n    cpil: 'compilation',\n    tmpo: 'bpm',\n    '----:com.apple.iTunes:MOOD': 'mood',\n    '----:com.apple.iTunes:MEDIA': 'media',\n    '----:com.apple.iTunes:CATALOGNUMBER': 'catalognumber',\n    tvsh: 'tvShow',\n    tvsn: 'tvSeason',\n    tves: 'tvEpisode',\n    sosn: 'tvShowSort',\n    tven: 'tvEpisodeId',\n    tvnn: 'tvNetwork',\n    pcst: 'podcast',\n    purl: 'podcasturl',\n    '----:com.apple.iTunes:MusicBrainz Album Status': 'releasestatus',\n    '----:com.apple.iTunes:MusicBrainz Album Type': 'releasetype',\n    '----:com.apple.iTunes:MusicBrainz Album Release Country': 'releasecountry',\n    '----:com.apple.iTunes:SCRIPT': 'script',\n    '----:com.apple.iTunes:LANGUAGE': 'language',\n    cprt: 'copyright',\n    '©cpy': 'copyright',\n    '----:com.apple.iTunes:LICENSE': 'license',\n    '©too': 'encodedby',\n    pgap: 'gapless',\n    '----:com.apple.iTunes:BARCODE': 'barcode',\n    '----:com.apple.iTunes:ISRC': 'isrc',\n    '----:com.apple.iTunes:ASIN': 'asin',\n    '----:com.apple.iTunes:NOTES': 'comment',\n    '----:com.apple.iTunes:MusicBrainz Track Id': 'musicbrainz_recordingid',\n    '----:com.apple.iTunes:MusicBrainz Release Track Id': 'musicbrainz_trackid',\n    '----:com.apple.iTunes:MusicBrainz Album Id': 'musicbrainz_albumid',\n    '----:com.apple.iTunes:MusicBrainz Artist Id': 'musicbrainz_artistid',\n    '----:com.apple.iTunes:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',\n    '----:com.apple.iTunes:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',\n    '----:com.apple.iTunes:MusicBrainz Work Id': 'musicbrainz_workid',\n    '----:com.apple.iTunes:MusicBrainz TRM Id': 'musicbrainz_trmid',\n    '----:com.apple.iTunes:MusicBrainz Disc Id': 'musicbrainz_discid',\n    '----:com.apple.iTunes:Acoustid Id': 'acoustid_id',\n    '----:com.apple.iTunes:Acoustid Fingerprint': 'acoustid_fingerprint',\n    '----:com.apple.iTunes:MusicIP PUID': 'musicip_puid',\n    '----:com.apple.iTunes:fingerprint': 'musicip_fingerprint',\n    '----:com.apple.iTunes:replaygain_track_gain': 'replaygain_track_gain',\n    '----:com.apple.iTunes:replaygain_track_peak': 'replaygain_track_peak',\n    '----:com.apple.iTunes:replaygain_album_gain': 'replaygain_album_gain',\n    '----:com.apple.iTunes:replaygain_album_peak': 'replaygain_album_peak',\n    '----:com.apple.iTunes:replaygain_track_minmax': 'replaygain_track_minmax',\n    '----:com.apple.iTunes:replaygain_album_minmax': 'replaygain_album_minmax',\n    '----:com.apple.iTunes:replaygain_undo': 'replaygain_undo',\n    // Additional mappings:\n    gnre: 'genre',\n    '----:com.apple.iTunes:ALBUMARTISTSORT': 'albumartistsort',\n    '----:com.apple.iTunes:ARTISTS': 'artists',\n    '----:com.apple.iTunes:ORIGINALDATE': 'originaldate',\n    '----:com.apple.iTunes:ORIGINALYEAR': 'originalyear',\n    // '----:com.apple.iTunes:PERFORMER': 'performer'\n    desc: 'subtitle',\n    ldes: 'description',\n    '©mvn': 'movement',\n    '©mvi': 'movementIndex',\n    '©mvc': 'movementTotal',\n    '©wrk': 'work',\n    catg: 'category',\n    egid: 'podcastId',\n    hdvd: 'hdVideo',\n    keyw: 'keywords',\n    shwm: 'showMovement',\n    stik: 'stik'\n};\nexports.tagType = 'iTunes';\nclass MP4TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super([exports.tagType], mp4TagMap);\n    }\n}\nexports.MP4TagMapper = MP4TagMapper;\n//# sourceMappingURL=MP4TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wNC9NUDRUYWdNYXBwZXIuanM/ZmViNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsMEdBQWlDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcDQvTVA0VGFnTWFwcGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1QNFRhZ01hcHBlciA9IGV4cG9ydHMudGFnVHlwZSA9IHZvaWQgMDtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Nlcmdpb21iMi9saWJtcDR2Mi93aWtpL2lUdW5lc01ldGFkYXRhXG4gKi9cbmNvbnN0IG1wNFRhZ01hcCA9IHtcbiAgICAnwqluYW0nOiAndGl0bGUnLFxuICAgICfCqUFSVCc6ICdhcnRpc3QnLFxuICAgIGFBUlQ6ICdhbGJ1bWFydGlzdCcsXG4gICAgLyoqXG4gICAgICogVG9EbzogQWxidW0gYXJ0aXN0IHNlZW1zIHRvIGJlIHN0b3JlZCBoZXJlIHdoaWxlIFBpY2FyZCBkb2N1bWVudGF0aW9uIHNheXM6IGFBUlRcbiAgICAgKi9cbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkJhbmQnOiAnYWxidW1hcnRpc3QnLFxuICAgICfCqWFsYic6ICdhbGJ1bScsXG4gICAgJ8KpZGF5JzogJ2RhdGUnLFxuICAgICfCqWNtdCc6ICdjb21tZW50JyxcbiAgICAnwqljb20nOiAnY29tbWVudCcsXG4gICAgdHJrbjogJ3RyYWNrJyxcbiAgICBkaXNrOiAnZGlzaycsXG4gICAgJ8KpZ2VuJzogJ2dlbnJlJyxcbiAgICBjb3ZyOiAncGljdHVyZScsXG4gICAgJ8Kpd3J0JzogJ2NvbXBvc2VyJyxcbiAgICAnwqlseXInOiAnbHlyaWNzJyxcbiAgICBzb2FsOiAnYWxidW1zb3J0JyxcbiAgICBzb25tOiAndGl0bGVzb3J0JyxcbiAgICBzb2FyOiAnYXJ0aXN0c29ydCcsXG4gICAgc29hYTogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgc29jbzogJ2NvbXBvc2Vyc29ydCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpMWVJJQ0lTVCc6ICdseXJpY2lzdCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpDT05EVUNUT1InOiAnY29uZHVjdG9yJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOlJFTUlYRVInOiAncmVtaXhlcicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpFTkdJTkVFUic6ICdlbmdpbmVlcicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpQUk9EVUNFUic6ICdwcm9kdWNlcicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpESk1JWEVSJzogJ2RqbWl4ZXInLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TUlYRVInOiAnbWl4ZXInLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TEFCRUwnOiAnbGFiZWwnLFxuICAgICfCqWdycCc6ICdncm91cGluZycsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpTVUJUSVRMRSc6ICdzdWJ0aXRsZScsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpESVNDU1VCVElUTEUnOiAnZGlzY3N1YnRpdGxlJyxcbiAgICBjcGlsOiAnY29tcGlsYXRpb24nLFxuICAgIHRtcG86ICdicG0nLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TU9PRCc6ICdtb29kJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk1FRElBJzogJ21lZGlhJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkNBVEFMT0dOVU1CRVInOiAnY2F0YWxvZ251bWJlcicsXG4gICAgdHZzaDogJ3R2U2hvdycsXG4gICAgdHZzbjogJ3R2U2Vhc29uJyxcbiAgICB0dmVzOiAndHZFcGlzb2RlJyxcbiAgICBzb3NuOiAndHZTaG93U29ydCcsXG4gICAgdHZlbjogJ3R2RXBpc29kZUlkJyxcbiAgICB0dm5uOiAndHZOZXR3b3JrJyxcbiAgICBwY3N0OiAncG9kY2FzdCcsXG4gICAgcHVybDogJ3BvZGNhc3R1cmwnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogQWxidW0gU3RhdHVzJzogJ3JlbGVhc2VzdGF0dXMnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogQWxidW0gVHlwZSc6ICdyZWxlYXNldHlwZScsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0JyYWlueiBBbGJ1bSBSZWxlYXNlIENvdW50cnknOiAncmVsZWFzZWNvdW50cnknLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6U0NSSVBUJzogJ3NjcmlwdCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpMQU5HVUFHRSc6ICdsYW5ndWFnZScsXG4gICAgY3BydDogJ2NvcHlyaWdodCcsXG4gICAgJ8KpY3B5JzogJ2NvcHlyaWdodCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpMSUNFTlNFJzogJ2xpY2Vuc2UnLFxuICAgICfCqXRvbyc6ICdlbmNvZGVkYnknLFxuICAgIHBnYXA6ICdnYXBsZXNzJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkJBUkNPREUnOiAnYmFyY29kZScsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpJU1JDJzogJ2lzcmMnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6QVNJTic6ICdhc2luJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk5PVEVTJzogJ2NvbW1lbnQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogVHJhY2sgSWQnOiAnbXVzaWNicmFpbnpfcmVjb3JkaW5naWQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogUmVsZWFzZSBUcmFjayBJZCc6ICdtdXNpY2JyYWluel90cmFja2lkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IEFsYnVtIElkJzogJ211c2ljYnJhaW56X2FsYnVtaWQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FydGlzdGlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IEFsYnVtIEFydGlzdCBJZCc6ICdtdXNpY2JyYWluel9hbGJ1bWFydGlzdGlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IFJlbGVhc2UgR3JvdXAgSWQnOiAnbXVzaWNicmFpbnpfcmVsZWFzZWdyb3VwaWQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogV29yayBJZCc6ICdtdXNpY2JyYWluel93b3JraWQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogVFJNIElkJzogJ211c2ljYnJhaW56X3RybWlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IERpc2MgSWQnOiAnbXVzaWNicmFpbnpfZGlzY2lkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkFjb3VzdGlkIElkJzogJ2Fjb3VzdGlkX2lkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkFjb3VzdGlkIEZpbmdlcnByaW50JzogJ2Fjb3VzdGlkX2ZpbmdlcnByaW50JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljSVAgUFVJRCc6ICdtdXNpY2lwX3B1aWQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6ZmluZ2VycHJpbnQnOiAnbXVzaWNpcF9maW5nZXJwcmludCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX3RyYWNrX2dhaW4nOiAncmVwbGF5Z2Fpbl90cmFja19nYWluJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOnJlcGxheWdhaW5fdHJhY2tfcGVhayc6ICdyZXBsYXlnYWluX3RyYWNrX3BlYWsnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6cmVwbGF5Z2Fpbl9hbGJ1bV9nYWluJzogJ3JlcGxheWdhaW5fYWxidW1fZ2FpbicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX2FsYnVtX3BlYWsnOiAncmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOnJlcGxheWdhaW5fdHJhY2tfbWlubWF4JzogJ3JlcGxheWdhaW5fdHJhY2tfbWlubWF4JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOnJlcGxheWdhaW5fYWxidW1fbWlubWF4JzogJ3JlcGxheWdhaW5fYWxidW1fbWlubWF4JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOnJlcGxheWdhaW5fdW5kbyc6ICdyZXBsYXlnYWluX3VuZG8nLFxuICAgIC8vIEFkZGl0aW9uYWwgbWFwcGluZ3M6XG4gICAgZ25yZTogJ2dlbnJlJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkFMQlVNQVJUSVNUU09SVCc6ICdhbGJ1bWFydGlzdHNvcnQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6QVJUSVNUUyc6ICdhcnRpc3RzJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk9SSUdJTkFMREFURSc6ICdvcmlnaW5hbGRhdGUnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6T1JJR0lOQUxZRUFSJzogJ29yaWdpbmFseWVhcicsXG4gICAgLy8gJy0tLS06Y29tLmFwcGxlLmlUdW5lczpQRVJGT1JNRVInOiAncGVyZm9ybWVyJ1xuICAgIGRlc2M6ICdzdWJ0aXRsZScsXG4gICAgbGRlczogJ2Rlc2NyaXB0aW9uJyxcbiAgICAnwqltdm4nOiAnbW92ZW1lbnQnLFxuICAgICfCqW12aSc6ICdtb3ZlbWVudEluZGV4JyxcbiAgICAnwqltdmMnOiAnbW92ZW1lbnRUb3RhbCcsXG4gICAgJ8Kpd3JrJzogJ3dvcmsnLFxuICAgIGNhdGc6ICdjYXRlZ29yeScsXG4gICAgZWdpZDogJ3BvZGNhc3RJZCcsXG4gICAgaGR2ZDogJ2hkVmlkZW8nLFxuICAgIGtleXc6ICdrZXl3b3JkcycsXG4gICAgc2h3bTogJ3Nob3dNb3ZlbWVudCcsXG4gICAgc3RpazogJ3N0aWsnXG59O1xuZXhwb3J0cy50YWdUeXBlID0gJ2lUdW5lcyc7XG5jbGFzcyBNUDRUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbZXhwb3J0cy50YWdUeXBlXSwgbXA0VGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLk1QNFRhZ01hcHBlciA9IE1QNFRhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1QNFRhZ01hcHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mp4/MP4TagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mpeg/MpegParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/MpegParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpegParser = void 0;\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst XingTag_1 = __webpack_require__(/*! ./XingTag */ \"./node_modules/music-metadata/lib/mpeg/XingTag.js\");\nconst debug = initDebug('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC',\n        'AAC SSR',\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = Util_1.default.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new Error('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new Error('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(`layer=0 => ADTS`);\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = 'ADTS/MPEG-' + this.version;\n        const profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n        this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return;\n        }\n        const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n        return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },\n    2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },\n    2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152],\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.calculateEofDuration = false;\n        this.buf_frame_header = Buffer.alloc(4);\n        this.syncPeek = {\n            buf: Buffer.alloc(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async _parse() {\n        this.metadata.setFormat('lossless', false);\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n                if (this.calculateEofDuration) {\n                    const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    const duration = numberOfSamples / this.metadata.format.sampleRate;\n                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n        if (format.duration && this.tokenizer.fileInfo.size) {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            if (format.codecProfile && format.codecProfile[0] === 'V') {\n                this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n            }\n        }\n        else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            const duration = numberOfSamples / format.sampleRate;\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\n            this.metadata.setFormat('duration', duration);\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new core_1.EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                else {\n                    gotFirstSync = false;\n                    bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                    if (bo === -1) {\n                        if (this.syncPeek.len < this.syncPeek.buf.length) {\n                            throw new core_1.EndOfStreamError();\n                        }\n                        await this.tokenizer.ignore(this.syncPeek.len);\n                        break; // continue with next buffer\n                    }\n                    else {\n                        ++bo;\n                        gotFirstSync = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            this.metadata.addWarning('Parse error: ' + err.message);\n            return false; // sync\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        if (header.version >= 2 && header.layer === 0) {\n            return this.parseAdts(header); // ADTS, usually AAC\n        }\n        else {\n            return this.parseAudioFrameHeader(header); // MP3\n        }\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new Error('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        const fsize = (bps * header.bitrate / header.samplingRate) +\n            ((header.padding) ? slot_size : 0);\n        this.frame_size = Math.floor(fsize);\n        this.audioFrameHeader = header;\n        this.bitrates.push(header.bitrate);\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        else {\n            await this.skipSideInformation();\n            return false;\n        }\n    }\n    async parseAdts(header) {\n        const buf = Buffer.alloc(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        const framesPerSec = header.samplingRate / this.samplesPerFrame;\n        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n        this.metadata.setFormat('bitrate', bitrate);\n        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n        // side information\n        await this.tokenizer.readToken(new Token.BufferType(sideinfo_length));\n        this.offset += sideinfo_length;\n        await this.readXtraInfoHeader();\n        return;\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n        this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing':\n                const infoTag = await this.readXingInfoHeader();\n                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                this.metadata.setFormat('codecProfile', codecProfile);\n                return null;\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME':\n                const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n                if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n                    this.offset += XingTag_1.LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', 'LAME ' + version);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                else {\n                    this.metadata.addWarning('Corrupt LAME header');\n                    break;\n                }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const infoTag = await this.tokenizer.readToken(XingTag_1.XingInfoTag);\n        this.offset += XingTag_1.XingInfoTag.len; // 12\n        this.metadata.setFormat('tool', Util_1.default.stripNulls(infoTag.codec));\n        if ((infoTag.headerFlags[3] & 0x01) === 1) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        assert.ok(frameDataLeft >= 0, 'frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\nexports.MpegParser = MpegParser;\n//# sourceMappingURL=MpegParser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wZWcvTXBlZ1BhcnNlci5qcz81NjU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyw0REFBa0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakMsZUFBZSxtQkFBTyxDQUFDLHdFQUFnQjtBQUN2Qyw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBNEI7QUFDaEUsa0JBQWtCLG1CQUFPLENBQUMsb0VBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxTQUFTLFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixFQUFFLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRCxRQUFRLHdDQUF3QztBQUNoRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Ysc0NBQXNDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNEJBQTRCLGVBQWUsZ0JBQWdCO0FBQ3ZHO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx1QkFBdUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsU0FBUyxtQkFBbUIsbUJBQW1CLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wZWcvTXBlZ1BhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NcGVnUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBpbml0RGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBBYnN0cmFjdElEM1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0Fic3RyYWN0SUQzUGFyc2VyXCIpO1xuY29uc3QgWGluZ1RhZ18xID0gcmVxdWlyZShcIi4vWGluZ1RhZ1wiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXBlZycpO1xuLyoqXG4gKiBDYWNoZSBidWZmZXIgc2l6ZSB1c2VkIGZvciBzZWFyY2hpbmcgc3luY2hyb25pemF0aW9uIHByZWFibWxlXG4gKi9cbmNvbnN0IG1heFBlZWtMZW4gPSAxMDI0O1xuLyoqXG4gKiBNUEVHLTQgQXVkaW8gZGVmaW5pdGlvbnNcbiAqIFJlZjogIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9NUEVHLTRfQXVkaW9cbiAqL1xuY29uc3QgTVBFRzQgPSB7XG4gICAgLyoqXG4gICAgICogQXVkaW8gT2JqZWN0IFR5cGVzXG4gICAgICovXG4gICAgQXVkaW9PYmplY3RUeXBlczogW1xuICAgICAgICAnQUFDIE1haW4nLFxuICAgICAgICAnQUFDIExDJyxcbiAgICAgICAgJ0FBQyBTU1InLFxuICAgICAgICAnQUFDIExUUCcgLy8gTG9uZyBUZXJtIFByZWRpY3Rpb25cbiAgICBdLFxuICAgIC8qKlxuICAgICAqIFNhbXBsaW5nIEZyZXF1ZW5jaWVzXG4gICAgICogaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwL01QRUctNF9BdWRpbyNTYW1wbGluZ19GcmVxdWVuY2llc1xuICAgICAqL1xuICAgIFNhbXBsaW5nRnJlcXVlbmNpZXM6IFtcbiAgICAgICAgOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgLTFcbiAgICBdXG4gICAgLyoqXG4gICAgICogQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgICAqL1xufTtcbmNvbnN0IE1QRUc0X0NoYW5uZWxDb25maWd1cmF0aW9ucyA9IFtcbiAgICB1bmRlZmluZWQsXG4gICAgWydmcm9udC1jZW50ZXInXSxcbiAgICBbJ2Zyb250LWxlZnQnLCAnZnJvbnQtcmlnaHQnXSxcbiAgICBbJ2Zyb250LWNlbnRlcicsICdmcm9udC1sZWZ0JywgJ2Zyb250LXJpZ2h0J10sXG4gICAgWydmcm9udC1jZW50ZXInLCAnZnJvbnQtbGVmdCcsICdmcm9udC1yaWdodCcsICdiYWNrLWNlbnRlciddLFxuICAgIFsnZnJvbnQtY2VudGVyJywgJ2Zyb250LWxlZnQnLCAnZnJvbnQtcmlnaHQnLCAnYmFjay1sZWZ0JywgJ2JhY2stcmlnaHQnXSxcbiAgICBbJ2Zyb250LWNlbnRlcicsICdmcm9udC1sZWZ0JywgJ2Zyb250LXJpZ2h0JywgJ2JhY2stbGVmdCcsICdiYWNrLXJpZ2h0JywgJ0xGRS1jaGFubmVsJ10sXG4gICAgWydmcm9udC1jZW50ZXInLCAnZnJvbnQtbGVmdCcsICdmcm9udC1yaWdodCcsICdzaWRlLWxlZnQnLCAnc2lkZS1yaWdodCcsICdiYWNrLWxlZnQnLCAnYmFjay1yaWdodCcsICdMRkUtY2hhbm5lbCddXG5dO1xuLyoqXG4gKiBNUEVHIEF1ZGlvIExheWVyIEkvSUkvSUlJIGZyYW1lIGhlYWRlclxuICogUmVmOiBodHRwczovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICogQml0IGxheW91dDogQUFBQUFBQUEgQUFBQkJDQ0QgRUVFRUZGR0ggSUlKSktMTU1cbiAqIFJlZjogaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwL0FEVFNcbiAqL1xuY2xhc3MgTXBlZ0ZyYW1lSGVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYsIG9mZikge1xuICAgICAgICAvLyBCKDIwLDE5KTogTVBFRyBBdWRpbyB2ZXJzaW9uSW5kZXggSURcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5kZXggPSBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEsIDMsIDIpO1xuICAgICAgICAvLyBDKDE4LDE3KTogTGF5ZXIgZGVzY3JpcHRpb25cbiAgICAgICAgdGhpcy5sYXllciA9IE1wZWdGcmFtZUhlYWRlci5MYXllckRlc2NyaXB0aW9uW1V0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMSwgNSwgMildO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uSW5kZXggPiAxICYmIHRoaXMubGF5ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VBZHRzSGVhZGVyKGJ1Ziwgb2ZmKTsgLy8gQXVkaW8gRGF0YSBUcmFuc3BvcnQgU3RyZWFtIChBRFRTKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZU1wZWdIZWFkZXIoYnVmLCBvZmYpOyAvLyBDb252ZW50aW9uYWwgTVBFRyBoZWFkZXJcbiAgICAgICAgfVxuICAgICAgICAvLyBEKDE2KTogUHJvdGVjdGlvbiBiaXQgKGlmIHRydWUgMTYtYml0IENSQyBmb2xsb3dzIGhlYWRlcilcbiAgICAgICAgdGhpcy5pc1Byb3RlY3RlZEJ5Q1JDID0gIVV0aWxfMS5kZWZhdWx0LmlzQml0U2V0KGJ1Ziwgb2ZmICsgMSwgNyk7XG4gICAgfVxuICAgIGNhbGNEdXJhdGlvbihudW1GcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bUZyYW1lcyAqIHRoaXMuY2FsY1NhbXBsZXNQZXJGcmFtZSgpIC8gdGhpcy5zYW1wbGluZ1JhdGU7XG4gICAgfVxuICAgIGNhbGNTYW1wbGVzUGVyRnJhbWUoKSB7XG4gICAgICAgIHJldHVybiBNcGVnRnJhbWVIZWFkZXIuc2FtcGxlc0luRnJhbWVUYWJsZVt0aGlzLnZlcnNpb24gPT09IDEgPyAwIDogMV1bdGhpcy5sYXllcl07XG4gICAgfVxuICAgIGNhbGN1bGF0ZVNpZGVJbmZvTGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy5sYXllciAhPT0gMylcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsTW9kZUluZGV4ID09PSAzKSB7XG4gICAgICAgICAgICAvLyBtb25vXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAyIHx8IHRoaXMudmVyc2lvbiA9PT0gMi41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAyIHx8IHRoaXMudmVyc2lvbiA9PT0gMi41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGNTbG90U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCA0LCAxLCAxXVt0aGlzLmxheWVyXTtcbiAgICB9XG4gICAgcGFyc2VNcGVnSGVhZGVyKGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gJ01QRUcnO1xuICAgICAgICAvLyBFKDE1LDEyKTogQml0cmF0ZSBpbmRleFxuICAgICAgICB0aGlzLmJpdHJhdGVJbmRleCA9IFV0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMiwgMCwgNCk7XG4gICAgICAgIC8vIEYoMTEsMTApOiBTYW1wbGluZyByYXRlIGZyZXF1ZW5jeSBpbmRleFxuICAgICAgICB0aGlzLnNhbXBSYXRlRnJlcUluZGV4ID0gVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAyLCA0LCAyKTtcbiAgICAgICAgLy8gRyg5KTogUGFkZGluZyBiaXRcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gVXRpbF8xLmRlZmF1bHQuaXNCaXRTZXQoYnVmLCBvZmYgKyAyLCA2KTtcbiAgICAgICAgLy8gSCg4KTogUHJpdmF0ZSBiaXRcbiAgICAgICAgdGhpcy5wcml2YXRlQml0ID0gVXRpbF8xLmRlZmF1bHQuaXNCaXRTZXQoYnVmLCBvZmYgKyAyLCA3KTtcbiAgICAgICAgLy8gSSg3LDYpOiBDaGFubmVsIE1vZGVcbiAgICAgICAgdGhpcy5jaGFubmVsTW9kZUluZGV4ID0gVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCAwLCAyKTtcbiAgICAgICAgLy8gSig1LDQpOiBNb2RlIGV4dGVuc2lvbiAoT25seSB1c2VkIGluIEpvaW50IHN0ZXJlbylcbiAgICAgICAgdGhpcy5tb2RlRXh0ZW5zaW9uID0gVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCAyLCAyKTtcbiAgICAgICAgLy8gSygzKTogQ29weXJpZ2h0XG4gICAgICAgIHRoaXMuaXNDb3B5cmlnaHRlZCA9IFV0aWxfMS5kZWZhdWx0LmlzQml0U2V0KGJ1Ziwgb2ZmICsgMywgNCk7XG4gICAgICAgIC8vIEwoMik6IE9yaWdpbmFsXG4gICAgICAgIHRoaXMuaXNPcmlnaW5hbE1lZGlhID0gVXRpbF8xLmRlZmF1bHQuaXNCaXRTZXQoYnVmLCBvZmYgKyAzLCA1KTtcbiAgICAgICAgLy8gTSgzKTogVGhlIG9yaWdpbmFsIGJpdCBpbmRpY2F0ZXMsIGlmIGl0IGlzIHNldCwgdGhhdCB0aGUgZnJhbWUgaXMgbG9jYXRlZCBvbiBpdHMgb3JpZ2luYWwgbWVkaWEuXG4gICAgICAgIHRoaXMuZW1waGFzaXMgPSBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDMsIDcsIDIpO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBNcGVnRnJhbWVIZWFkZXIuVmVyc2lvbklEW3RoaXMudmVyc2lvbkluZGV4XTtcbiAgICAgICAgdGhpcy5jaGFubmVsTW9kZSA9IE1wZWdGcmFtZUhlYWRlci5DaGFubmVsTW9kZVt0aGlzLmNoYW5uZWxNb2RlSW5kZXhdO1xuICAgICAgICB0aGlzLmNvZGVjID0gYE1QRUcgJHt0aGlzLnZlcnNpb259IExheWVyICR7dGhpcy5sYXllcn1gO1xuICAgICAgICAvLyBDYWxjdWxhdGUgYml0cmF0ZVxuICAgICAgICBjb25zdCBiaXRyYXRlSW5LYnBzID0gdGhpcy5jYWxjQml0cmF0ZSgpO1xuICAgICAgICBpZiAoIWJpdHJhdGVJbkticHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRldGVybWluZSBiaXQtcmF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYml0cmF0ZSA9IGJpdHJhdGVJbkticHMgKiAxMDAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgc2FtcGxpbmcgcmF0ZVxuICAgICAgICB0aGlzLnNhbXBsaW5nUmF0ZSA9IHRoaXMuY2FsY1NhbXBsaW5nUmF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5zYW1wbGluZ1JhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0ZXJtaW5lIHNhbXBsaW5nLXJhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUFkdHNIZWFkZXIoYnVmLCBvZmYpIHtcbiAgICAgICAgZGVidWcoYGxheWVyPTAgPT4gQURUU2ApO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB0aGlzLnZlcnNpb25JbmRleCA9PT0gMiA/IDQgOiAyO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICdBRFRTL01QRUctJyArIHRoaXMudmVyc2lvbjtcbiAgICAgICAgY29uc3QgcHJvZmlsZUluZGV4ID0gVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAyLCAwLCAyKTtcbiAgICAgICAgdGhpcy5jb2RlYyA9ICdBQUMnO1xuICAgICAgICB0aGlzLmNvZGVjUHJvZmlsZSA9IE1QRUc0LkF1ZGlvT2JqZWN0VHlwZXNbcHJvZmlsZUluZGV4XTtcbiAgICAgICAgZGVidWcoYE1QRUctNCBhdWRpby1jb2RlYz0ke3RoaXMuY29kZWN9YCk7XG4gICAgICAgIGNvbnN0IHNhbXBsaW5nRnJlcXVlbmN5SW5kZXggPSBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDIsIDIsIDQpO1xuICAgICAgICB0aGlzLnNhbXBsaW5nUmF0ZSA9IE1QRUc0LlNhbXBsaW5nRnJlcXVlbmNpZXNbc2FtcGxpbmdGcmVxdWVuY3lJbmRleF07XG4gICAgICAgIGRlYnVnKGBzYW1wbGluZy1yYXRlPSR7dGhpcy5zYW1wbGluZ1JhdGV9YCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxJbmRleCA9IFV0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMiwgNywgMyk7XG4gICAgICAgIHRoaXMubXA0Q2hhbm5lbENvbmZpZyA9IE1QRUc0X0NoYW5uZWxDb25maWd1cmF0aW9uc1tjaGFubmVsSW5kZXhdO1xuICAgICAgICBkZWJ1ZyhgY2hhbm5lbC1jb25maWc9JHt0aGlzLm1wNENoYW5uZWxDb25maWcuam9pbignKycpfWApO1xuICAgICAgICB0aGlzLmZyYW1lTGVuZ3RoID0gVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCA2LCAyKSA8PCAxMTtcbiAgICB9XG4gICAgY2FsY0JpdHJhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJpdHJhdGVJbmRleCA9PT0gMHgwMCB8fCAvLyBmcmVlXG4gICAgICAgICAgICB0aGlzLmJpdHJhdGVJbmRleCA9PT0gMHgwRikgeyAvLyByZXNlcnZlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVjSW5kZXggPSBgJHtNYXRoLmZsb29yKHRoaXMudmVyc2lvbil9JHt0aGlzLmxheWVyfWA7XG4gICAgICAgIHJldHVybiBNcGVnRnJhbWVIZWFkZXIuYml0cmF0ZV9pbmRleFt0aGlzLmJpdHJhdGVJbmRleF1bY29kZWNJbmRleF07XG4gICAgfVxuICAgIGNhbGNTYW1wbGluZ1JhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNhbXBSYXRlRnJlcUluZGV4ID09PSAweDAzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vICdyZXNlcnZlZCdcbiAgICAgICAgcmV0dXJuIE1wZWdGcmFtZUhlYWRlci5zYW1wbGluZ19yYXRlX2ZyZXFfaW5kZXhbdGhpcy52ZXJzaW9uXVt0aGlzLnNhbXBSYXRlRnJlcUluZGV4XTtcbiAgICB9XG59XG5NcGVnRnJhbWVIZWFkZXIuU3luY0J5dGUxID0gMHhGRjtcbk1wZWdGcmFtZUhlYWRlci5TeW5jQnl0ZTIgPSAweEUwO1xuTXBlZ0ZyYW1lSGVhZGVyLlZlcnNpb25JRCA9IFsyLjUsIG51bGwsIDIsIDFdO1xuTXBlZ0ZyYW1lSGVhZGVyLkxheWVyRGVzY3JpcHRpb24gPSBbMCwgMywgMiwgMV07XG5NcGVnRnJhbWVIZWFkZXIuQ2hhbm5lbE1vZGUgPSBbJ3N0ZXJlbycsICdqb2ludF9zdGVyZW8nLCAnZHVhbF9jaGFubmVsJywgJ21vbm8nXTtcbk1wZWdGcmFtZUhlYWRlci5iaXRyYXRlX2luZGV4ID0ge1xuICAgIDB4MDE6IHsgMTE6IDMyLCAxMjogMzIsIDEzOiAzMiwgMjE6IDMyLCAyMjogOCwgMjM6IDggfSxcbiAgICAweDAyOiB7IDExOiA2NCwgMTI6IDQ4LCAxMzogNDAsIDIxOiA0OCwgMjI6IDE2LCAyMzogMTYgfSxcbiAgICAweDAzOiB7IDExOiA5NiwgMTI6IDU2LCAxMzogNDgsIDIxOiA1NiwgMjI6IDI0LCAyMzogMjQgfSxcbiAgICAweDA0OiB7IDExOiAxMjgsIDEyOiA2NCwgMTM6IDU2LCAyMTogNjQsIDIyOiAzMiwgMjM6IDMyIH0sXG4gICAgMHgwNTogeyAxMTogMTYwLCAxMjogODAsIDEzOiA2NCwgMjE6IDgwLCAyMjogNDAsIDIzOiA0MCB9LFxuICAgIDB4MDY6IHsgMTE6IDE5MiwgMTI6IDk2LCAxMzogODAsIDIxOiA5NiwgMjI6IDQ4LCAyMzogNDggfSxcbiAgICAweDA3OiB7IDExOiAyMjQsIDEyOiAxMTIsIDEzOiA5NiwgMjE6IDExMiwgMjI6IDU2LCAyMzogNTYgfSxcbiAgICAweDA4OiB7IDExOiAyNTYsIDEyOiAxMjgsIDEzOiAxMTIsIDIxOiAxMjgsIDIyOiA2NCwgMjM6IDY0IH0sXG4gICAgMHgwOTogeyAxMTogMjg4LCAxMjogMTYwLCAxMzogMTI4LCAyMTogMTQ0LCAyMjogODAsIDIzOiA4MCB9LFxuICAgIDB4MEE6IHsgMTE6IDMyMCwgMTI6IDE5MiwgMTM6IDE2MCwgMjE6IDE2MCwgMjI6IDk2LCAyMzogOTYgfSxcbiAgICAweDBCOiB7IDExOiAzNTIsIDEyOiAyMjQsIDEzOiAxOTIsIDIxOiAxNzYsIDIyOiAxMTIsIDIzOiAxMTIgfSxcbiAgICAweDBDOiB7IDExOiAzODQsIDEyOiAyNTYsIDEzOiAyMjQsIDIxOiAxOTIsIDIyOiAxMjgsIDIzOiAxMjggfSxcbiAgICAweDBEOiB7IDExOiA0MTYsIDEyOiAzMjAsIDEzOiAyNTYsIDIxOiAyMjQsIDIyOiAxNDQsIDIzOiAxNDQgfSxcbiAgICAweDBFOiB7IDExOiA0NDgsIDEyOiAzODQsIDEzOiAzMjAsIDIxOiAyNTYsIDIyOiAxNjAsIDIzOiAxNjAgfVxufTtcbk1wZWdGcmFtZUhlYWRlci5zYW1wbGluZ19yYXRlX2ZyZXFfaW5kZXggPSB7XG4gICAgMTogeyAweDAwOiA0NDEwMCwgMHgwMTogNDgwMDAsIDB4MDI6IDMyMDAwIH0sXG4gICAgMjogeyAweDAwOiAyMjA1MCwgMHgwMTogMjQwMDAsIDB4MDI6IDE2MDAwIH0sXG4gICAgMi41OiB7IDB4MDA6IDExMDI1LCAweDAxOiAxMjAwMCwgMHgwMjogODAwMCB9XG59O1xuTXBlZ0ZyYW1lSGVhZGVyLnNhbXBsZXNJbkZyYW1lVGFibGUgPSBbXG4gICAgLyogTGF5ZXIgICBJICAgIElJICAgSUlJICovXG4gICAgWzAsIDM4NCwgMTE1MiwgMTE1Ml0sXG4gICAgWzAsIDM4NCwgMTE1MiwgNTc2XSAvLyBNUEVHLTIoLjVcbl07XG4vKipcbiAqIE1QRUcgQXVkaW8gTGF5ZXIgSS9JSS9JSUlcbiAqL1xuY29uc3QgRnJhbWVIZWFkZXIgPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgTXBlZ0ZyYW1lSGVhZGVyKGJ1Ziwgb2ZmKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0VmJyQ29kZWNQcm9maWxlKHZiclNjYWxlKSB7XG4gICAgcmV0dXJuICdWJyArIE1hdGguZmxvb3IoKDEwMCAtIHZiclNjYWxlKSAvIDEwKTtcbn1cbmNsYXNzIE1wZWdQYXJzZXIgZXh0ZW5kcyBBYnN0cmFjdElEM1BhcnNlcl8xLkFic3RyYWN0SUQzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zeW5jRnJhbWVDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLmNvdW50U2tpcEZyYW1lRGF0YSA9IDA7XG4gICAgICAgIHRoaXMudG90YWxEYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5iaXRyYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUVvZkR1cmF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmX2ZyYW1lX2hlYWRlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5zeW5jUGVlayA9IHtcbiAgICAgICAgICAgIGJ1ZjogQnVmZmVyLmFsbG9jKG1heFBlZWtMZW4pLFxuICAgICAgICAgICAgbGVuOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciBJRDMgaGVhZGVycyBoYXZlIGJlZW4gcGFyc2VkXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCBmYWxzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcXVpdCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zeW5jKCk7XG4gICAgICAgICAgICAgICAgcXVpdCA9IGF3YWl0IHRoaXMucGFyc2VDb21tb25NcGVnSGVhZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGNvcmVfMS5FbmRPZlN0cmVhbUVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoYEVuZC1vZi1zdHJlYW1gKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVFb2ZEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlNhbXBsZXMgPSB0aGlzLmZyYW1lQ291bnQgKiB0aGlzLnNhbXBsZXNQZXJGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mU2FtcGxlcycsIG51bWJlck9mU2FtcGxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gbnVtYmVyT2ZTYW1wbGVzIC8gdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYENhbGN1bGF0ZSBkdXJhdGlvbiBhdCBFT0Y6ICR7ZHVyYXRpb259IHNlYy5gLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIGZpbGUgaGFzIGJlZW4gZnVsbHkgcGFyc2VkLCB0aGlzIGFsbG93cywgaWYgcHJlc2VudCwgdG8gZXhjbHVkZSB0aGUgSUQzdjEuMSBoZWFkZXIgbGVuZ3RoXG4gICAgICovXG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMubWV0YWRhdGEuZm9ybWF0O1xuICAgICAgICBjb25zdCBoYXNJRDN2MSA9IHRoaXMubWV0YWRhdGEubmF0aXZlLmhhc093blByb3BlcnR5KCdJRDN2MScpO1xuICAgICAgICBpZiAoZm9ybWF0LmR1cmF0aW9uICYmIHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1wZWdTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMubXBlZ09mZnNldCAtIChoYXNJRDN2MSA/IDEyOCA6IDApO1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5jb2RlY1Byb2ZpbGUgJiYgZm9ybWF0LmNvZGVjUHJvZmlsZVswXSA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBtcGVnU2l6ZSAqIDggLyBmb3JtYXQuZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgJiYgZm9ybWF0LmNvZGVjUHJvZmlsZSA9PT0gJ0NCUicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1wZWdTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMubXBlZ09mZnNldCAtIChoYXNJRDN2MSA/IDEyOCA6IDApO1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZTYW1wbGVzID0gTWF0aC5yb3VuZChtcGVnU2l6ZSAvIHRoaXMuZnJhbWVfc2l6ZSkgKiB0aGlzLnNhbXBsZXNQZXJGcmFtZTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBudW1iZXJPZlNhbXBsZXMpO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBudW1iZXJPZlNhbXBsZXMgLyBmb3JtYXQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIGRlYnVnKFwiQ2FsY3VsYXRlIENCUiBkdXJhdGlvbiBiYXNlZCBvbiBmaWxlIHNpemU6ICVzXCIsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzeW5jKCkge1xuICAgICAgICBsZXQgZ290Rmlyc3RTeW5jID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgYm8gPSAwO1xuICAgICAgICAgICAgdGhpcy5zeW5jUGVlay5sZW4gPSBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrQnVmZmVyKHRoaXMuc3luY1BlZWsuYnVmLCB7IGxlbmd0aDogbWF4UGVla0xlbiwgbWF5QmVMZXNzOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3luY1BlZWsubGVuIDw9IDE2Mykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ290Rmlyc3RTeW5jICYmICh0aGlzLnN5bmNQZWVrLmJ1Zltib10gJiAweEUwKSA9PT0gMHhFMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1Zl9mcmFtZV9oZWFkZXJbMF0gPSBNcGVnRnJhbWVIZWFkZXIuU3luY0J5dGUxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1Zl9mcmFtZV9oZWFkZXJbMV0gPSB0aGlzLnN5bmNQZWVrLmJ1Zltib107XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShibyk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBTeW5jIGF0IG9mZnNldD0ke3RoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gMX0sIGZyYW1lQ291bnQ9JHt0aGlzLmZyYW1lQ291bnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN5bmNGcmFtZUNvdW50ID09PSB0aGlzLmZyYW1lQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKGBSZS1zeW5jZWQgTVBFRyBzdHJlYW0sIGZyYW1lQ291bnQ9JHt0aGlzLmZyYW1lQ291bnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZV9zaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNGcmFtZUNvdW50ID0gdGhpcy5mcmFtZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHN5bmNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdvdEZpcnN0U3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBibyA9IHRoaXMuc3luY1BlZWsuYnVmLmluZGV4T2YoTXBlZ0ZyYW1lSGVhZGVyLlN5bmNCeXRlMSwgYm8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm8gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW5jUGVlay5sZW4gPCB0aGlzLnN5bmNQZWVrLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSh0aGlzLnN5bmNQZWVrLmxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gY29udGludWUgd2l0aCBuZXh0IGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytibztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdEZpcnN0U3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZWQgQURUUyAmIE1QRUcgKE1QMiAmIE1QMykgaGVhZGVyIGhhbmRsaW5nXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSBpZiBwYXJzZXIgc2hvdWxkIHF1aXRcbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZUNvbW1vbk1wZWdIZWFkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubXBlZ09mZnNldCA9IHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrQnVmZmVyKHRoaXMuYnVmX2ZyYW1lX2hlYWRlciwgeyBvZmZzZXQ6IDEsIGxlbmd0aDogMyB9KTtcbiAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhlYWRlciA9IEZyYW1lSGVhZGVyLmdldCh0aGlzLmJ1Zl9mcmFtZV9oZWFkZXIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSgxKTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnUGFyc2UgZXJyb3I6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHN5bmNcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoMyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCBoZWFkZXIuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgaGVhZGVyLmNvZGVjKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgZmFsc2UpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGhlYWRlci5zYW1wbGluZ1JhdGUpO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQrKztcbiAgICAgICAgaWYgKGhlYWRlci52ZXJzaW9uID49IDIgJiYgaGVhZGVyLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFkdHMoaGVhZGVyKTsgLy8gQURUUywgdXN1YWxseSBBQUNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXVkaW9GcmFtZUhlYWRlcihoZWFkZXIpOyAvLyBNUDNcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIGlmIHBhcnNlciBzaG91bGQgcXVpdFxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQXVkaW9GcmFtZUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBoZWFkZXIuY2hhbm5lbE1vZGUgPT09ICdtb25vJyA/IDEgOiAyKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBoZWFkZXIuYml0cmF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPCAyMCAqIDEwMDAwKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb2Zmc2V0PSVzIE1QJXMgYml0cmF0ZT0lcyBzYW1wbGUtcmF0ZT0lcycsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gNCwgaGVhZGVyLmxheWVyLCBoZWFkZXIuYml0cmF0ZSwgaGVhZGVyLnNhbXBsaW5nUmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xvdF9zaXplID0gaGVhZGVyLmNhbGNTbG90U2l6ZSgpO1xuICAgICAgICBpZiAoc2xvdF9zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2xvdF9zaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtcGxlc19wZXJfZnJhbWUgPSBoZWFkZXIuY2FsY1NhbXBsZXNQZXJGcmFtZSgpO1xuICAgICAgICBkZWJ1Zyhgc2FtcGxlc19wZXJfZnJhbWU9JHtzYW1wbGVzX3Blcl9mcmFtZX1gKTtcbiAgICAgICAgY29uc3QgYnBzID0gc2FtcGxlc19wZXJfZnJhbWUgLyA4LjA7XG4gICAgICAgIGNvbnN0IGZzaXplID0gKGJwcyAqIGhlYWRlci5iaXRyYXRlIC8gaGVhZGVyLnNhbXBsaW5nUmF0ZSkgK1xuICAgICAgICAgICAgKChoZWFkZXIucGFkZGluZykgPyBzbG90X3NpemUgOiAwKTtcbiAgICAgICAgdGhpcy5mcmFtZV9zaXplID0gTWF0aC5mbG9vcihmc2l6ZSk7XG4gICAgICAgIHRoaXMuYXVkaW9GcmFtZUhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5iaXRyYXRlcy5wdXNoKGhlYWRlci5iaXRyYXRlKTtcbiAgICAgICAgLy8geHRyYSBoZWFkZXIgb25seSBleGlzdHMgaW4gZmlyc3QgZnJhbWVcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBGcmFtZUhlYWRlci5sZW47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNraXBTaWRlSW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFtZUNvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RyZWFtIGlzIENCUiBpZiB0aGUgZmlyc3QgMyBmcmFtZSBiaXRyYXRlcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZUFsbFNhbWUodGhpcy5iaXRyYXRlcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWwgY2FsY3VsYXRpb24gd2lsbCBiZSBkb25lIGluIGZpbmFsaXplXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVzX3Blcl9mcmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWNQcm9maWxlJywgJ0NCUicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gV2lsbCBjYWxjdWxhdGUgZHVyYXRpb24gYmFzZWQgb24gdGhlIGZpbGUgc2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gV2UgYWxyZWFkeSBnb3QgdGhlIGR1cmF0aW9uLCBzdG9wIHByb2Nlc3NpbmcgTVBFRyBzdHJlYW0gYW55IGZ1cnRoZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEVuZm9yY2UgZHVyYXRpb24gbm90IGVuYWJsZWQsIHN0b3AgcHJvY2Vzc2luZyBlbnRpcmUgc3RyZWFtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25jZSB3ZSBrbm93IHRoZSBmaWxlIGlzIFZCUiBhdHRhY2ggbGlzdGVuZXIgdG8gZW5kIG9mXG4gICAgICAgIC8vIHN0cmVhbSBzbyB3ZSBjYW4gZG8gdGhlIGR1cmF0aW9uIGNhbGN1bGF0aW9uIHdoZW4gd2VcbiAgICAgICAgLy8gaGF2ZSBjb3VudGVkIGFsbCB0aGUgZnJhbWVzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gJiYgdGhpcy5mcmFtZUNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZXNfcGVyX2ZyYW1lO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVFb2ZEdXJhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSA0O1xuICAgICAgICBpZiAoaGVhZGVyLmlzUHJvdGVjdGVkQnlDUkMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VDcmMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2tpcFNpZGVJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQWR0cyhoZWFkZXIpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDMpO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkQnVmZmVyKGJ1Zik7XG4gICAgICAgIGhlYWRlci5mcmFtZUxlbmd0aCArPSBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIDAsIDAsIDExKTtcbiAgICAgICAgdGhpcy50b3RhbERhdGFMZW5ndGggKz0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgICAgICB0aGlzLnNhbXBsZXNQZXJGcmFtZSA9IDEwMjQ7XG4gICAgICAgIGNvbnN0IGZyYW1lc1BlclNlYyA9IGhlYWRlci5zYW1wbGluZ1JhdGUgLyB0aGlzLnNhbXBsZXNQZXJGcmFtZTtcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJGcmFtZSA9IHRoaXMuZnJhbWVDb3VudCA9PT0gMCA/IDAgOiB0aGlzLnRvdGFsRGF0YUxlbmd0aCAvIHRoaXMuZnJhbWVDb3VudDtcbiAgICAgICAgY29uc3QgYml0cmF0ZSA9IDggKiBieXRlc1BlckZyYW1lICogZnJhbWVzUGVyU2VjICsgMC41O1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGJpdHJhdGUpO1xuICAgICAgICBkZWJ1ZyhgZnJhbWUtY291bnQ9JHt0aGlzLmZyYW1lQ291bnR9LCBzaXplPSR7aGVhZGVyLmZyYW1lTGVuZ3RofSBieXRlcywgYml0LXJhdGU9JHtiaXRyYXRlfWApO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoaGVhZGVyLmZyYW1lTGVuZ3RoID4gNyA/IGhlYWRlci5mcmFtZUxlbmd0aCAtIDcgOiAxKTtcbiAgICAgICAgLy8gQ29uc3VtZSByZW1haW5pbmcgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlY1Byb2ZpbGUnLCBoZWFkZXIuY29kZWNQcm9maWxlKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIubXA0Q2hhbm5lbENvbmZpZykge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaGVhZGVyLm1wNENoYW5uZWxDb25maWcubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUVvZkR1cmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTdG9wIHBhcnNpbmcgYWZ0ZXIgdGhlIHRoaXJkIGZyYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUNyYygpIHtcbiAgICAgICAgdGhpcy5jcmMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLklOVDE2X0JFKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcFNpZGVJbmZvcm1hdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBza2lwU2lkZUluZm9ybWF0aW9uKCkge1xuICAgICAgICBjb25zdCBzaWRlaW5mb19sZW5ndGggPSB0aGlzLmF1ZGlvRnJhbWVIZWFkZXIuY2FsY3VsYXRlU2lkZUluZm9MZW5ndGgoKTtcbiAgICAgICAgLy8gc2lkZSBpbmZvcm1hdGlvblxuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLkJ1ZmZlclR5cGUoc2lkZWluZm9fbGVuZ3RoKSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IHNpZGVpbmZvX2xlbmd0aDtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkWHRyYUluZm9IZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyByZWFkWHRyYUluZm9IZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlclRhZyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihYaW5nVGFnXzEuSW5mb1RhZ0hlYWRlclRhZyk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IFhpbmdUYWdfMS5JbmZvVGFnSGVhZGVyVGFnLmxlbjsgLy8gMTJcbiAgICAgICAgc3dpdGNoIChoZWFkZXJUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ0luZm8nOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlY1Byb2ZpbGUnLCAnQ0JSJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFhpbmdJbmZvSGVhZGVyKCk7XG4gICAgICAgICAgICBjYXNlICdYaW5nJzpcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvVGFnID0gYXdhaXQgdGhpcy5yZWFkWGluZ0luZm9IZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1Byb2ZpbGUgPSBnZXRWYnJDb2RlY1Byb2ZpbGUoaW5mb1RhZy52YnJTY2FsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjUHJvZmlsZScsIGNvZGVjUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlICdYdHJhJzpcbiAgICAgICAgICAgICAgICAvLyBUb0RvOiA/Pz9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xBTUUnOlxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oWGluZ1RhZ18xLkxhbWVFbmNvZGVyVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVfc2l6ZSA+PSB0aGlzLm9mZnNldCArIFhpbmdUYWdfMS5MYW1lRW5jb2RlclZlcnNpb24ubGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IFhpbmdUYWdfMS5MYW1lRW5jb2RlclZlcnNpb24ubGVuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgndG9vbCcsICdMQU1FICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5za2lwRnJhbWVEYXRhKHRoaXMuZnJhbWVfc2l6ZSAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0NvcnJ1cHQgTEFNRSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9EbzogPz8/XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9EbzogcHJvbWlzZSBkdXJhdGlvbj8/P1xuICAgICAgICBjb25zdCBmcmFtZURhdGFMZWZ0ID0gdGhpcy5mcmFtZV9zaXplIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChmcmFtZURhdGFMZWZ0IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdGcmFtZSAnICsgdGhpcy5mcmFtZUNvdW50ICsgJ2NvcnJ1cHQ6IG5lZ2F0aXZlIGZyYW1lRGF0YUxlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2tpcEZyYW1lRGF0YShmcmFtZURhdGFMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmOiBodHRwOi8vZ2FicmllbC5tcDMtdGVjaC5vcmcvbXAzaW5mb3RhZy5odG1sXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBhc3luYyByZWFkWGluZ0luZm9IZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGluZm9UYWcgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oWGluZ1RhZ18xLlhpbmdJbmZvVGFnKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gWGluZ1RhZ18xLlhpbmdJbmZvVGFnLmxlbjsgLy8gMTJcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3Rvb2wnLCBVdGlsXzEuZGVmYXVsdC5zdHJpcE51bGxzKGluZm9UYWcuY29kZWMpKTtcbiAgICAgICAgaWYgKChpbmZvVGFnLmhlYWRlckZsYWdzWzNdICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hdWRpb0ZyYW1lSGVhZGVyLmNhbGNEdXJhdGlvbihpbmZvVGFnLm51bUZyYW1lcyk7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBkZWJ1ZygnR2V0IGR1cmF0aW9uIGZyb20gWGluZyBoZWFkZXI6ICVzJywgdGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGluZm9UYWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZnJhbWVzIGZpZWxkIGlzIG5vdCBwcmVzZW50XG4gICAgICAgIGNvbnN0IGZyYW1lRGF0YUxlZnQgPSB0aGlzLmZyYW1lX3NpemUgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgYXdhaXQgdGhpcy5za2lwRnJhbWVEYXRhKGZyYW1lRGF0YUxlZnQpO1xuICAgICAgICByZXR1cm4gaW5mb1RhZztcbiAgICB9XG4gICAgYXN5bmMgc2tpcEZyYW1lRGF0YShmcmFtZURhdGFMZWZ0KSB7XG4gICAgICAgIGFzc2VydC5vayhmcmFtZURhdGFMZWZ0ID49IDAsICdmcmFtZS1kYXRhLWxlZnQgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShmcmFtZURhdGFMZWZ0KTtcbiAgICAgICAgdGhpcy5jb3VudFNraXBGcmFtZURhdGEgKz0gZnJhbWVEYXRhTGVmdDtcbiAgICB9XG4gICAgYXJlQWxsU2FtZShhcnJheSkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGFycmF5WzBdO1xuICAgICAgICByZXR1cm4gYXJyYXkuZXZlcnkoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gZmlyc3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTXBlZ1BhcnNlciA9IE1wZWdQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NcGVnUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mpeg/MpegParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/mpeg/XingTag.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/XingTag.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XingInfoTag = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/**\n * Info Tag: Xing, LAME\n */\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexports.XingInfoTag = {\n    len: 136,\n    get: (buf, off) => {\n        return {\n            // === ZONE A - Traditional Xing VBR Tag data ===\n            // 4 bytes for HeaderFlags\n            headerFlags: new Token.BufferType(4).get(buf, off),\n            numFrames: Token.UINT32_BE.get(buf, off + 4),\n            streamSize: Token.UINT32_BE.get(buf, off + 8),\n            // the number of header data bytes (from original file)\n            vbrScale: Token.UINT32_BE.get(buf, off + 112),\n            /**\n             * LAME Tag, extends the Xing header format\n             * First added in LAME 3.12 for VBR\n             * The modified header is also included in CBR files (effective LAME 3.94), with \"Info\" instead of \"XING\" near the beginning.\n             */\n            // === ZONE B - Initial LAME info  ===\n            //  Initial LAME info, e.g.: LAME3.99r\n            codec: new Token.StringType(9, 'ascii').get(buf, off + 116),\n            // \t Info tag revision\n            infoTagRevision: Token.UINT8.get(buf, off + 125) >> 4,\n            // VBR method\n            vbrMethod: Token.UINT8.get(buf, off + 125) & 0xf // $A5\n        };\n    }\n};\n//# sourceMappingURL=XingTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wZWcvWGluZ1RhZy5qcz9hZDNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9YaW5nVGFnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlhpbmdJbmZvVGFnID0gZXhwb3J0cy5MYW1lRW5jb2RlclZlcnNpb24gPSBleHBvcnRzLkluZm9UYWdIZWFkZXJUYWcgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbi8qKlxuICogSW5mbyBUYWc6IFhpbmcsIExBTUVcbiAqL1xuZXhwb3J0cy5JbmZvVGFnSGVhZGVyVGFnID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoNCwgJ2FzY2lpJyk7XG4vKipcbiAqIExBTUUgVEFHIHZhbHVlXG4gKiBEaWQgbm90IGZpbmQgYW55IG9mZmljaWFsIGRvY3VtZW50YXRpb24gZm9yIHRoaXNcbiAqIFZhbHVlIGUuZy46IFwiMy45OC40XCJcbiAqL1xuZXhwb3J0cy5MYW1lRW5jb2RlclZlcnNpb24gPSBuZXcgVG9rZW4uU3RyaW5nVHlwZSg2LCAnYXNjaWknKTtcbi8qKlxuICogSW5mbyBUYWdcbiAqIFJlZjogaHR0cDovL2dhYnJpZWwubXAzLXRlY2gub3JnL21wM2luZm90YWcuaHRtbFxuICovXG5leHBvcnRzLlhpbmdJbmZvVGFnID0ge1xuICAgIGxlbjogMTM2LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyA9PT0gWk9ORSBBIC0gVHJhZGl0aW9uYWwgWGluZyBWQlIgVGFnIGRhdGEgPT09XG4gICAgICAgICAgICAvLyA0IGJ5dGVzIGZvciBIZWFkZXJGbGFnc1xuICAgICAgICAgICAgaGVhZGVyRmxhZ3M6IG5ldyBUb2tlbi5CdWZmZXJUeXBlKDQpLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBudW1GcmFtZXM6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIHN0cmVhbVNpemU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgb2YgaGVhZGVyIGRhdGEgYnl0ZXMgKGZyb20gb3JpZ2luYWwgZmlsZSlcbiAgICAgICAgICAgIHZiclNjYWxlOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTEyKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTEFNRSBUYWcsIGV4dGVuZHMgdGhlIFhpbmcgaGVhZGVyIGZvcm1hdFxuICAgICAgICAgICAgICogRmlyc3QgYWRkZWQgaW4gTEFNRSAzLjEyIGZvciBWQlJcbiAgICAgICAgICAgICAqIFRoZSBtb2RpZmllZCBoZWFkZXIgaXMgYWxzbyBpbmNsdWRlZCBpbiBDQlIgZmlsZXMgKGVmZmVjdGl2ZSBMQU1FIDMuOTQpLCB3aXRoIFwiSW5mb1wiIGluc3RlYWQgb2YgXCJYSU5HXCIgbmVhciB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyA9PT0gWk9ORSBCIC0gSW5pdGlhbCBMQU1FIGluZm8gID09PVxuICAgICAgICAgICAgLy8gIEluaXRpYWwgTEFNRSBpbmZvLCBlLmcuOiBMQU1FMy45OXJcbiAgICAgICAgICAgIGNvZGVjOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg5LCAnYXNjaWknKS5nZXQoYnVmLCBvZmYgKyAxMTYpLFxuICAgICAgICAgICAgLy8gXHQgSW5mbyB0YWcgcmV2aXNpb25cbiAgICAgICAgICAgIGluZm9UYWdSZXZpc2lvbjogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMTI1KSA+PiA0LFxuICAgICAgICAgICAgLy8gVkJSIG1ldGhvZFxuICAgICAgICAgICAgdmJyTWV0aG9kOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYgKyAxMjUpICYgMHhmIC8vICRBNVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YaW5nVGFnLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/mpeg/XingTag.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst MpcSv8Parser_1 = __webpack_require__(/*! ./sv8/MpcSv8Parser */ \"./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js\");\nconst MpcSv7Parser_1 = __webpack_require__(/*! ./sv7/MpcSv7Parser */ \"./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst debug = initDebug('music-metadata:parser:musepack');\nclass MusepackParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async _parse() {\n        const signature = await this.tokenizer.peekToken(new Token.StringType(3, 'binary'));\n        let mpcParser;\n        switch (signature) {\n            case 'MP+': {\n                debug('Musepack stream-version 7');\n                mpcParser = new MpcSv7Parser_1.MpcSv7Parser();\n                break;\n            }\n            case 'MPC': {\n                debug('Musepack stream-version 8');\n                mpcParser = new MpcSv8Parser_1.MpcSv8Parser();\n                break;\n            }\n            default: {\n                throw new Error('Invalid Musepack signature prefix');\n            }\n        }\n        mpcParser.init(this.metadata, this.tokenizer, this.options);\n        return mpcParser.parse();\n    }\n}\nexports.default = MusepackParser;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL2luZGV4LmpzP2E0ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBTztBQUNqQyxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsdUJBQXVCLG1CQUFPLENBQUMsMEZBQW9CO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLDBGQUFvQjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgTXBjU3Y4UGFyc2VyXzEgPSByZXF1aXJlKFwiLi9zdjgvTXBjU3Y4UGFyc2VyXCIpO1xuY29uc3QgTXBjU3Y3UGFyc2VyXzEgPSByZXF1aXJlKFwiLi9zdjcvTXBjU3Y3UGFyc2VyXCIpO1xuY29uc3QgQWJzdHJhY3RJRDNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2Mi9BYnN0cmFjdElEM1BhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXVzZXBhY2snKTtcbmNsYXNzIE11c2VwYWNrUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RJRDNQYXJzZXJfMS5BYnN0cmFjdElEM1BhcnNlciB7XG4gICAgYXN5bmMgX3BhcnNlKCkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrVG9rZW4obmV3IFRva2VuLlN0cmluZ1R5cGUoMywgJ2JpbmFyeScpKTtcbiAgICAgICAgbGV0IG1wY1BhcnNlcjtcbiAgICAgICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ01QKyc6IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnTXVzZXBhY2sgc3RyZWFtLXZlcnNpb24gNycpO1xuICAgICAgICAgICAgICAgIG1wY1BhcnNlciA9IG5ldyBNcGNTdjdQYXJzZXJfMS5NcGNTdjdQYXJzZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ01QQyc6IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnTXVzZXBhY2sgc3RyZWFtLXZlcnNpb24gOCcpO1xuICAgICAgICAgICAgICAgIG1wY1BhcnNlciA9IG5ldyBNcGNTdjhQYXJzZXJfMS5NcGNTdjhQYXJzZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTXVzZXBhY2sgc2lnbmF0dXJlIHByZWZpeCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1wY1BhcnNlci5pbml0KHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbXBjUGFyc2VyLnBhcnNlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTXVzZXBhY2tQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/index.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/sv7/BitReader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/BitReader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitReader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nclass BitReader {\n    constructor(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.pos = 0;\n        this.dword = undefined;\n    }\n    /**\n     *\n     * @param bits 1..30 bits\n     */\n    async read(bits) {\n        while (this.dword === undefined) {\n            this.dword = await this.tokenizer.readToken(Token.UINT32_LE);\n        }\n        let out = this.dword;\n        this.pos += bits;\n        if (this.pos < 32) {\n            out >>>= (32 - this.pos);\n            return out & ((1 << bits) - 1);\n        }\n        else {\n            this.pos -= 32;\n            if (this.pos === 0) {\n                this.dword = undefined;\n                return out & ((1 << bits) - 1);\n            }\n            else {\n                this.dword = await this.tokenizer.readToken(Token.UINT32_LE);\n                if (this.pos) {\n                    out <<= this.pos;\n                    out |= this.dword >>> (32 - this.pos);\n                }\n                return out & ((1 << bits) - 1);\n            }\n        }\n    }\n    async ignore(bits) {\n        if (this.pos > 0) {\n            const remaining = 32 - this.pos;\n            this.dword = undefined;\n            bits -= remaining;\n            this.pos = 0;\n        }\n        const remainder = bits % 32;\n        const numOfWords = (bits - remainder) / 32;\n        await this.tokenizer.ignore(numOfWords * 4);\n        return this.read(remainder);\n    }\n}\nexports.BitReader = BitReader;\n//# sourceMappingURL=BitReader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2Ny9CaXRSZWFkZXIuanM/YWFlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L0JpdFJlYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNsYXNzIEJpdFJlYWRlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5pemVyKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJpdHMgMS4uMzAgYml0c1xuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoYml0cykge1xuICAgICAgICB3aGlsZSAodGhpcy5kd29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmR3b3JkID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9MRSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dCA9IHRoaXMuZHdvcmQ7XG4gICAgICAgIHRoaXMucG9zICs9IGJpdHM7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IDMyKSB7XG4gICAgICAgICAgICBvdXQgPj4+PSAoMzIgLSB0aGlzLnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0ICYgKCgxIDw8IGJpdHMpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcyAtPSAzMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dCAmICgoMSA8PCBiaXRzKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kd29yZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMzJfTEUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcykge1xuICAgICAgICAgICAgICAgICAgICBvdXQgPDw9IHRoaXMucG9zO1xuICAgICAgICAgICAgICAgICAgICBvdXQgfD0gdGhpcy5kd29yZCA+Pj4gKDMyIC0gdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ICYgKCgxIDw8IGJpdHMpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaWdub3JlKGJpdHMpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gMzIgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBiaXRzIC09IHJlbWFpbmluZztcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5kZXIgPSBiaXRzICUgMzI7XG4gICAgICAgIGNvbnN0IG51bU9mV29yZHMgPSAoYml0cyAtIHJlbWFpbmRlcikgLyAzMjtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKG51bU9mV29yZHMgKiA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZChyZW1haW5kZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0UmVhZGVyID0gQml0UmVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0UmVhZGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/sv7/BitReader.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpcSv7Parser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst SV7 = __webpack_require__(/*! ./StreamVersion7 */ \"./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../../apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst BitReader_1 = __webpack_require__(/*! ./BitReader */ \"./node_modules/music-metadata/lib/musepack/sv7/BitReader.js\");\nconst debug = initDebug('music-metadata:parser:musepack');\nclass MpcSv7Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.audioLength = 0;\n    }\n    async parse() {\n        const header = await this.tokenizer.readToken(SV7.Header);\n        assert.equal(header.signature, 'MP+', 'Magic number');\n        debug(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);\n        this.metadata.setFormat('container', 'Musepack, SV7');\n        this.metadata.setFormat('sampleRate', header.sampleFrequency);\n        const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;\n        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n        this.duration = numberOfSamples / header.sampleFrequency;\n        this.metadata.setFormat('duration', this.duration);\n        this.bitreader = new BitReader_1.BitReader(this.tokenizer);\n        this.metadata.setFormat('numberOfChannels', header.midSideStereo || header.intensityStereo ? 2 : 1);\n        const version = await this.bitreader.read(8);\n        this.metadata.setFormat('codec', (version / 100).toFixed(2));\n        await this.skipAudioData(header.frameCount);\n        debug(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);\n        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n    }\n    async skipAudioData(frameCount) {\n        while (frameCount-- > 0) {\n            const frameLength = await this.bitreader.read(20);\n            this.audioLength += 20 + frameLength;\n            await this.bitreader.ignore(frameLength);\n        }\n        // last frame\n        const lastFrameLength = await this.bitreader.read(11);\n        this.audioLength += lastFrameLength;\n        this.metadata.setFormat('bitrate', this.audioLength / this.duration);\n    }\n}\nexports.MpcSv7Parser = MpcSv7Parser;\n//# sourceMappingURL=MpcSv7Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2Ny9NcGNTdjdQYXJzZXIuanM/Yjg1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakMsZUFBZSxtQkFBTyxDQUFDLDhFQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLHlGQUEwQjtBQUN4RCxZQUFZLG1CQUFPLENBQUMsMEZBQWtCO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUF5QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0JBQXdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tdXNlcGFjay9zdjcvTXBjU3Y3UGFyc2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NcGNTdjdQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBpbml0RGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBTVjcgPSByZXF1aXJlKFwiLi9TdHJlYW1WZXJzaW9uN1wiKTtcbmNvbnN0IEFQRXYyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vYXBldjIvQVBFdjJQYXJzZXJcIik7XG5jb25zdCBCaXRSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0JpdFJlYWRlclwiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXVzZXBhY2snKTtcbmNsYXNzIE1wY1N2N1BhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF1ZGlvTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihTVjcuSGVhZGVyKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGhlYWRlci5zaWduYXR1cmUsICdNUCsnLCAnTWFnaWMgbnVtYmVyJyk7XG4gICAgICAgIGRlYnVnKGBzdHJlYW0tdmVyc2lvbj0ke2hlYWRlci5zdHJlYW1NYWpvclZlcnNpb259LiR7aGVhZGVyLnN0cmVhbU1pbm9yVmVyc2lvbn1gKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsICdNdXNlcGFjaywgU1Y3Jyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgaGVhZGVyLnNhbXBsZUZyZXF1ZW5jeSk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcyA9IDExNTIgKiAoaGVhZGVyLmZyYW1lQ291bnQgLSAxKSArIGhlYWRlci5sYXN0RnJhbWVMZW5ndGg7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBudW1iZXJPZlNhbXBsZXMpO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbnVtYmVyT2ZTYW1wbGVzIC8gaGVhZGVyLnNhbXBsZUZyZXF1ZW5jeTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHRoaXMuYml0cmVhZGVyID0gbmV3IEJpdFJlYWRlcl8xLkJpdFJlYWRlcih0aGlzLnRva2VuaXplcik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaGVhZGVyLm1pZFNpZGVTdGVyZW8gfHwgaGVhZGVyLmludGVuc2l0eVN0ZXJlbyA/IDIgOiAxKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMuYml0cmVhZGVyLnJlYWQoOCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsICh2ZXJzaW9uIC8gMTAwKS50b0ZpeGVkKDIpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5za2lwQXVkaW9EYXRhKGhlYWRlci5mcmFtZUNvdW50KTtcbiAgICAgICAgZGVidWcoYEVuZCBvZiBhdWRpbyBzdHJlYW0sIHN3aXRjaGluZyB0byBBUEV2Miwgb2Zmc2V0PSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259YCk7XG4gICAgICAgIHJldHVybiBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyLnRyeVBhcnNlQXBlSGVhZGVyKHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBza2lwQXVkaW9EYXRhKGZyYW1lQ291bnQpIHtcbiAgICAgICAgd2hpbGUgKGZyYW1lQ291bnQtLSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gYXdhaXQgdGhpcy5iaXRyZWFkZXIucmVhZCgyMCk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvTGVuZ3RoICs9IDIwICsgZnJhbWVMZW5ndGg7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJpdHJlYWRlci5pZ25vcmUoZnJhbWVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3QgZnJhbWVcbiAgICAgICAgY29uc3QgbGFzdEZyYW1lTGVuZ3RoID0gYXdhaXQgdGhpcy5iaXRyZWFkZXIucmVhZCgxMSk7XG4gICAgICAgIHRoaXMuYXVkaW9MZW5ndGggKz0gbGFzdEZyYW1lTGVuZ3RoO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIHRoaXMuYXVkaW9MZW5ndGggLyB0aGlzLmR1cmF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLk1wY1N2N1BhcnNlciA9IE1wY1N2N1BhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1wY1N2N1BhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js":
/*!************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * BASIC STRUCTURE\n */\nexports.Header = {\n    len: 6 * 4,\n    get: (buf, off) => {\n        const header = {\n            // word 0\n            signature: buf.toString(\"binary\", off, off + 3),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            streamMinorVersion: Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 4),\n            streamMajorVersion: Util_1.default.getBitAllignedNumber(buf, off + 3, 4, 4),\n            // word 1\n            frameCount: Token.UINT32_LE.get(buf, off + 4),\n            // word 2\n            maxLevel: Token.UINT16_LE.get(buf, off + 8),\n            sampleFrequency: [44100, 48000, 37800, 32000][Util_1.default.getBitAllignedNumber(buf, off + 10, 0, 2)],\n            link: Util_1.default.getBitAllignedNumber(buf, off + 10, 2, 2),\n            profile: Util_1.default.getBitAllignedNumber(buf, off + 10, 4, 4),\n            maxBand: Util_1.default.getBitAllignedNumber(buf, off + 11, 0, 6),\n            intensityStereo: Util_1.default.isBitSet(buf, off + 11, 6),\n            midSideStereo: Util_1.default.isBitSet(buf, off + 11, 7),\n            // word 3\n            titlePeak: Token.UINT16_LE.get(buf, off + 12),\n            titleGain: Token.UINT16_LE.get(buf, off + 14),\n            // word 4\n            albumPeak: Token.UINT16_LE.get(buf, off + 16),\n            albumGain: Token.UINT16_LE.get(buf, off + 18),\n            // word\n            lastFrameLength: (Token.UINT32_LE.get(buf, off + 20) >>> 20) & 0x7FF,\n            trueGapless: Util_1.default.isBitSet(buf, off + 23, 0)\n        };\n        header.lastFrameLength = header.trueGapless ? (Token.UINT32_LE.get(buf, 20) >>> 20) & 0x7FF : 0;\n        return header;\n    }\n};\n//# sourceMappingURL=StreamVersion7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2Ny9TdHJlYW1WZXJzaW9uNy5qcz83ZWNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDJFQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L1N0cmVhbVZlcnNpb243LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9VdGlsXCIpO1xuLyoqXG4gKiBCQVNJQyBTVFJVQ1RVUkVcbiAqL1xuZXhwb3J0cy5IZWFkZXIgPSB7XG4gICAgbGVuOiA2ICogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgICAgICAvLyB3b3JkIDBcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnVmLnRvU3RyaW5nKFwiYmluYXJ5XCIsIG9mZiwgb2ZmICsgMyksXG4gICAgICAgICAgICAvLyB2ZXJzaW9uSW5kZXggbnVtYmVyICogMTAwMCAoMy44MSA9IDM4MTApIChyZW1lbWJlciB0aGF0IDQtYnl0ZSBhbGlnbm1lbnQgY2F1c2VzIHRoaXMgdG8gdGFrZSA0LWJ5dGVzKVxuICAgICAgICAgICAgc3RyZWFtTWlub3JWZXJzaW9uOiBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDMsIDAsIDQpLFxuICAgICAgICAgICAgc3RyZWFtTWFqb3JWZXJzaW9uOiBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDMsIDQsIDQpLFxuICAgICAgICAgICAgLy8gd29yZCAxXG4gICAgICAgICAgICBmcmFtZUNvdW50OiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICAvLyB3b3JkIDJcbiAgICAgICAgICAgIG1heExldmVsOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICBzYW1wbGVGcmVxdWVuY3k6IFs0NDEwMCwgNDgwMDAsIDM3ODAwLCAzMjAwMF1bVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMCwgMCwgMildLFxuICAgICAgICAgICAgbGluazogVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMCwgMiwgMiksXG4gICAgICAgICAgICBwcm9maWxlOiBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEwLCA0LCA0KSxcbiAgICAgICAgICAgIG1heEJhbmQ6IFV0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMTEsIDAsIDYpLFxuICAgICAgICAgICAgaW50ZW5zaXR5U3RlcmVvOiBVdGlsXzEuZGVmYXVsdC5pc0JpdFNldChidWYsIG9mZiArIDExLCA2KSxcbiAgICAgICAgICAgIG1pZFNpZGVTdGVyZW86IFV0aWxfMS5kZWZhdWx0LmlzQml0U2V0KGJ1Ziwgb2ZmICsgMTEsIDcpLFxuICAgICAgICAgICAgLy8gd29yZCAzXG4gICAgICAgICAgICB0aXRsZVBlYWs6IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICB0aXRsZUdhaW46IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYgKyAxNCksXG4gICAgICAgICAgICAvLyB3b3JkIDRcbiAgICAgICAgICAgIGFsYnVtUGVhazogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIGFsYnVtR2FpbjogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiArIDE4KSxcbiAgICAgICAgICAgIC8vIHdvcmRcbiAgICAgICAgICAgIGxhc3RGcmFtZUxlbmd0aDogKFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyMCkgPj4+IDIwKSAmIDB4N0ZGLFxuICAgICAgICAgICAgdHJ1ZUdhcGxlc3M6IFV0aWxfMS5kZWZhdWx0LmlzQml0U2V0KGJ1Ziwgb2ZmICsgMjMsIDApXG4gICAgICAgIH07XG4gICAgICAgIGhlYWRlci5sYXN0RnJhbWVMZW5ndGggPSBoZWFkZXIudHJ1ZUdhcGxlc3MgPyAoVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIDIwKSA+Pj4gMjApICYgMHg3RkYgOiAwO1xuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJlYW1WZXJzaW9uNy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpcSv8Parser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst SV8 = __webpack_require__(/*! ./StreamVersion8 */ \"./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../../apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst debug = initDebug('music-metadata:parser:musepack');\nclass MpcSv8Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.audioLength = 0;\n    }\n    async parse() {\n        const signature = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        assert.equal(signature, 'MPCK', 'Magic number');\n        this.metadata.setFormat('container', 'Musepack, SV8');\n        return this.parsePacket();\n    }\n    async parsePacket() {\n        const sv8reader = new SV8.StreamReader(this.tokenizer);\n        do {\n            const header = await sv8reader.readPacketHeader();\n            debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);\n            switch (header.key) {\n                case 'SH': // Stream Header\n                    const sh = await sv8reader.readStreamHeader(header.payloadLength);\n                    this.metadata.setFormat('numberOfSamples', sh.sampleCount);\n                    this.metadata.setFormat('sampleRate', sh.sampleFrequency);\n                    this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);\n                    this.metadata.setFormat('numberOfChannels', sh.channelCount);\n                    break;\n                case 'AP': // Audio Packet\n                    this.audioLength += header.payloadLength;\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'RG': // Replaygain\n                case 'EI': // Encoder Info\n                case 'SO': // Seek Table Offset\n                case 'ST': // Seek Table\n                case 'CT': // Chapter-Tag\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'SE': // Stream End\n                    this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);\n                    return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n                default:\n                    throw new Error(`Unexpected header: ${header.key}`);\n            }\n        } while (true);\n    }\n}\nexports.MpcSv8Parser = MpcSv8Parser;\n//# sourceMappingURL=MpcSv8Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2OC9NcGNTdjhQYXJzZXIuanM/NTNhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEVBQU87QUFDakMsZUFBZSxtQkFBTyxDQUFDLDhFQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLHlGQUEwQjtBQUN4RCxZQUFZLG1CQUFPLENBQUMsMEZBQWtCO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUF5QjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVyxrQkFBa0IscUJBQXFCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y4L01wY1N2OFBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXBjU3Y4UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgU1Y4ID0gcmVxdWlyZShcIi4vU3RyZWFtVmVyc2lvbjhcIik7XG5jb25zdCBBUEV2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FwZXYyL0FQRXYyUGFyc2VyXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXVzZXBhY2snKTtcbmNsYXNzIE1wY1N2OFBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF1ZGlvTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgIGFzc2VydC5lcXVhbChzaWduYXR1cmUsICdNUENLJywgJ01hZ2ljIG51bWJlcicpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ011c2VwYWNrLCBTVjgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYWNrZXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VQYWNrZXQoKSB7XG4gICAgICAgIGNvbnN0IHN2OHJlYWRlciA9IG5ldyBTVjguU3RyZWFtUmVhZGVyKHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgc3Y4cmVhZGVyLnJlYWRQYWNrZXRIZWFkZXIoKTtcbiAgICAgICAgICAgIGRlYnVnKGBwYWNrZXQtaGVhZGVyIGtleT0ke2hlYWRlci5rZXl9LCBwYXlsb2FkTGVuZ3RoPSR7aGVhZGVyLnBheWxvYWRMZW5ndGh9YCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSCc6IC8vIFN0cmVhbSBIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2ggPSBhd2FpdCBzdjhyZWFkZXIucmVhZFN0cmVhbUhlYWRlcihoZWFkZXIucGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBzaC5zYW1wbGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgc2guc2FtcGxlRnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgc2guc2FtcGxlQ291bnQgLyBzaC5zYW1wbGVGcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIHNoLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0FQJzogLy8gQXVkaW8gUGFja2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9MZW5ndGggKz0gaGVhZGVyLnBheWxvYWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIucGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JHJzogLy8gUmVwbGF5Z2FpblxuICAgICAgICAgICAgICAgIGNhc2UgJ0VJJzogLy8gRW5jb2RlciBJbmZvXG4gICAgICAgICAgICAgICAgY2FzZSAnU08nOiAvLyBTZWVrIFRhYmxlIE9mZnNldFxuICAgICAgICAgICAgICAgIGNhc2UgJ1NUJzogLy8gU2VlayBUYWJsZVxuICAgICAgICAgICAgICAgIGNhc2UgJ0NUJzogLy8gQ2hhcHRlci1UYWdcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0UnOiAvLyBTdHJlYW0gRW5kXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgdGhpcy5hdWRpb0xlbmd0aCAqIDggLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyLnRyeVBhcnNlQXBlSGVhZGVyKHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBoZWFkZXI6ICR7aGVhZGVyLmtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NcGNTdjhQYXJzZXIgPSBNcGNTdjhQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NcGNTdjhQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js":
/*!************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamReader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst debug = initDebug('music-metadata:parser:musepack:sv8');\nconst PacketKey = new Token.StringType(2, 'binary');\n/**\n * Stream Header Packet part 1\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part1 = {\n    len: 5,\n    get: (buf, off) => {\n        return {\n            crc: Token.UINT32_LE.get(buf, off),\n            streamVersion: Token.UINT8.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Stream Header Packet part 3\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part3 = {\n    len: 2,\n    get: (buf, off) => {\n        return {\n            sampleFrequency: [44100, 48000, 37800, 32000][Util_1.default.getBitAllignedNumber(buf, off, 0, 3)],\n            maxUsedBands: Util_1.default.getBitAllignedNumber(buf, off, 3, 5),\n            channelCount: Util_1.default.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,\n            msUsed: Util_1.default.isBitSet(buf, off + 1, 4),\n            audioBlockFrames: Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 3)\n        };\n    }\n};\nclass StreamReader {\n    constructor(tokenizer) {\n        this.tokenizer = tokenizer;\n    }\n    async readPacketHeader() {\n        const key = await this.tokenizer.readToken(PacketKey);\n        const size = await this.readVariableSizeField();\n        return {\n            key,\n            payloadLength: size.value - 2 - size.len\n        };\n    }\n    async readStreamHeader(size) {\n        const streamHeader = {};\n        debug(`Reading SH at offset=${this.tokenizer.position}`);\n        const part1 = await this.tokenizer.readToken(SH_part1);\n        size -= SH_part1.len;\n        Object.assign(streamHeader, part1);\n        debug(`SH.streamVersion = ${part1.streamVersion}`);\n        const sampleCount = await this.readVariableSizeField();\n        size -= sampleCount.len;\n        streamHeader.sampleCount = sampleCount.value;\n        const bs = await this.readVariableSizeField();\n        size -= bs.len;\n        streamHeader.beginningOfSilence = bs.value;\n        const part3 = await this.tokenizer.readToken(SH_part3);\n        size -= SH_part3.len;\n        Object.assign(streamHeader, part3);\n        // assert.equal(size, 0);\n        await this.tokenizer.ignore(size);\n        return streamHeader;\n    }\n    async readVariableSizeField(len = 1, hb = 0) {\n        let n = await this.tokenizer.readNumber(Token.UINT8);\n        if ((n & 0x80) === 0) {\n            return { len, value: hb + n };\n        }\n        n &= 0x7F;\n        n += hb;\n        return this.readVariableSizeField(len + 1, n << 7);\n    }\n}\nexports.StreamReader = StreamReader;\n//# sourceMappingURL=StreamVersion8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2OC9TdHJlYW1WZXJzaW9uOC5qcz80YjhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDJFQUFtQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y4L1N0cmVhbVZlcnNpb244LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9VdGlsXCIpO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjptdXNlcGFjazpzdjgnKTtcbmNvbnN0IFBhY2tldEtleSA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDIsICdiaW5hcnknKTtcbi8qKlxuICogU3RyZWFtIEhlYWRlciBQYWNrZXQgcGFydCAxXG4gKiBSZWY6IGh0dHA6Ly90cmFjLm11c2VwYWNrLm5ldC9tdXNlcGFjay93aWtpL1NWOFNwZWNpZmljYXRpb24jU3RyZWFtSGVhZGVyUGFja2V0XG4gKi9cbmNvbnN0IFNIX3BhcnQxID0ge1xuICAgIGxlbjogNSxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JjOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIHN0cmVhbVZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDQpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtIEhlYWRlciBQYWNrZXQgcGFydCAzXG4gKiBSZWY6IGh0dHA6Ly90cmFjLm11c2VwYWNrLm5ldC9tdXNlcGFjay93aWtpL1NWOFNwZWNpZmljYXRpb24jU3RyZWFtSGVhZGVyUGFja2V0XG4gKi9cbmNvbnN0IFNIX3BhcnQzID0ge1xuICAgIGxlbjogMixcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2FtcGxlRnJlcXVlbmN5OiBbNDQxMDAsIDQ4MDAwLCAzNzgwMCwgMzIwMDBdW1V0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAwLCAzKV0sXG4gICAgICAgICAgICBtYXhVc2VkQmFuZHM6IFV0aWxfMS5kZWZhdWx0LmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAzLCA1KSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogVXRpbF8xLmRlZmF1bHQuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxLCAwLCA0KSArIDEsXG4gICAgICAgICAgICBtc1VzZWQ6IFV0aWxfMS5kZWZhdWx0LmlzQml0U2V0KGJ1Ziwgb2ZmICsgMSwgNCksXG4gICAgICAgICAgICBhdWRpb0Jsb2NrRnJhbWVzOiBVdGlsXzEuZGVmYXVsdC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEsIDUsIDMpXG4gICAgICAgIH07XG4gICAgfVxufTtcbmNsYXNzIFN0cmVhbVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5pemVyKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgIH1cbiAgICBhc3luYyByZWFkUGFja2V0SGVhZGVyKCkge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oUGFja2V0S2V5KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGF3YWl0IHRoaXMucmVhZFZhcmlhYmxlU2l6ZUZpZWxkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwYXlsb2FkTGVuZ3RoOiBzaXplLnZhbHVlIC0gMiAtIHNpemUubGVuXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTdHJlYW1IZWFkZXIoc2l6ZSkge1xuICAgICAgICBjb25zdCBzdHJlYW1IZWFkZXIgPSB7fTtcbiAgICAgICAgZGVidWcoYFJlYWRpbmcgU0ggYXQgb2Zmc2V0PSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259YCk7XG4gICAgICAgIGNvbnN0IHBhcnQxID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFNIX3BhcnQxKTtcbiAgICAgICAgc2l6ZSAtPSBTSF9wYXJ0MS5sZW47XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3RyZWFtSGVhZGVyLCBwYXJ0MSk7XG4gICAgICAgIGRlYnVnKGBTSC5zdHJlYW1WZXJzaW9uID0gJHtwYXJ0MS5zdHJlYW1WZXJzaW9ufWApO1xuICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IGF3YWl0IHRoaXMucmVhZFZhcmlhYmxlU2l6ZUZpZWxkKCk7XG4gICAgICAgIHNpemUgLT0gc2FtcGxlQ291bnQubGVuO1xuICAgICAgICBzdHJlYW1IZWFkZXIuc2FtcGxlQ291bnQgPSBzYW1wbGVDb3VudC52YWx1ZTtcbiAgICAgICAgY29uc3QgYnMgPSBhd2FpdCB0aGlzLnJlYWRWYXJpYWJsZVNpemVGaWVsZCgpO1xuICAgICAgICBzaXplIC09IGJzLmxlbjtcbiAgICAgICAgc3RyZWFtSGVhZGVyLmJlZ2lubmluZ09mU2lsZW5jZSA9IGJzLnZhbHVlO1xuICAgICAgICBjb25zdCBwYXJ0MyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihTSF9wYXJ0Myk7XG4gICAgICAgIHNpemUgLT0gU0hfcGFydDMubGVuO1xuICAgICAgICBPYmplY3QuYXNzaWduKHN0cmVhbUhlYWRlciwgcGFydDMpO1xuICAgICAgICAvLyBhc3NlcnQuZXF1YWwoc2l6ZSwgMCk7XG4gICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShzaXplKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbUhlYWRlcjtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFZhcmlhYmxlU2l6ZUZpZWxkKGxlbiA9IDEsIGhiID0gMCkge1xuICAgICAgICBsZXQgbiA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWROdW1iZXIoVG9rZW4uVUlOVDgpO1xuICAgICAgICBpZiAoKG4gJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGVuLCB2YWx1ZTogaGIgKyBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiAmPSAweDdGO1xuICAgICAgICBuICs9IGhiO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVmFyaWFibGVTaXplRmllbGQobGVuICsgMSwgbiA8PCA3KTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbVJlYWRlciA9IFN0cmVhbVJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbVZlcnNpb244LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/OggParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/OggParser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OggParser = exports.SegmentTable = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ./vorbis/VorbisParser */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst OpusParser_1 = __webpack_require__(/*! ./opus/OpusParser */ \"./node_modules/music-metadata/lib/ogg/opus/OpusParser.js\");\nconst SpeexParser_1 = __webpack_require__(/*! ./speex/SpeexParser */ \"./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst TheoraParser_1 = __webpack_require__(/*! ./theora/TheoraParser */ \"./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js\");\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst debug = initDebug('music-metadata:parser:ogg');\nclass SegmentTable {\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    static sum(buf, off, len) {\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += buf[i];\n        }\n        return s;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\nexports.SegmentTable = SegmentTable;\n/**\n * Parser for Ogg logical bitstream framing\n */\nclass OggParser extends BasicParser_1.BasicParser {\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        debug('pos=%s, parsePage()', this.tokenizer.position);\n        try {\n            let header;\n            do {\n                header = await this.tokenizer.readToken(OggParser.Header);\n                assert.strictEqual(header.capturePattern, 'OggS', 'Ogg capture pattern');\n                this.metadata.setFormat('container', 'Ogg');\n                this.header = header;\n                this.pageNumber = header.pageSequenceNo;\n                debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\n                const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\n                debug('totalPageSize=%s', segmentTable.totalPageSize);\n                const pageData = await this.tokenizer.readToken(new Token.BufferType(segmentTable.totalPageSize));\n                debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n                if (header.headerType.firstPage) {\n                    const id = new Token.StringType(7, 'ascii').get(pageData, 0);\n                    switch (id) {\n                        case '\u0001vorbis': // Ogg/Vorbis\n                            debug('Set page consumer to Ogg/Vorbis');\n                            this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);\n                            break;\n                        case 'OpusHea': // Ogg/Opus\n                            debug('Set page consumer to Ogg/Opus');\n                            this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'Speex  ': // Ogg/Speex\n                            debug('Set page consumer to Ogg/Speex');\n                            this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'fishead':\n                        case '\u0000theora': // Ogg/Theora\n                            debug('Set page consumer to Ogg/Theora');\n                            this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        default:\n                            throw new Error('gg audio-codec not recognized (id=' + id + ')');\n                    }\n                }\n                this.pageConsumer.parsePage(header, pageData);\n            } while (!header.headerType.lastPage);\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                debug(`End-of-stream`);\n                this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                if (this.header) {\n                    this.pageConsumer.calculateDuration(this.header);\n                }\n            }\n            else if (err.message.startsWith('FourCC')) {\n                if (this.pageNumber > 0) {\n                    // ignore this error: work-around if last OGG-page is not marked with last-page flag\n                    this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\n                    this.pageConsumer.flush();\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\nexports.OggParser = OggParser;\nOggParser.Header = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: FourCC_1.FourCcToken.get(buf, off),\n            version: buf.readUInt8(off + 4),\n            headerType: {\n                continued: Util_1.default.strtokBITSET.get(buf, off + 5, 0),\n                firstPage: Util_1.default.strtokBITSET.get(buf, off + 5, 1),\n                lastPage: Util_1.default.strtokBITSET.get(buf, off + 5, 2)\n            },\n            // packet_flag: buf.readUInt8(off + 5),\n            absoluteGranulePosition: buf.readIntLE(off + 6, 6),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: buf.readUInt8(off + 26)\n        };\n    }\n};\n//# sourceMappingURL=OggParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9PZ2dQYXJzZXIuanM/MjJkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFrQjtBQUMzQyx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsbUZBQW1CO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyw0REFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9PZ2dQYXJzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2dnUGFyc2VyID0gZXhwb3J0cy5TZWdtZW50VGFibGUgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgVm9yYmlzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi92b3JiaXMvVm9yYmlzUGFyc2VyXCIpO1xuY29uc3QgT3B1c1BhcnNlcl8xID0gcmVxdWlyZShcIi4vb3B1cy9PcHVzUGFyc2VyXCIpO1xuY29uc3QgU3BlZXhQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3NwZWV4L1NwZWV4UGFyc2VyXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBUaGVvcmFQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3RoZW9yYS9UaGVvcmFQYXJzZXJcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwic3RydG9rMy9saWIvY29yZVwiKTtcbmNvbnN0IGRlYnVnID0gaW5pdERlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6b2dnJyk7XG5jbGFzcyBTZWdtZW50VGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5wYWdlX3NlZ21lbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgc3VtKGJ1Ziwgb2ZmLCBsZW4pIHtcbiAgICAgICAgbGV0IHMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gYnVmW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsUGFnZVNpemU6IFNlZ21lbnRUYWJsZS5zdW0oYnVmLCBvZmYsIHRoaXMubGVuKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VnbWVudFRhYmxlID0gU2VnbWVudFRhYmxlO1xuLyoqXG4gKiBQYXJzZXIgZm9yIE9nZyBsb2dpY2FsIGJpdHN0cmVhbSBmcmFtaW5nXG4gKi9cbmNsYXNzIE9nZ1BhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHBhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgZGVidWcoJ3Bvcz0lcywgcGFyc2VQYWdlKCknLCB0aGlzLnRva2VuaXplci5wb3NpdGlvbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihPZ2dQYXJzZXIuSGVhZGVyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoaGVhZGVyLmNhcHR1cmVQYXR0ZXJuLCAnT2dnUycsICdPZ2cgY2FwdHVyZSBwYXR0ZXJuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsICdPZ2cnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VOdW1iZXIgPSBoZWFkZXIucGFnZVNlcXVlbmNlTm87XG4gICAgICAgICAgICAgICAgZGVidWcoJ3BhZ2UjPSVzLCBPZ2cuaWQ9JXMnLCBoZWFkZXIucGFnZVNlcXVlbmNlTm8sIGhlYWRlci5jYXB0dXJlUGF0dGVybik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudFRhYmxlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBTZWdtZW50VGFibGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3RvdGFsUGFnZVNpemU9JXMnLCBzZWdtZW50VGFibGUudG90YWxQYWdlU2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZURhdGEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLkJ1ZmZlclR5cGUoc2VnbWVudFRhYmxlLnRvdGFsUGFnZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnZmlyc3RQYWdlPSVzLCBsYXN0UGFnZT0lcywgY29udGludWVkPSVzJywgaGVhZGVyLmhlYWRlclR5cGUuZmlyc3RQYWdlLCBoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSwgaGVhZGVyLmhlYWRlclR5cGUuY29udGludWVkKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmhlYWRlclR5cGUuZmlyc3RQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoNywgJ2FzY2lpJykuZ2V0KHBhZ2VEYXRhLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXHUwMDAxdm9yYmlzJzogLy8gT2dnL1ZvcmJpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdTZXQgcGFnZSBjb25zdW1lciB0byBPZ2cvVm9yYmlzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIgPSBuZXcgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyKHRoaXMubWV0YWRhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPcHVzSGVhJzogLy8gT2dnL09wdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnU2V0IHBhZ2UgY29uc3VtZXIgdG8gT2dnL09wdXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDb25zdW1lciA9IG5ldyBPcHVzUGFyc2VyXzEuT3B1c1BhcnNlcih0aGlzLm1ldGFkYXRhLCB0aGlzLm9wdGlvbnMsIHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwZWV4ICAnOiAvLyBPZ2cvU3BlZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnU2V0IHBhZ2UgY29uc3VtZXIgdG8gT2dnL1NwZWV4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIgPSBuZXcgU3BlZXhQYXJzZXJfMS5TcGVleFBhcnNlcih0aGlzLm1ldGFkYXRhLCB0aGlzLm9wdGlvbnMsIHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zpc2hlYWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXHUwMDAwdGhlb3JhJzogLy8gT2dnL1RoZW9yYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdTZXQgcGFnZSBjb25zdW1lciB0byBPZ2cvVGhlb3JhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIgPSBuZXcgVGhlb3JhUGFyc2VyXzEuVGhlb3JhUGFyc2VyKHRoaXMubWV0YWRhdGEsIHRoaXMub3B0aW9ucywgdGhpcy50b2tlbml6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dnIGF1ZGlvLWNvZGVjIG5vdCByZWNvZ25pemVkIChpZD0nICsgaWQgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUNvbnN1bWVyLnBhcnNlUGFnZShoZWFkZXIsIHBhZ2VEYXRhKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKCFoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGNvcmVfMS5FbmRPZlN0cmVhbUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdMYXN0IE9HRy1wYWdlIGlzIG5vdCBtYXJrZWQgd2l0aCBsYXN0LXBhZ2UgZmxhZycpO1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbmQtb2Ytc3RyZWFtYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdMYXN0IE9HRy1wYWdlIGlzIG5vdCBtYXJrZWQgd2l0aCBsYXN0LXBhZ2UgZmxhZycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDb25zdW1lci5jYWxjdWxhdGVEdXJhdGlvbih0aGlzLmhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnRm91ckNDJykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBlcnJvcjogd29yay1hcm91bmQgaWYgbGFzdCBPR0ctcGFnZSBpcyBub3QgbWFya2VkIHdpdGggbGFzdC1wYWdlIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdJbnZhbGlkIEZvdXJDQyBJRCwgbWF5YmUgbGFzdCBPR0ctcGFnZSBpcyBub3QgbWFya2VkIHdpdGggbGFzdC1wYWdlIGZsYWcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIuZmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9nZ1BhcnNlciA9IE9nZ1BhcnNlcjtcbk9nZ1BhcnNlci5IZWFkZXIgPSB7XG4gICAgbGVuOiAyNyxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FwdHVyZVBhdHRlcm46IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICB2ZXJzaW9uOiBidWYucmVhZFVJbnQ4KG9mZiArIDQpLFxuICAgICAgICAgICAgaGVhZGVyVHlwZToge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlZDogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChidWYsIG9mZiArIDUsIDApLFxuICAgICAgICAgICAgICAgIGZpcnN0UGFnZTogVXRpbF8xLmRlZmF1bHQuc3RydG9rQklUU0VULmdldChidWYsIG9mZiArIDUsIDEpLFxuICAgICAgICAgICAgICAgIGxhc3RQYWdlOiBVdGlsXzEuZGVmYXVsdC5zdHJ0b2tCSVRTRVQuZ2V0KGJ1Ziwgb2ZmICsgNSwgMilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwYWNrZXRfZmxhZzogYnVmLnJlYWRVSW50OChvZmYgKyA1KSxcbiAgICAgICAgICAgIGFic29sdXRlR3JhbnVsZVBvc2l0aW9uOiBidWYucmVhZEludExFKG9mZiArIDYsIDYpLFxuICAgICAgICAgICAgc3RyZWFtU2VyaWFsTnVtYmVyOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTQpLFxuICAgICAgICAgICAgcGFnZVNlcXVlbmNlTm86IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxOCksXG4gICAgICAgICAgICBwYWdlQ2hlY2tzdW06IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyMiksXG4gICAgICAgICAgICBwYWdlX3NlZ21lbnRzOiBidWYucmVhZFVJbnQ4KG9mZiArIDI2KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PZ2dQYXJzZXIuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/OggParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/opus/Opus.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/opus/Opus.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IdHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nclass IdHeader {\n    constructor(len) {\n        this.len = len;\n        if (len < 19) {\n            throw new Error(\"ID-header-page 0 should be at least 19 bytes long\");\n        }\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: buf.readUInt8(off + 8),\n            channelCount: buf.readUInt8(off + 9),\n            preSkip: buf.readInt16LE(off + 10),\n            inputSampleRate: buf.readInt32LE(off + 12),\n            outputGain: buf.readInt16LE(off + 16),\n            channelMapping: buf.readUInt8(off + 18)\n        };\n    }\n}\nexports.IdHeader = IdHeader;\n//# sourceMappingURL=Opus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9vcHVzL09wdXMuanM/YWFkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvb3B1cy9PcHVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG4vKipcbiAqIE9wdXMgSUQgSGVhZGVyIHBhcnNlclxuICogUmVmOiBodHRwczovL3dpa2kueGlwaC5vcmcvT2dnT3B1cyNJRF9IZWFkZXJcbiAqL1xuY2xhc3MgSWRIZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgICAgaWYgKGxlbiA8IDE5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJRC1oZWFkZXItcGFnZSAwIHNob3VsZCBiZSBhdCBsZWFzdCAxOSBieXRlcyBsb25nXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFnaWNTaWduYXR1cmU6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChidWYsIG9mZiArIDApLFxuICAgICAgICAgICAgdmVyc2lvbjogYnVmLnJlYWRVSW50OChvZmYgKyA4KSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogYnVmLnJlYWRVSW50OChvZmYgKyA5KSxcbiAgICAgICAgICAgIHByZVNraXA6IGJ1Zi5yZWFkSW50MTZMRShvZmYgKyAxMCksXG4gICAgICAgICAgICBpbnB1dFNhbXBsZVJhdGU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyAxMiksXG4gICAgICAgICAgICBvdXRwdXRHYWluOiBidWYucmVhZEludDE2TEUob2ZmICsgMTYpLFxuICAgICAgICAgICAgY2hhbm5lbE1hcHBpbmc6IGJ1Zi5yZWFkVUludDgob2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5JZEhlYWRlciA9IElkSGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3B1cy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/opus/Opus.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/opus/OpusParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/opus/OpusParser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OpusParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Opus = __webpack_require__(/*! ./Opus */ \"./node_modules/music-metadata/lib/ogg/opus/Opus.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../vorbis/VorbisParser */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggParser\n */\nclass OpusParser extends VorbisParser_1.VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n        this.lastPos = -1;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new Error(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n    }\n    parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\nexports.OpusParser = OpusParser;\n//# sourceMappingURL=OpusParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9vcHVzL09wdXNQYXJzZXIuanM/YzczZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxrRUFBUTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL29wdXMvT3B1c1BhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcHVzUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBPcHVzID0gcmVxdWlyZShcIi4vT3B1c1wiKTtcbmNvbnN0IFZvcmJpc1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL3ZvcmJpcy9Wb3JiaXNQYXJzZXJcIik7XG4vKipcbiAqIE9wdXMgcGFyc2VyXG4gKiBJbnRlcm5ldCBFbmdpbmVlcmluZyBUYXNrIEZvcmNlIChJRVRGKSAtIFJGQyA2NzE2XG4gKiBVc2VkIGJ5IE9nZ1BhcnNlclxuICovXG5jbGFzcyBPcHVzUGFyc2VyIGV4dGVuZHMgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHN1cGVyKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubGFzdFBvcyA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmaXJzdCBPcHVzIE9nZyBwYWdlXG4gICAgICogQHBhcmFtIHtJUGFnZUhlYWRlcn0gaGVhZGVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHBhZ2VEYXRhXG4gICAgICovXG4gICAgcGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAnT3B1cycpO1xuICAgICAgICAvLyBQYXJzZSBPcHVzIElEIEhlYWRlclxuICAgICAgICB0aGlzLmlkSGVhZGVyID0gbmV3IE9wdXMuSWRIZWFkZXIocGFnZURhdGEubGVuZ3RoKS5nZXQocGFnZURhdGEsIDApO1xuICAgICAgICBpZiAodGhpcy5pZEhlYWRlci5tYWdpY1NpZ25hdHVyZSAhPT0gXCJPcHVzSGVhZFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBvZ2cvT3B1cyBtYWdpYy1zaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgdGhpcy5pZEhlYWRlci5pbnB1dFNhbXBsZVJhdGUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIHRoaXMuaWRIZWFkZXIuY2hhbm5lbENvdW50KTtcbiAgICB9XG4gICAgcGFyc2VGdWxsUGFnZShwYWdlRGF0YSkge1xuICAgICAgICBjb25zdCBtYWdpY1NpZ25hdHVyZSA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIHN3aXRjaCAobWFnaWNTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ09wdXNUYWdzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVXNlckNvbW1lbnRMaXN0KHBhZ2VEYXRhLCA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RQb3MgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbiAtIHBhZ2VEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY3VsYXRlRHVyYXRpb24oaGVhZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlICYmIGhlYWRlci5hYnNvbHV0ZUdyYW51bGVQb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHBvc180OGJpdCA9IGhlYWRlci5hYnNvbHV0ZUdyYW51bGVQb3NpdGlvbiAtIHRoaXMuaWRIZWFkZXIucHJlU2tpcDtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBwb3NfNDhiaXQpO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgcG9zXzQ4Yml0IC8gNDgwMDApO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBvcyAhPT0gLTEgJiYgdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMubGFzdFBvcztcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIDggKiBkYXRhU2l6ZSAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT3B1c1BhcnNlciA9IE9wdXNQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcHVzUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/opus/OpusParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/speex/Speex.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/speex/Speex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexports.Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: Util_1.default.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: buf.readInt32LE(off + 28),\n            header_size: buf.readInt32LE(off + 32),\n            rate: buf.readInt32LE(off + 36),\n            mode: buf.readInt32LE(off + 40),\n            mode_bitstream_version: buf.readInt32LE(off + 44),\n            nb_channels: buf.readInt32LE(off + 48),\n            bitrate: buf.readInt32LE(off + 52),\n            frame_size: buf.readInt32LE(off + 56),\n            vbr: buf.readInt32LE(off + 60),\n            frames_per_packet: buf.readInt32LE(off + 64),\n            extra_headers: buf.readInt32LE(off + 68),\n            reserved1: buf.readInt32LE(off + 72),\n            reserved2: buf.readInt32LE(off + 76)\n        };\n    }\n};\n//# sourceMappingURL=Speex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9zcGVleC9TcGVleC5qcz8wNGNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDJFQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9zcGVleC9TcGVleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vVXRpbFwiKTtcbi8qKlxuICogU3BlZXggSGVhZGVyIFBhY2tldFxuICogUmVmOiBodHRwczovL3d3dy5zcGVleC5vcmcvZG9jcy9tYW51YWwvc3BlZXgtbWFudWFsL25vZGU4Lmh0bWwjU0VDVElPTjAwODMwMDAwMDAwMDAwMDAwMDAwXG4gKi9cbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGxlbjogODAsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwZWV4OiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg4LCAnYXNjaWknKS5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgIHZlcnNpb246IFV0aWxfMS5kZWZhdWx0LnRyaW1SaWdodE51bGwobmV3IFRva2VuLlN0cmluZ1R5cGUoMjAsICdhc2NpaScpLmdldChidWYsIG9mZiArIDgpKSxcbiAgICAgICAgICAgIHZlcnNpb25faWQ6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyAyOCksXG4gICAgICAgICAgICBoZWFkZXJfc2l6ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDMyKSxcbiAgICAgICAgICAgIHJhdGU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyAzNiksXG4gICAgICAgICAgICBtb2RlOiBidWYucmVhZEludDMyTEUob2ZmICsgNDApLFxuICAgICAgICAgICAgbW9kZV9iaXRzdHJlYW1fdmVyc2lvbjogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDQ0KSxcbiAgICAgICAgICAgIG5iX2NoYW5uZWxzOiBidWYucmVhZEludDMyTEUob2ZmICsgNDgpLFxuICAgICAgICAgICAgYml0cmF0ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDUyKSxcbiAgICAgICAgICAgIGZyYW1lX3NpemU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA1NiksXG4gICAgICAgICAgICB2YnI6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA2MCksXG4gICAgICAgICAgICBmcmFtZXNfcGVyX3BhY2tldDogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDY0KSxcbiAgICAgICAgICAgIGV4dHJhX2hlYWRlcnM6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA2OCksXG4gICAgICAgICAgICByZXNlcnZlZDE6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA3MiksXG4gICAgICAgICAgICByZXNlcnZlZDI6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA3NilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BlZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/speex/Speex.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpeexParser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Speex = __webpack_require__(/*! ./Speex */ \"./node_modules/music-metadata/lib/ogg/speex/Speex.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../vorbis/VorbisParser */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst debug = initDebug('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n *   https://www.speex.org/docs/manual/speex-manual/\n *   https://tools.ietf.org/html/rfc5574\n */\nclass SpeexParser extends VorbisParser_1.VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n    }\n}\nexports.SpeexParser = SpeexParser;\n//# sourceMappingURL=SpeexParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9zcGVleC9TcGVleFBhcnNlci5qcz8wMGY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBTztBQUNqQyxjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9zcGVleC9TcGVleFBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TcGVleFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGluaXREZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFNwZWV4ID0gcmVxdWlyZShcIi4vU3BlZXhcIik7XG5jb25zdCBWb3JiaXNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi92b3JiaXMvVm9yYmlzUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpvZ2c6c3BlZXgnKTtcbi8qKlxuICogU3BlZXgsIFJGQyA1NTc0XG4gKiBSZWY6XG4gKiAgIGh0dHBzOi8vd3d3LnNwZWV4Lm9yZy9kb2NzL21hbnVhbC9zcGVleC1tYW51YWwvXG4gKiAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NTc0XG4gKi9cbmNsYXNzIFNwZWV4UGFyc2VyIGV4dGVuZHMgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHN1cGVyKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGZpcnN0IFNwZWV4IE9nZyBwYWdlXG4gICAgICogQHBhcmFtIHtJUGFnZUhlYWRlcn0gaGVhZGVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHBhZ2VEYXRhXG4gICAgICovXG4gICAgcGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSkge1xuICAgICAgICBkZWJ1ZygnRmlyc3QgT2dnL1NwZWV4IHBhZ2UnKTtcbiAgICAgICAgY29uc3Qgc3BlZXhIZWFkZXIgPSBTcGVleC5IZWFkZXIuZ2V0KHBhZ2VEYXRhLCAwKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgYFNwZWV4ICR7c3BlZXhIZWFkZXIudmVyc2lvbn1gKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBzcGVleEhlYWRlci5uYl9jaGFubmVscyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgc3BlZXhIZWFkZXIucmF0ZSk7XG4gICAgICAgIGlmIChzcGVleEhlYWRlci5iaXRyYXRlICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBzcGVleEhlYWRlci5iaXRyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3BlZXhQYXJzZXIgPSBTcGVleFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwZWV4UGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/theora/Theora.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/theora/Theora.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IdentificationHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexports.IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: buf.readUInt8(off + 7),\n            vmin: buf.readUInt8(off + 8),\n            vrev: buf.readUInt8(off + 9),\n            vmbw: buf.readUInt16BE(off + 10),\n            vmbh: buf.readUInt16BE(off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: buf.readUInt8(off + 40)\n        };\n    }\n};\n//# sourceMappingURL=Theora.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy90aGVvcmEvVGhlb3JhLmpzP2YzZjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvdGhlb3JhL1RoZW9yYS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZGVudGlmaWNhdGlvbkhlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuLyoqXG4gKiA2LjIgSWRlbnRpZmljYXRpb24gSGVhZGVyXG4gKiBSZWY6IGh0dHBzOi8vdGhlb3JhLm9yZy9kb2MvVGhlb3JhLnBkZjogNi4yIElkZW50aWZpY2F0aW9uIEhlYWRlciBEZWNvZGVcbiAqL1xuZXhwb3J0cy5JZGVudGlmaWNhdGlvbkhlYWRlciA9IHtcbiAgICBsZW46IDQyLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogbmV3IFRva2VuLlN0cmluZ1R5cGUoNywgJ2FzY2lpJykuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIHZtYWo6IGJ1Zi5yZWFkVUludDgob2ZmICsgNyksXG4gICAgICAgICAgICB2bWluOiBidWYucmVhZFVJbnQ4KG9mZiArIDgpLFxuICAgICAgICAgICAgdnJldjogYnVmLnJlYWRVSW50OChvZmYgKyA5KSxcbiAgICAgICAgICAgIHZtYnc6IGJ1Zi5yZWFkVUludDE2QkUob2ZmICsgMTApLFxuICAgICAgICAgICAgdm1iaDogYnVmLnJlYWRVSW50MTZCRShvZmYgKyAxNyksXG4gICAgICAgICAgICBub21icjogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDM3KSxcbiAgICAgICAgICAgIG5xdWFsOiBidWYucmVhZFVJbnQ4KG9mZiArIDQwKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaGVvcmEuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/theora/Theora.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TheoraParser = void 0;\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst Theora_1 = __webpack_require__(/*! ./Theora */ \"./node_modules/music-metadata/lib/ogg/theora/Theora.js\");\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n *   https://theora.org/doc/Theora.pdf\n */\nclass TheoraParser {\n    constructor(metadata, options, tokenizer) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n    }\n    flush() {\n        debug('flush');\n    }\n    calculateDuration(header) {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = Theora_1.IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n    }\n}\nexports.TheoraParser = TheoraParser;\n//# sourceMappingURL=TheoraParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy90aGVvcmEvVGhlb3JhUGFyc2VyLmpzPzEwYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3RoZW9yYS9UaGVvcmFQYXJzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGhlb3JhUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgVGhlb3JhXzEgPSByZXF1aXJlKFwiLi9UaGVvcmFcIik7XG5jb25zdCBkZWJ1ZyA9IGluaXREZWJ1ZygnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOm9nZzp0aGVvcmEnKTtcbi8qKlxuICogUmVmOlxuICogICBodHRwczovL3RoZW9yYS5vcmcvZG9jL1RoZW9yYS5wZGZcbiAqL1xuY2xhc3MgVGhlb3JhUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZvcmJpcyAxIHBhcnNlclxuICAgICAqIEBwYXJhbSBoZWFkZXIgT2dnIFBhZ2UgSGVhZGVyXG4gICAgICogQHBhcmFtIHBhZ2VEYXRhIFBhZ2UgZGF0YVxuICAgICAqL1xuICAgIHBhcnNlUGFnZShoZWFkZXIsIHBhZ2VEYXRhKSB7XG4gICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5maXJzdFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGRlYnVnKCdmbHVzaCcpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVEdXJhdGlvbihoZWFkZXIpIHtcbiAgICAgICAgZGVidWcoJ2R1cmF0aW9uIGNhbGN1bGF0aW9uIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmaXJzdCBUaGVvcmEgT2dnIHBhZ2UuIHRoZSBpbml0aWFsIGlkZW50aWZpY2F0aW9uIGhlYWRlciBwYWNrZXRcbiAgICAgKiBAcGFyYW0ge0lQYWdlSGVhZGVyfSBoZWFkZXJcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcGFnZURhdGFcbiAgICAgKi9cbiAgICBwYXJzZUZpcnN0UGFnZShoZWFkZXIsIHBhZ2VEYXRhKSB7XG4gICAgICAgIGRlYnVnKCdGaXJzdCBPZ2cvVGhlb3JhIHBhZ2UnKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgJ1RoZW9yYScpO1xuICAgICAgICBjb25zdCBpZEhlYWRlciA9IFRoZW9yYV8xLklkZW50aWZpY2F0aW9uSGVhZGVyLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgaWRIZWFkZXIubm9tYnIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGhlb3JhUGFyc2VyID0gVGhlb3JhUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGhlb3JhUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IdentificationHeader = exports.CommonHeader = exports.VorbisPictureToken = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ../../id3v2/ID3v2Token */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nclass VorbisPictureToken {\n    constructor(len) {\n        this.len = len;\n    }\n    static fromBase64(base64str) {\n        return this.fromBuffer(Buffer.from(base64str, 'base64'));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    get(buffer, offset) {\n        const type = ID3v2Token_1.AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        const mimeLen = Token.UINT32_BE.get(buffer, offset += 4);\n        const format = buffer.toString('utf-8', offset += 4, offset + mimeLen);\n        const descLen = Token.UINT32_BE.get(buffer, offset += mimeLen);\n        const description = buffer.toString('utf-8', offset += 4, offset + descLen);\n        const width = Token.UINT32_BE.get(buffer, offset += descLen);\n        const height = Token.UINT32_BE.get(buffer, offset += 4);\n        const colour_depth = Token.UINT32_BE.get(buffer, offset += 4);\n        const indexed_color = Token.UINT32_BE.get(buffer, offset += 4);\n        const picDataLen = Token.UINT32_BE.get(buffer, offset += 4);\n        const data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\nexports.VorbisPictureToken = VorbisPictureToken;\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexports.CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: buf.readUInt8(off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexports.IdentificationHeader = {\n    len: 23,\n    get: (buf, off) => {\n        return {\n            version: buf.readUInt32LE(off + 0),\n            channelMode: buf.readUInt8(off + 4),\n            sampleRate: buf.readUInt32LE(off + 5),\n            bitrateMax: buf.readUInt32LE(off + 9),\n            bitrateNominal: buf.readUInt32LE(off + 13),\n            bitrateMin: buf.readUInt32LE(off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzLmpzPzcyMzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkZW50aWZpY2F0aW9uSGVhZGVyID0gZXhwb3J0cy5Db21tb25IZWFkZXIgPSBleHBvcnRzLlZvcmJpc1BpY3R1cmVUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgSUQzdjJUb2tlbl8xID0gcmVxdWlyZShcIi4uLy4uL2lkM3YyL0lEM3YyVG9rZW5cIik7XG4vKipcbiAqIFBhcnNlIHRoZSBNRVRBREFUQV9CTE9DS19QSUNUVVJFXG4gKiBSZWY6IGh0dHBzOi8vd2lraS54aXBoLm9yZy9Wb3JiaXNDb21tZW50I01FVEFEQVRBX0JMT0NLX1BJQ1RVUkVcbiAqIFJlZjogaHR0cHM6Ly94aXBoLm9yZy9mbGFjL2Zvcm1hdC5odG1sI21ldGFkYXRhX2Jsb2NrX3BpY3R1cmVcbiAqIC8vIFRvRG86IG1vdmUgdG8gSUQzIC8gQVBJQz9cbiAqL1xuY2xhc3MgVm9yYmlzUGljdHVyZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGJhc2U2NHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGJhc2U2NHN0ciwgJ2Jhc2U2NCcpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHBpYyA9IG5ldyBWb3JiaXNQaWN0dXJlVG9rZW4oYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBwaWMuZ2V0KGJ1ZmZlciwgMCk7XG4gICAgfVxuICAgIGdldChidWZmZXIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB0eXBlID0gSUQzdjJUb2tlbl8xLkF0dGFjaGVkUGljdHVyZVR5cGVbVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCldO1xuICAgICAgICBjb25zdCBtaW1lTGVuID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCArPSA0KTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcsIG9mZnNldCArPSA0LCBvZmZzZXQgKyBtaW1lTGVuKTtcbiAgICAgICAgY29uc3QgZGVzY0xlbiA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmZmVyLCBvZmZzZXQgKz0gbWltZUxlbik7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcsIG9mZnNldCArPSA0LCBvZmZzZXQgKyBkZXNjTGVuKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1ZmZlciwgb2Zmc2V0ICs9IGRlc2NMZW4pO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1ZmZlciwgb2Zmc2V0ICs9IDQpO1xuICAgICAgICBjb25zdCBjb2xvdXJfZGVwdGggPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1ZmZlciwgb2Zmc2V0ICs9IDQpO1xuICAgICAgICBjb25zdCBpbmRleGVkX2NvbG9yID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCArPSA0KTtcbiAgICAgICAgY29uc3QgcGljRGF0YUxlbiA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmZmVyLCBvZmZzZXQgKz0gNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShidWZmZXIuc2xpY2Uob2Zmc2V0ICs9IDQsIG9mZnNldCArIHBpY0RhdGFMZW4pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3VyX2RlcHRoLFxuICAgICAgICAgICAgaW5kZXhlZF9jb2xvcixcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlZvcmJpc1BpY3R1cmVUb2tlbiA9IFZvcmJpc1BpY3R1cmVUb2tlbjtcbi8qKlxuICogQ29tbWVudCBoZWFkZXIgZGVjb2RlclxuICogUmVmOiBodHRwczovL3hpcGgub3JnL3ZvcmJpcy9kb2MvVm9yYmlzX0lfc3BlYy5odG1sI3gxLTYyMDAwNC4yLjFcbiAqL1xuZXhwb3J0cy5Db21tb25IZWFkZXIgPSB7XG4gICAgbGVuOiA3LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWNrZXRUeXBlOiBidWYucmVhZFVJbnQ4KG9mZiksXG4gICAgICAgICAgICB2b3JiaXM6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDYsICdhc2NpaScpLmdldChidWYsIG9mZiArIDEpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogSWRlbnRpZmljYXRpb24gaGVhZGVyIGRlY29kZXJcbiAqIFJlZjogaHR0cHM6Ly94aXBoLm9yZy92b3JiaXMvZG9jL1ZvcmJpc19JX3NwZWMuaHRtbCN4MS02MzAwMDQuMi4yXG4gKi9cbmV4cG9ydHMuSWRlbnRpZmljYXRpb25IZWFkZXIgPSB7XG4gICAgbGVuOiAyMyxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogYnVmLnJlYWRVSW50MzJMRShvZmYgKyAwKSxcbiAgICAgICAgICAgIGNoYW5uZWxNb2RlOiBidWYucmVhZFVJbnQ4KG9mZiArIDQpLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogYnVmLnJlYWRVSW50MzJMRShvZmYgKyA1KSxcbiAgICAgICAgICAgIGJpdHJhdGVNYXg6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgOSksXG4gICAgICAgICAgICBiaXRyYXRlTm9taW5hbDogYnVmLnJlYWRVSW50MzJMRShvZmYgKyAxMyksXG4gICAgICAgICAgICBiaXRyYXRlTWluOiBidWYucmVhZFVJbnQzMkxFKG9mZiArIDE3KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Wb3JiaXMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VorbisDecoder = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nclass VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = this.data.toString('utf8', this.offset, this.offset + len);\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\nexports.VorbisDecoder = VorbisDecoder;\n//# sourceMappingURL=VorbisDecoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzRGVjb2Rlci5qcz81OTlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXNEZWNvZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvcmJpc0RlY29kZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNsYXNzIFZvcmJpc0RlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgcmVhZEludDMyKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFRva2VuLlVJTlQzMl9MRS5nZXQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFN0cmluZ1V0ZjgoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZEludDMyKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLnRvU3RyaW5nKCd1dGY4JywgdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHBhcnNlVXNlckNvbW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldDAgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMucmVhZFN0cmluZ1V0ZjgoKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdi5pbmRleE9mKCc9Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHYuc2xpY2UoMCwgaWR4KS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgdmFsdWU6IHYuc2xpY2UoaWR4ICsgMSksXG4gICAgICAgICAgICBsZW46IHRoaXMub2Zmc2V0IC0gb2Zmc2V0MFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVm9yYmlzRGVjb2RlciA9IFZvcmJpc0RlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Wb3JiaXNEZWNvZGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VorbisParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst _debug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst VorbisDecoder_1 = __webpack_require__(/*! ./VorbisDecoder */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\nconst Vorbis_1 = __webpack_require__(/*! ./Vorbis */ \"./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\nconst debug = _debug('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new Error(\"Cannot continue on previous page\");\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = Buffer.concat(this.pageSegments);\n                    this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    flush() {\n        this.parseFullPage(Buffer.concat(this.pageSegments));\n    }\n    parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(`Ignore picture`);\n                return;\n            }\n            value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug(\"Parse first page\");\n        // Parse  Vorbis common header\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new Error('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new Error('First Ogg page should be type 1: the identification header');\n    }\n    parseFullPage(pageData) {\n        // New page\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += this.parseUserComment(pageData, offset);\n        }\n    }\n}\nexports.VorbisParser = VorbisParser;\n//# sourceMappingURL=VorbisParser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzUGFyc2VyLmpzP2JkYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsOEVBQU87QUFDOUIsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHLFdBQVcsYUFBYTtBQUNqRTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUcsVUFBVSxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvdm9yYmlzL1ZvcmJpc1BhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb3JiaXNQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IF9kZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFZvcmJpc0RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL1ZvcmJpc0RlY29kZXJcIik7XG5jb25zdCBWb3JiaXNfMSA9IHJlcXVpcmUoXCIuL1ZvcmJpc1wiKTtcbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6b2dnOnZvcmJpczEnKTtcbi8qKlxuICogVm9yYmlzIDEgUGFyc2VyLlxuICogVXNlZCBieSBPZ2dQYXJzZXJcbiAqL1xuY2xhc3MgVm9yYmlzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGFnZVNlZ21lbnRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZvcmJpcyAxIHBhcnNlclxuICAgICAqIEBwYXJhbSBoZWFkZXIgT2dnIFBhZ2UgSGVhZGVyXG4gICAgICogQHBhcmFtIHBhZ2VEYXRhIFBhZ2UgZGF0YVxuICAgICAqL1xuICAgIHBhcnNlUGFnZShoZWFkZXIsIHBhZ2VEYXRhKSB7XG4gICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5maXJzdFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmhlYWRlclR5cGUuY29udGludWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFnZVNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udGludWUgb24gcHJldmlvdXMgcGFnZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlU2VnbWVudHMucHVzaChwYWdlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmhlYWRlclR5cGUubGFzdFBhZ2UgfHwgIWhlYWRlci5oZWFkZXJUeXBlLmNvbnRpbnVlZCkge1xuICAgICAgICAgICAgICAgIC8vIEZsdXNoIHBhZ2Ugc2VnbWVudHNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGFnZSA9IEJ1ZmZlci5jb25jYXQodGhpcy5wYWdlU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRnVsbFBhZ2UoZnVsbFBhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBwYWdlIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlU2VnbWVudHMgPSBoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSA/IFtdIDogW3BhZ2VEYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyLmhlYWRlclR5cGUubGFzdFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRHVyYXRpb24oaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5wYXJzZUZ1bGxQYWdlKEJ1ZmZlci5jb25jYXQodGhpcy5wYWdlU2VnbWVudHMpKTtcbiAgICB9XG4gICAgcGFyc2VVc2VyQ29tbWVudChwYWdlRGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVm9yYmlzRGVjb2Rlcl8xLlZvcmJpc0RlY29kZXIocGFnZURhdGEsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGRlY29kZXIucGFyc2VVc2VyQ29tbWVudCgpO1xuICAgICAgICB0aGlzLmFkZFRhZyh0YWcua2V5LCB0YWcudmFsdWUpO1xuICAgICAgICByZXR1cm4gdGFnLmxlbjtcbiAgICB9XG4gICAgYWRkVGFnKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT09ICdNRVRBREFUQV9CTE9DS19QSUNUVVJFJyAmJiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcENvdmVycykge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBJZ25vcmUgcGljdHVyZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gVm9yYmlzXzEuVm9yYmlzUGljdHVyZVRva2VuLmZyb21CYXNlNjQodmFsdWUpO1xuICAgICAgICAgICAgZGVidWcoYFB1c2ggcGljdHVyZTogaWQ9JHtpZH0sIGZvcm1hdD0ke3ZhbHVlLmZvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKGBQdXNoIHRhZzogaWQ9JHtpZH0sIHZhbHVlPSR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoJ3ZvcmJpcycsIGlkLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUR1cmF0aW9uKGhlYWRlcikge1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSAmJiBoZWFkZXIuYWJzb2x1dGVHcmFudWxlUG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgaGVhZGVyLmFic29sdXRlR3JhbnVsZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIHRoaXMubWV0YWRhdGEuZm9ybWF0Lm51bWJlck9mU2FtcGxlcyAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LnNhbXBsZVJhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGZpcnN0IE9nZy9Wb3JiaXMgcGFnZVxuICAgICAqIEBwYXJhbSB7SVBhZ2VIZWFkZXJ9IGhlYWRlclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBwYWdlRGF0YVxuICAgICAqL1xuICAgIHBhcnNlRmlyc3RQYWdlKGhlYWRlciwgcGFnZURhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgJ1ZvcmJpcyBJJyk7XG4gICAgICAgIGRlYnVnKFwiUGFyc2UgZmlyc3QgcGFnZVwiKTtcbiAgICAgICAgLy8gUGFyc2UgIFZvcmJpcyBjb21tb24gaGVhZGVyXG4gICAgICAgIGNvbnN0IGNvbW1vbkhlYWRlciA9IFZvcmJpc18xLkNvbW1vbkhlYWRlci5nZXQocGFnZURhdGEsIDApO1xuICAgICAgICBpZiAoY29tbW9uSGVhZGVyLnZvcmJpcyAhPT0gJ3ZvcmJpcycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGRvZXMgbm90IGxvb2sgbGlrZSBWb3JiaXMnKTtcbiAgICAgICAgaWYgKGNvbW1vbkhlYWRlci5wYWNrZXRUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZEhlYWRlciA9IFZvcmJpc18xLklkZW50aWZpY2F0aW9uSGVhZGVyLmdldChwYWdlRGF0YSwgVm9yYmlzXzEuQ29tbW9uSGVhZGVyLmxlbik7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGlkSGVhZGVyLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBpZEhlYWRlci5iaXRyYXRlTm9taW5hbCk7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGlkSGVhZGVyLmNoYW5uZWxNb2RlKTtcbiAgICAgICAgICAgIGRlYnVnKFwic2FtcGxlLXJhdGU9JXNbaHpdLCBiaXRyYXRlPSVzW2Ivc10sIGNoYW5uZWwtbW9kZT0lc1wiLCBpZEhlYWRlci5zYW1wbGVSYXRlLCBpZEhlYWRlci5iaXRyYXRlTm9taW5hbCwgaWRIZWFkZXIuY2hhbm5lbE1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgT2dnIHBhZ2Ugc2hvdWxkIGJlIHR5cGUgMTogdGhlIGlkZW50aWZpY2F0aW9uIGhlYWRlcicpO1xuICAgIH1cbiAgICBwYXJzZUZ1bGxQYWdlKHBhZ2VEYXRhKSB7XG4gICAgICAgIC8vIE5ldyBwYWdlXG4gICAgICAgIGNvbnN0IGNvbW1vbkhlYWRlciA9IFZvcmJpc18xLkNvbW1vbkhlYWRlci5nZXQocGFnZURhdGEsIDApO1xuICAgICAgICBkZWJ1ZyhcIlBhcnNlIGZ1bGwgcGFnZTogdHlwZT0lcywgYnl0ZUxlbmd0aD0lc1wiLCBjb21tb25IZWFkZXIucGFja2V0VHlwZSwgcGFnZURhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHN3aXRjaCAoY29tbW9uSGVhZGVyLnBhY2tldFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzogLy8gIHR5cGUgMzogY29tbWVudCBoZWFkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVzZXJDb21tZW50TGlzdChwYWdlRGF0YSwgVm9yYmlzXzEuQ29tbW9uSGVhZGVyLmxlbik7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHR5cGUgMTogdGhlIGlkZW50aWZpY2F0aW9uIGhlYWRlclxuICAgICAgICAgICAgY2FzZSA1OiAvLyB0eXBlIDU6IHNldHVwIGhlYWRlciB0eXBlXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZjogaHR0cHM6Ly94aXBoLm9yZy92b3JiaXMvZG9jL1ZvcmJpc19JX3NwZWMuaHRtbCN4MS04NDAwMDUuMlxuICAgICAqL1xuICAgIHBhcnNlVXNlckNvbW1lbnRMaXN0KHBhZ2VEYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc3RyTGVuID0gVG9rZW4uVUlOVDMyX0xFLmdldChwYWdlRGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIC8vIGNvbnN0IHZlbmRvclN0cmluZyA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKHN0ckxlbiwgJ3V0Zi04JykuZ2V0KHBhZ2VEYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gc3RyTGVuO1xuICAgICAgICBsZXQgdXNlckNvbW1lbnRMaXN0TGVuZ3RoID0gVG9rZW4uVUlOVDMyX0xFLmdldChwYWdlRGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHdoaWxlICh1c2VyQ29tbWVudExpc3RMZW5ndGgtLSA+IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLnBhcnNlVXNlckNvbW1lbnQocGFnZURhdGEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZvcmJpc1BhcnNlciA9IFZvcmJpc1BhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvcmJpc1BhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VorbisTagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../../common/GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * Vorbis tag mappings\n *\n * Mapping from native header format to one or possibly more 'common' entries\n * The common entries aim to read the same information from different media files\n * independent of the underlying format\n */\nconst vorbisTagMap = {\n    TITLE: \"title\",\n    ARTIST: \"artist\",\n    ARTISTS: \"artists\",\n    ALBUMARTIST: \"albumartist\",\n    ALBUM: \"album\",\n    DATE: \"date\",\n    ORIGINALDATE: \"originaldate\",\n    ORIGINALYEAR: \"originalyear\",\n    COMMENT: \"comment\",\n    TRACKNUMBER: \"track\",\n    DISCNUMBER: \"disk\",\n    GENRE: \"genre\",\n    METADATA_BLOCK_PICTURE: \"picture\",\n    COMPOSER: \"composer\",\n    LYRICS: \"lyrics\",\n    ALBUMSORT: \"albumsort\",\n    TITLESORT: \"titlesort\",\n    WORK: \"work\",\n    ARTISTSORT: \"artistsort\",\n    ALBUMARTISTSORT: \"albumartistsort\",\n    COMPOSERSORT: \"composersort\",\n    LYRICIST: \"lyricist\",\n    WRITER: \"writer\",\n    CONDUCTOR: \"conductor\",\n    // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo\n    REMIXER: \"remixer\",\n    ARRANGER: \"arranger\",\n    ENGINEER: \"engineer\",\n    PRODUCER: \"producer\",\n    DJMIXER: \"djmixer\",\n    MIXER: \"mixer\",\n    LABEL: \"label\",\n    GROUPING: \"grouping\",\n    SUBTITLE: \"subtitle\",\n    DISCSUBTITLE: \"discsubtitle\",\n    TRACKTOTAL: \"totaltracks\",\n    DISCTOTAL: \"totaldiscs\",\n    COMPILATION: \"compilation\",\n    RATING: \"rating\",\n    BPM: \"bpm\",\n    KEY: \"key\",\n    MOOD: \"mood\",\n    MEDIA: \"media\",\n    CATALOGNUMBER: \"catalognumber\",\n    RELEASESTATUS: \"releasestatus\",\n    RELEASETYPE: \"releasetype\",\n    RELEASECOUNTRY: \"releasecountry\",\n    SCRIPT: \"script\",\n    LANGUAGE: \"language\",\n    COPYRIGHT: \"copyright\",\n    LICENSE: \"license\",\n    ENCODEDBY: \"encodedby\",\n    ENCODERSETTINGS: \"encodersettings\",\n    BARCODE: \"barcode\",\n    ISRC: \"isrc\",\n    ASIN: \"asin\",\n    MUSICBRAINZ_TRACKID: \"musicbrainz_recordingid\",\n    MUSICBRAINZ_RELEASETRACKID: \"musicbrainz_trackid\",\n    MUSICBRAINZ_ALBUMID: \"musicbrainz_albumid\",\n    MUSICBRAINZ_ARTISTID: \"musicbrainz_artistid\",\n    MUSICBRAINZ_ALBUMARTISTID: \"musicbrainz_albumartistid\",\n    MUSICBRAINZ_RELEASEGROUPID: \"musicbrainz_releasegroupid\",\n    MUSICBRAINZ_WORKID: \"musicbrainz_workid\",\n    MUSICBRAINZ_TRMID: \"musicbrainz_trmid\",\n    MUSICBRAINZ_DISCID: \"musicbrainz_discid\",\n    ACOUSTID_ID: \"acoustid_id\",\n    ACOUSTID_ID_FINGERPRINT: \"acoustid_fingerprint\",\n    MUSICIP_PUID: \"musicip_puid\",\n    // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo\n    WEBSITE: \"website\",\n    NOTES: \"notes\",\n    TOTALTRACKS: \"totaltracks\",\n    TOTALDISCS: \"totaldiscs\",\n    // Discogs\n    DISCOGS_ARTIST_ID: \"discogs_artist_id\",\n    DISCOGS_ARTISTS: \"artists\",\n    DISCOGS_ARTIST_NAME: \"artists\",\n    DISCOGS_ALBUM_ARTISTS: \"albumartist\",\n    DISCOGS_CATALOG: \"catalognumber\",\n    DISCOGS_COUNTRY: \"releasecountry\",\n    DISCOGS_DATE: \"originaldate\",\n    DISCOGS_LABEL: \"label\",\n    DISCOGS_LABEL_ID: \"discogs_label_id\",\n    DISCOGS_MASTER_RELEASE_ID: \"discogs_master_release_id\",\n    DISCOGS_RATING: \"discogs_rating\",\n    DISCOGS_RELEASED: \"date\",\n    DISCOGS_RELEASE_ID: \"discogs_release_id\",\n    DISCOGS_VOTES: \"discogs_votes\",\n    CATALOGID: \"catalognumber\",\n    STYLE: \"genre\",\n    //\n    REPLAYGAIN_TRACK_GAIN: \"replaygain_track_gain\",\n    REPLAYGAIN_TRACK_PEAK: \"replaygain_track_peak\",\n    REPLAYGAIN_ALBUM_GAIN: \"replaygain_album_gain\",\n    REPLAYGAIN_ALBUM_PEAK: \"replaygain_album_peak\",\n    // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:\n    REPLAYGAIN_MINMAX: \"replaygain_track_minmax\",\n    REPLAYGAIN_ALBUM_MINMAX: \"replaygain_album_minmax\",\n    REPLAYGAIN_UNDO: \"replaygain_undo\"\n};\nclass VorbisTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    static toRating(email, rating) {\n        return {\n            source: email ? email.toLowerCase() : email,\n            rating: parseFloat(rating) * GenericTagMapper_1.CommonTagMapper.maxRatingScore\n        };\n    }\n    constructor() {\n        super(['vorbis'], vorbisTagMap);\n    }\n    postMap(tag) {\n        if (tag.id.indexOf('RATING:') === 0) {\n            const keys = tag.id.split(':');\n            tag.value = VorbisTagMapper.toRating(keys[1], tag.value);\n            tag.id = keys[0];\n        }\n    }\n}\nexports.VorbisTagMapper = VorbisTagMapper;\n//# sourceMappingURL=VorbisTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzVGFnTWFwcGVyLmpzPzhmMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLG1HQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXNUYWdNYXBwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVm9yYmlzVGFnTWFwcGVyID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuLyoqXG4gKiBWb3JiaXMgdGFnIG1hcHBpbmdzXG4gKlxuICogTWFwcGluZyBmcm9tIG5hdGl2ZSBoZWFkZXIgZm9ybWF0IHRvIG9uZSBvciBwb3NzaWJseSBtb3JlICdjb21tb24nIGVudHJpZXNcbiAqIFRoZSBjb21tb24gZW50cmllcyBhaW0gdG8gcmVhZCB0aGUgc2FtZSBpbmZvcm1hdGlvbiBmcm9tIGRpZmZlcmVudCBtZWRpYSBmaWxlc1xuICogaW5kZXBlbmRlbnQgb2YgdGhlIHVuZGVybHlpbmcgZm9ybWF0XG4gKi9cbmNvbnN0IHZvcmJpc1RhZ01hcCA9IHtcbiAgICBUSVRMRTogXCJ0aXRsZVwiLFxuICAgIEFSVElTVDogXCJhcnRpc3RcIixcbiAgICBBUlRJU1RTOiBcImFydGlzdHNcIixcbiAgICBBTEJVTUFSVElTVDogXCJhbGJ1bWFydGlzdFwiLFxuICAgIEFMQlVNOiBcImFsYnVtXCIsXG4gICAgREFURTogXCJkYXRlXCIsXG4gICAgT1JJR0lOQUxEQVRFOiBcIm9yaWdpbmFsZGF0ZVwiLFxuICAgIE9SSUdJTkFMWUVBUjogXCJvcmlnaW5hbHllYXJcIixcbiAgICBDT01NRU5UOiBcImNvbW1lbnRcIixcbiAgICBUUkFDS05VTUJFUjogXCJ0cmFja1wiLFxuICAgIERJU0NOVU1CRVI6IFwiZGlza1wiLFxuICAgIEdFTlJFOiBcImdlbnJlXCIsXG4gICAgTUVUQURBVEFfQkxPQ0tfUElDVFVSRTogXCJwaWN0dXJlXCIsXG4gICAgQ09NUE9TRVI6IFwiY29tcG9zZXJcIixcbiAgICBMWVJJQ1M6IFwibHlyaWNzXCIsXG4gICAgQUxCVU1TT1JUOiBcImFsYnVtc29ydFwiLFxuICAgIFRJVExFU09SVDogXCJ0aXRsZXNvcnRcIixcbiAgICBXT1JLOiBcIndvcmtcIixcbiAgICBBUlRJU1RTT1JUOiBcImFydGlzdHNvcnRcIixcbiAgICBBTEJVTUFSVElTVFNPUlQ6IFwiYWxidW1hcnRpc3Rzb3J0XCIsXG4gICAgQ09NUE9TRVJTT1JUOiBcImNvbXBvc2Vyc29ydFwiLFxuICAgIExZUklDSVNUOiBcImx5cmljaXN0XCIsXG4gICAgV1JJVEVSOiBcIndyaXRlclwiLFxuICAgIENPTkRVQ1RPUjogXCJjb25kdWN0b3JcIixcbiAgICAvLyAnUEVSRk9STUVSPWFydGlzdMKgKGluc3RydW1lbnQpJzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JywgLy8gVG9Eb1xuICAgIFJFTUlYRVI6IFwicmVtaXhlclwiLFxuICAgIEFSUkFOR0VSOiBcImFycmFuZ2VyXCIsXG4gICAgRU5HSU5FRVI6IFwiZW5naW5lZXJcIixcbiAgICBQUk9EVUNFUjogXCJwcm9kdWNlclwiLFxuICAgIERKTUlYRVI6IFwiZGptaXhlclwiLFxuICAgIE1JWEVSOiBcIm1peGVyXCIsXG4gICAgTEFCRUw6IFwibGFiZWxcIixcbiAgICBHUk9VUElORzogXCJncm91cGluZ1wiLFxuICAgIFNVQlRJVExFOiBcInN1YnRpdGxlXCIsXG4gICAgRElTQ1NVQlRJVExFOiBcImRpc2NzdWJ0aXRsZVwiLFxuICAgIFRSQUNLVE9UQUw6IFwidG90YWx0cmFja3NcIixcbiAgICBESVNDVE9UQUw6IFwidG90YWxkaXNjc1wiLFxuICAgIENPTVBJTEFUSU9OOiBcImNvbXBpbGF0aW9uXCIsXG4gICAgUkFUSU5HOiBcInJhdGluZ1wiLFxuICAgIEJQTTogXCJicG1cIixcbiAgICBLRVk6IFwia2V5XCIsXG4gICAgTU9PRDogXCJtb29kXCIsXG4gICAgTUVESUE6IFwibWVkaWFcIixcbiAgICBDQVRBTE9HTlVNQkVSOiBcImNhdGFsb2dudW1iZXJcIixcbiAgICBSRUxFQVNFU1RBVFVTOiBcInJlbGVhc2VzdGF0dXNcIixcbiAgICBSRUxFQVNFVFlQRTogXCJyZWxlYXNldHlwZVwiLFxuICAgIFJFTEVBU0VDT1VOVFJZOiBcInJlbGVhc2Vjb3VudHJ5XCIsXG4gICAgU0NSSVBUOiBcInNjcmlwdFwiLFxuICAgIExBTkdVQUdFOiBcImxhbmd1YWdlXCIsXG4gICAgQ09QWVJJR0hUOiBcImNvcHlyaWdodFwiLFxuICAgIExJQ0VOU0U6IFwibGljZW5zZVwiLFxuICAgIEVOQ09ERURCWTogXCJlbmNvZGVkYnlcIixcbiAgICBFTkNPREVSU0VUVElOR1M6IFwiZW5jb2RlcnNldHRpbmdzXCIsXG4gICAgQkFSQ09ERTogXCJiYXJjb2RlXCIsXG4gICAgSVNSQzogXCJpc3JjXCIsXG4gICAgQVNJTjogXCJhc2luXCIsXG4gICAgTVVTSUNCUkFJTlpfVFJBQ0tJRDogXCJtdXNpY2JyYWluel9yZWNvcmRpbmdpZFwiLFxuICAgIE1VU0lDQlJBSU5aX1JFTEVBU0VUUkFDS0lEOiBcIm11c2ljYnJhaW56X3RyYWNraWRcIixcbiAgICBNVVNJQ0JSQUlOWl9BTEJVTUlEOiBcIm11c2ljYnJhaW56X2FsYnVtaWRcIixcbiAgICBNVVNJQ0JSQUlOWl9BUlRJU1RJRDogXCJtdXNpY2JyYWluel9hcnRpc3RpZFwiLFxuICAgIE1VU0lDQlJBSU5aX0FMQlVNQVJUSVNUSUQ6IFwibXVzaWNicmFpbnpfYWxidW1hcnRpc3RpZFwiLFxuICAgIE1VU0lDQlJBSU5aX1JFTEVBU0VHUk9VUElEOiBcIm11c2ljYnJhaW56X3JlbGVhc2Vncm91cGlkXCIsXG4gICAgTVVTSUNCUkFJTlpfV09SS0lEOiBcIm11c2ljYnJhaW56X3dvcmtpZFwiLFxuICAgIE1VU0lDQlJBSU5aX1RSTUlEOiBcIm11c2ljYnJhaW56X3RybWlkXCIsXG4gICAgTVVTSUNCUkFJTlpfRElTQ0lEOiBcIm11c2ljYnJhaW56X2Rpc2NpZFwiLFxuICAgIEFDT1VTVElEX0lEOiBcImFjb3VzdGlkX2lkXCIsXG4gICAgQUNPVVNUSURfSURfRklOR0VSUFJJTlQ6IFwiYWNvdXN0aWRfZmluZ2VycHJpbnRcIixcbiAgICBNVVNJQ0lQX1BVSUQ6IFwibXVzaWNpcF9wdWlkXCIsXG4gICAgLy8gJ0ZJTkdFUlBSSU5UPU11c2ljTWFnaWMgRmluZ2VycHJpbnTCoHtmaW5nZXJwcmludH0nOiAnbXVzaWNpcF9maW5nZXJwcmludCcsIC8vIFRvRG9cbiAgICBXRUJTSVRFOiBcIndlYnNpdGVcIixcbiAgICBOT1RFUzogXCJub3Rlc1wiLFxuICAgIFRPVEFMVFJBQ0tTOiBcInRvdGFsdHJhY2tzXCIsXG4gICAgVE9UQUxESVNDUzogXCJ0b3RhbGRpc2NzXCIsXG4gICAgLy8gRGlzY29nc1xuICAgIERJU0NPR1NfQVJUSVNUX0lEOiBcImRpc2NvZ3NfYXJ0aXN0X2lkXCIsXG4gICAgRElTQ09HU19BUlRJU1RTOiBcImFydGlzdHNcIixcbiAgICBESVNDT0dTX0FSVElTVF9OQU1FOiBcImFydGlzdHNcIixcbiAgICBESVNDT0dTX0FMQlVNX0FSVElTVFM6IFwiYWxidW1hcnRpc3RcIixcbiAgICBESVNDT0dTX0NBVEFMT0c6IFwiY2F0YWxvZ251bWJlclwiLFxuICAgIERJU0NPR1NfQ09VTlRSWTogXCJyZWxlYXNlY291bnRyeVwiLFxuICAgIERJU0NPR1NfREFURTogXCJvcmlnaW5hbGRhdGVcIixcbiAgICBESVNDT0dTX0xBQkVMOiBcImxhYmVsXCIsXG4gICAgRElTQ09HU19MQUJFTF9JRDogXCJkaXNjb2dzX2xhYmVsX2lkXCIsXG4gICAgRElTQ09HU19NQVNURVJfUkVMRUFTRV9JRDogXCJkaXNjb2dzX21hc3Rlcl9yZWxlYXNlX2lkXCIsXG4gICAgRElTQ09HU19SQVRJTkc6IFwiZGlzY29nc19yYXRpbmdcIixcbiAgICBESVNDT0dTX1JFTEVBU0VEOiBcImRhdGVcIixcbiAgICBESVNDT0dTX1JFTEVBU0VfSUQ6IFwiZGlzY29nc19yZWxlYXNlX2lkXCIsXG4gICAgRElTQ09HU19WT1RFUzogXCJkaXNjb2dzX3ZvdGVzXCIsXG4gICAgQ0FUQUxPR0lEOiBcImNhdGFsb2dudW1iZXJcIixcbiAgICBTVFlMRTogXCJnZW5yZVwiLFxuICAgIC8vXG4gICAgUkVQTEFZR0FJTl9UUkFDS19HQUlOOiBcInJlcGxheWdhaW5fdHJhY2tfZ2FpblwiLFxuICAgIFJFUExBWUdBSU5fVFJBQ0tfUEVBSzogXCJyZXBsYXlnYWluX3RyYWNrX3BlYWtcIixcbiAgICBSRVBMQVlHQUlOX0FMQlVNX0dBSU46IFwicmVwbGF5Z2Fpbl9hbGJ1bV9nYWluXCIsXG4gICAgUkVQTEFZR0FJTl9BTEJVTV9QRUFLOiBcInJlcGxheWdhaW5fYWxidW1fcGVha1wiLFxuICAgIC8vIFRvIFN1cmUgaWYgdGhlc2UgKFJFUExBWUdBSU5fTUlOTUFYLCBSRVBMQVlHQUlOX0FMQlVNX01JTk1BWCAmIFJFUExBWUdBSU5fVU5ETykgYXJlIHVzZWQgZm9yIFZvcmJpczpcbiAgICBSRVBMQVlHQUlOX01JTk1BWDogXCJyZXBsYXlnYWluX3RyYWNrX21pbm1heFwiLFxuICAgIFJFUExBWUdBSU5fQUxCVU1fTUlOTUFYOiBcInJlcGxheWdhaW5fYWxidW1fbWlubWF4XCIsXG4gICAgUkVQTEFZR0FJTl9VTkRPOiBcInJlcGxheWdhaW5fdW5kb1wiXG59O1xuY2xhc3MgVm9yYmlzVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgc3RhdGljIHRvUmF0aW5nKGVtYWlsLCByYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogZW1haWwgPyBlbWFpbC50b0xvd2VyQ2FzZSgpIDogZW1haWwsXG4gICAgICAgICAgICByYXRpbmc6IHBhcnNlRmxvYXQocmF0aW5nKSAqIEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIubWF4UmF0aW5nU2NvcmVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFsndm9yYmlzJ10sIHZvcmJpc1RhZ01hcCk7XG4gICAgfVxuICAgIHBvc3RNYXAodGFnKSB7XG4gICAgICAgIGlmICh0YWcuaWQuaW5kZXhPZignUkFUSU5HOicpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGFnLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICB0YWcudmFsdWUgPSBWb3JiaXNUYWdNYXBwZXIudG9SYXRpbmcoa2V5c1sxXSwgdGFnLnZhbHVlKTtcbiAgICAgICAgICAgIHRhZy5pZCA9IGtleXNbMF07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZvcmJpc1RhZ01hcHBlciA9IFZvcmJpc1RhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvcmJpc1RhZ01hcHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/riff/RiffChunk.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/RiffChunk.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListInfoTagValue = exports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * Common RIFF chunk header\n */\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: FourCC_1.FourCcToken.get(buf, off),\n            // Size\n            chunkSize: buf.readUInt32LE(off + 4)\n        };\n    }\n};\n/**\n * Token to parse RIFF-INFO tag value\n */\nclass ListInfoTagValue {\n    constructor(tagHeader) {\n        this.tagHeader = tagHeader;\n        this.len = tagHeader.chunkSize;\n        this.len += this.len & 1; // if it is an odd length, round up to even\n    }\n    get(buf, off) {\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\n    }\n}\nexports.ListInfoTagValue = ListInfoTagValue;\n//# sourceMappingURL=RiffChunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvUmlmZkNodW5rLmpzPzhmNWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9yaWZmL1JpZmZDaHVuay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0SW5mb1RhZ1ZhbHVlID0gZXhwb3J0cy5IZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG4vKipcbiAqIENvbW1vbiBSSUZGIGNodW5rIGhlYWRlclxuICovXG5leHBvcnRzLkhlYWRlciA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIEdyb3VwLUlEXG4gICAgICAgICAgICBjaHVua0lEOiBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gU2l6ZVxuICAgICAgICAgICAgY2h1bmtTaXplOiBidWYucmVhZFVJbnQzMkxFKG9mZiArIDQpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogVG9rZW4gdG8gcGFyc2UgUklGRi1JTkZPIHRhZyB2YWx1ZVxuICovXG5jbGFzcyBMaXN0SW5mb1RhZ1ZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdIZWFkZXIpIHtcbiAgICAgICAgdGhpcy50YWdIZWFkZXIgPSB0YWdIZWFkZXI7XG4gICAgICAgIHRoaXMubGVuID0gdGFnSGVhZGVyLmNodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5sZW4gKz0gdGhpcy5sZW4gJiAxOyAvLyBpZiBpdCBpcyBhbiBvZGQgbGVuZ3RoLCByb3VuZCB1cCB0byBldmVuXG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuLlN0cmluZ1R5cGUodGhpcy50YWdIZWFkZXIuY2h1bmtTaXplLCAnYXNjaWknKS5nZXQoYnVmLCBvZmYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdEluZm9UYWdWYWx1ZSA9IExpc3RJbmZvVGFnVmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SaWZmQ2h1bmsuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/riff/RiffChunk.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RiffInfoTagMapper = exports.riffInfoTagMap = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * RIFF Info Tags; part of the EXIF 2.3\n * Ref: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html#Info\n */\nexports.riffInfoTagMap = {\n    IART: 'artist',\n    ICRD: 'date',\n    INAM: 'title',\n    TITL: 'title',\n    IPRD: 'album',\n    ITRK: 'track',\n    COMM: 'comment',\n    ICMT: 'comment',\n    ICNT: 'releasecountry',\n    GNRE: 'genre',\n    IWRI: 'writer',\n    RATE: 'rating',\n    YEAR: 'year',\n    ISFT: 'encodedby',\n    CODE: 'encodedby',\n    TURL: 'website',\n    IGNR: 'genre',\n    IENG: 'engineer',\n    ITCH: 'technician',\n    IMED: 'media',\n    IRPD: 'album' // Product, where the file was intended for\n};\nclass RiffInfoTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    constructor() {\n        super(['exif'], exports.riffInfoTagMap);\n    }\n}\nexports.RiffInfoTagMapper = RiffInfoTagMapper;\n//# sourceMappingURL=RiffInfoTagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvUmlmZkluZm9UYWdNYXAuanM/NDZkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQy9EO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvUmlmZkluZm9UYWdNYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmlmZkluZm9UYWdNYXBwZXIgPSBleHBvcnRzLnJpZmZJbmZvVGFnTWFwID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuLyoqXG4gKiBSSUZGIEluZm8gVGFnczsgcGFydCBvZiB0aGUgRVhJRiAyLjNcbiAqIFJlZjogaHR0cDovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9UYWdOYW1lcy9SSUZGLmh0bWwjSW5mb1xuICovXG5leHBvcnRzLnJpZmZJbmZvVGFnTWFwID0ge1xuICAgIElBUlQ6ICdhcnRpc3QnLFxuICAgIElDUkQ6ICdkYXRlJyxcbiAgICBJTkFNOiAndGl0bGUnLFxuICAgIFRJVEw6ICd0aXRsZScsXG4gICAgSVBSRDogJ2FsYnVtJyxcbiAgICBJVFJLOiAndHJhY2snLFxuICAgIENPTU06ICdjb21tZW50JyxcbiAgICBJQ01UOiAnY29tbWVudCcsXG4gICAgSUNOVDogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICBHTlJFOiAnZ2VucmUnLFxuICAgIElXUkk6ICd3cml0ZXInLFxuICAgIFJBVEU6ICdyYXRpbmcnLFxuICAgIFlFQVI6ICd5ZWFyJyxcbiAgICBJU0ZUOiAnZW5jb2RlZGJ5JyxcbiAgICBDT0RFOiAnZW5jb2RlZGJ5JyxcbiAgICBUVVJMOiAnd2Vic2l0ZScsXG4gICAgSUdOUjogJ2dlbnJlJyxcbiAgICBJRU5HOiAnZW5naW5lZXInLFxuICAgIElUQ0g6ICd0ZWNobmljaWFuJyxcbiAgICBJTUVEOiAnbWVkaWEnLFxuICAgIElSUEQ6ICdhbGJ1bScgLy8gUHJvZHVjdCwgd2hlcmUgdGhlIGZpbGUgd2FzIGludGVuZGVkIGZvclxufTtcbmNsYXNzIFJpZmZJbmZvVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFsnZXhpZiddLCBleHBvcnRzLnJpZmZJbmZvVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLlJpZmZJbmZvVGFnTWFwcGVyID0gUmlmZkluZm9UYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SaWZmSW5mb1RhZ01hcC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/riff/WaveParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/WaveParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WaveParser = void 0;\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst riff = __webpack_require__(/*! ./RiffChunk */ \"./node_modules/music-metadata/lib/riff/RiffChunk.js\");\nconst WaveChunk = __webpack_require__(/*! ./../wav/WaveChunk */ \"./node_modules/music-metadata/lib/wav/WaveChunk.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"./node_modules/music-metadata/lib/common/Util.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n *  http://soundfile.sapp.org/doc/WaveFormat\n *\n *  ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                case 'data': // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (header.chunkSize / this.blockAlign);\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                    this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            case 'adtl':\n            default:\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, Util_1.default.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw Error('Illegal remaining size: ' + chunkSize);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\nexports.WaveParser = WaveParser;\n//# sourceMappingURL=WaveParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvV2F2ZVBhcnNlci5qcz85NTA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBa0I7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLDREQUFhO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFPO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx3RUFBYTtBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWtCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLHNGQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLG1CQUFtQixtQkFBbUI7QUFDbkY7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QixpQ0FBaUMsZUFBZTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLE1BQU0saUJBQWlCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvV2F2ZVBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYXZlUGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgc3RydG9rMyA9IHJlcXVpcmUoXCJzdHJ0b2szL2xpYi9jb3JlXCIpO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBpbml0RGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCByaWZmID0gcmVxdWlyZShcIi4vUmlmZkNodW5rXCIpO1xuY29uc3QgV2F2ZUNodW5rID0gcmVxdWlyZShcIi4vLi4vd2F2L1dhdmVDaHVua1wiKTtcbmNvbnN0IElEM3YyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvSUQzdjJQYXJzZXJcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGluaXREZWJ1ZygnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOlJJRkYnKTtcbi8qKlxuICogUmVzb3VyY2UgSW50ZXJjaGFuZ2UgRmlsZSBGb3JtYXQgKFJJRkYpIFBhcnNlclxuICpcbiAqIFdBVkUgUENNIHNvdW5kZmlsZSBmb3JtYXRcbiAqXG4gKiBSZWY6XG4gKiAgaHR0cDovL3d3dy5qb2hubG9vbWlzLm9yZy9jcGUxMDIvYXNnbi9hc2duMS9yaWZmLmh0bWxcbiAqICBodHRwOi8vc291bmRmaWxlLnNhcHAub3JnL2RvYy9XYXZlRm9ybWF0XG4gKlxuICogIFRvRG86IFNwbGl0IFdBVkUgcGFydCBmcm9tIFJJRkYgcGFyc2VyXG4gKi9cbmNsYXNzIFdhdmVQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgcmlmZkhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihyaWZmLkhlYWRlcik7XG4gICAgICAgIGRlYnVnKGBwb3M9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn0sIHBhcnNlOiBjaHVua0lEPSR7cmlmZkhlYWRlci5jaHVua0lEfWApO1xuICAgICAgICBpZiAocmlmZkhlYWRlci5jaHVua0lEICE9PSAnUklGRicpXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vdCBSSUZGIGZvcm1hdFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJpZmZDaHVuayhyaWZmSGVhZGVyLmNodW5rU2l6ZSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHN0cnRvazMuRW5kT2ZTdHJlYW1FcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVJpZmZDaHVuayhjaHVua1NpemUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCB0eXBlKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdXQVZFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkV2F2ZUNodW5rKGNodW5rU2l6ZSAtIEZvdXJDQ18xLkZvdXJDY1Rva2VuLmxlbik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgUklGRiBmb3JtYXQ6IFJJRkYvJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRXYXZlQ2h1bmsocmVtYWluaW5nKSB7XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmcgPj0gcmlmZi5IZWFkZXIubGVuKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4ocmlmZi5IZWFkZXIpO1xuICAgICAgICAgICAgcmVtYWluaW5nIC09IHJpZmYuSGVhZGVyLmxlbiArIGhlYWRlci5jaHVua1NpemU7XG4gICAgICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIGRlYnVnKGBwb3M9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn0sIHJlYWRDaHVuazogY2h1bmtJRD1SSUZGL1dBVkUvJHtoZWFkZXIuY2h1bmtJRH1gKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaGVhZGVyLmNodW5rSUQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdMSVNUJzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXJzZUxpc3RUYWcoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFjdCc6IC8vIGV4dGVuZGVkIEZvcm1hdCBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY3QgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFdhdmVDaHVuay5GYWN0Q2h1bmsoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZtdCAnOiAvLyBUaGUgVXRpbCBDaHVuaywgbm9uLVBDTSBGb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgV2F2ZUNodW5rLkZvcm1hdChoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YkZvcm1hdCA9IFdhdmVDaHVuay5XYXZlRm9ybWF0W2ZtdC53Rm9ybWF0VGFnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdXQVZFL25vbi1QQ00gZm9ybWF0PScgKyBmbXQud0Zvcm1hdFRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJGb3JtYXQgPSAnbm9uLVBDTSAoJyArIGZtdC53Rm9ybWF0VGFnICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIHN1YkZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRzUGVyU2FtcGxlJywgZm10LndCaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBmbXQublNhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGZtdC5uQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGZtdC5uQmxvY2tBbGlnbiAqIGZtdC5uU2FtcGxlc1BlclNlYyAqIDgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrQWxpZ24gPSBmbXQubkJsb2NrQWxpZ247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2lkMyAnOiAvLyBUaGUgd2F5IFBpY2FyZCwgRm9vQmFyIGN1cnJlbnRseSBzdG9yZXMsIElEMyBtZXRhLWRhdGFcbiAgICAgICAgICAgICAgICBjYXNlICdJRDMgJzogLy8gVGhlIHdheSBNcDNUYWdzIHN0b3JlcyBJRDMgbWV0YS1kYXRhXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkM19kYXRhID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5CdWZmZXJUeXBlKGhlYWRlci5jaHVua1NpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnN0ID0gc3RydG9rMy5mcm9tQnVmZmVyKGlkM19kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IElEM3YyUGFyc2VyXzEuSUQzdjJQYXJzZXIoKS5wYXJzZSh0aGlzLm1ldGFkYXRhLCByc3QsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGEnOiAvLyBQQ00tZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQubG9zc2xlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlNhbXBsZXMgPSB0aGlzLmZhY3QgPyB0aGlzLmZhY3QuZHdTYW1wbGVMZW5ndGggOiAoaGVhZGVyLmNodW5rU2l6ZSAvIHRoaXMuYmxvY2tBbGlnbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBudW1iZXJPZlNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBudW1iZXJPZlNhbXBsZXMgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCB0aGlzLm1ldGFkYXRhLmZvcm1hdC5udW1iZXJPZkNoYW5uZWxzICogdGhpcy5ibG9ja0FsaWduICogdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSk7IC8vIFRvRG86IGNoZWNrIG1lXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIuY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYElnbm9yZSBjaHVuazogUklGRi8ke2hlYWRlci5jaHVua0lEfSBvZiAke2hlYWRlci5jaHVua1NpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnSWdub3JlIGNodW5rOiBSSUZGLycgKyBoZWFkZXIuY2h1bmtJRCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlci5jaHVua1NpemUgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1JlYWQgb2RkIHBhZGRpbmcgYnl0ZScpOyAvLyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHAvUklGRlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZUxpc3RUYWcobGlzdEhlYWRlcikge1xuICAgICAgICBjb25zdCBsaXN0VHlwZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgIGRlYnVnKCdwb3M9JXMsIHBhcnNlTGlzdFRhZzogY2h1bmtJRD1SSUZGL1dBVkUvTElTVC8lcycsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uLCBsaXN0VHlwZSk7XG4gICAgICAgIHN3aXRjaCAobGlzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0lORk8nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmlmZkluZm9UYWdzKGxpc3RIZWFkZXIuY2h1bmtTaXplIC0gNCk7XG4gICAgICAgICAgICBjYXNlICdhZHRsJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdJZ25vcmUgY2h1bms6IFJJRkYvV0FWRS9MSVNULycgKyBsaXN0VHlwZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0lnbm9yaW5nIGNodW5rSUQ9UklGRi9XQVZFL0xJU1QvJyArIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIuaWdub3JlKGxpc3RIZWFkZXIuY2h1bmtTaXplIC0gNCkudGhlbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUmlmZkluZm9UYWdzKGNodW5rU2l6ZSkge1xuICAgICAgICB3aGlsZSAoY2h1bmtTaXplID49IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihyaWZmLkhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVRva2VuID0gbmV3IHJpZmYuTGlzdEluZm9UYWdWYWx1ZShoZWFkZXIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4odmFsdWVUb2tlbik7XG4gICAgICAgICAgICB0aGlzLmFkZFRhZyhoZWFkZXIuY2h1bmtJRCwgVXRpbF8xLmRlZmF1bHQuc3RyaXBOdWxscyh2YWx1ZSkpO1xuICAgICAgICAgICAgY2h1bmtTaXplIC09ICg4ICsgdmFsdWVUb2tlbi5sZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVua1NpemUgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbGxlZ2FsIHJlbWFpbmluZyBzaXplOiAnICsgY2h1bmtTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYWcoaWQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuYWRkVGFnKCdleGlmJywgaWQsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLldhdmVQYXJzZXIgPSBXYXZlUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2F2ZVBhcnNlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/riff/WaveParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/type.js":
/*!*************************************************!*\
  !*** ./node_modules/music-metadata/lib/type.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrackType = void 0;\nvar TrackType;\n(function (TrackType) {\n    TrackType[TrackType[\"video\"] = 1] = \"video\";\n    TrackType[TrackType[\"audio\"] = 2] = \"audio\";\n    TrackType[TrackType[\"complex\"] = 3] = \"complex\";\n    TrackType[TrackType[\"logo\"] = 4] = \"logo\";\n    TrackType[TrackType[\"subtitle\"] = 17] = \"subtitle\";\n    TrackType[TrackType[\"button\"] = 18] = \"button\";\n    TrackType[TrackType[\"control\"] = 32] = \"control\";\n})(TrackType = exports.TrackType || (exports.TrackType = {}));\n//# sourceMappingURL=type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3R5cGUuanM/Y2VjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3R5cGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhY2tUeXBlID0gdm9pZCAwO1xudmFyIFRyYWNrVHlwZTtcbihmdW5jdGlvbiAoVHJhY2tUeXBlKSB7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcInZpZGVvXCJdID0gMV0gPSBcInZpZGVvXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcImF1ZGlvXCJdID0gMl0gPSBcImF1ZGlvXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcImNvbXBsZXhcIl0gPSAzXSA9IFwiY29tcGxleFwiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJsb2dvXCJdID0gNF0gPSBcImxvZ29cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wic3VidGl0bGVcIl0gPSAxN10gPSBcInN1YnRpdGxlXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcImJ1dHRvblwiXSA9IDE4XSA9IFwiYnV0dG9uXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcImNvbnRyb2xcIl0gPSAzMl0gPSBcImNvbnRyb2xcIjtcbn0pKFRyYWNrVHlwZSA9IGV4cG9ydHMuVHJhY2tUeXBlIHx8IChleHBvcnRzLlRyYWNrVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/type.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/wav/WaveChunk.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/WaveChunk.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FactChunk = exports.Format = exports.WaveFormat = void 0;\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\n */\nvar WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    // MPEG-4 and AAC Audio Types\n    WaveFormat[WaveFormat[\"ADPCM\"] = 2] = \"ADPCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"MPEG_ADTS_AAC\"] = 5632] = \"MPEG_ADTS_AAC\";\n    WaveFormat[WaveFormat[\"MPEG_LOAS\"] = 5634] = \"MPEG_LOAS\";\n    WaveFormat[WaveFormat[\"RAW_AAC1\"] = 255] = \"RAW_AAC1\";\n    // Dolby Audio Types\n    WaveFormat[WaveFormat[\"DOLBY_AC3_SPDIF\"] = 146] = \"DOLBY_AC3_SPDIF\";\n    WaveFormat[WaveFormat[\"DVM\"] = 8192] = \"DVM\";\n    WaveFormat[WaveFormat[\"RAW_SPORT\"] = 576] = \"RAW_SPORT\";\n    WaveFormat[WaveFormat[\"ESST_AC3\"] = 577] = \"ESST_AC3\";\n    WaveFormat[WaveFormat[\"DRM\"] = 9] = \"DRM\";\n    WaveFormat[WaveFormat[\"DTS2\"] = 8193] = \"DTS2\";\n    WaveFormat[WaveFormat[\"MPEG\"] = 80] = \"MPEG\";\n})(WaveFormat = exports.WaveFormat || (exports.WaveFormat = {}));\n/**\n * format chunk; chunk-id is \"fmt \"\n * http://soundfile.sapp.org/doc/WaveFormat/\n */\nclass Format {\n    constructor(header) {\n        assert.ok(header.chunkSize >= 16, '16 for PCM.');\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            wFormatTag: buf.readUInt16LE(off),\n            nChannels: buf.readUInt16LE(off + 2),\n            nSamplesPerSec: buf.readUInt32LE(off + 4),\n            nAvgBytesPerSec: buf.readUInt32LE(off + 8),\n            nBlockAlign: buf.readUInt16LE(off + 12),\n            wBitsPerSample: buf.readUInt16LE(off + 14)\n        };\n    }\n}\nexports.Format = Format;\n/**\n * Fact chunk; chunk-id is \"fact\"\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\n */\nclass FactChunk {\n    constructor(header) {\n        assert.ok(header.chunkSize >= 4, 'minimum fact chunk size.');\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            dwSampleLength: buf.readUInt32LE(off)\n        };\n    }\n}\nexports.FactChunk = FactChunk;\n//# sourceMappingURL=WaveChunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdi9XYXZlQ2h1bmsuanM/ODczNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZEQUE2RDtBQUM5RDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi93YXYvV2F2ZUNodW5rLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZhY3RDaHVuayA9IGV4cG9ydHMuRm9ybWF0ID0gZXhwb3J0cy5XYXZlRm9ybWF0ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbi8qKlxuICogUmVmOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDMxNzU5OSh2PXZzLjg1KS5hc3B4XG4gKi9cbnZhciBXYXZlRm9ybWF0O1xuKGZ1bmN0aW9uIChXYXZlRm9ybWF0KSB7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiUENNXCJdID0gMV0gPSBcIlBDTVwiO1xuICAgIC8vIE1QRUctNCBhbmQgQUFDIEF1ZGlvIFR5cGVzXG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiQURQQ01cIl0gPSAyXSA9IFwiQURQQ01cIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJJRUVFX0ZMT0FUXCJdID0gM10gPSBcIklFRUVfRkxPQVRcIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJNUEVHX0FEVFNfQUFDXCJdID0gNTYzMl0gPSBcIk1QRUdfQURUU19BQUNcIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJNUEVHX0xPQVNcIl0gPSA1NjM0XSA9IFwiTVBFR19MT0FTXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiUkFXX0FBQzFcIl0gPSAyNTVdID0gXCJSQVdfQUFDMVwiO1xuICAgIC8vIERvbGJ5IEF1ZGlvIFR5cGVzXG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiRE9MQllfQUMzX1NQRElGXCJdID0gMTQ2XSA9IFwiRE9MQllfQUMzX1NQRElGXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiRFZNXCJdID0gODE5Ml0gPSBcIkRWTVwiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIlJBV19TUE9SVFwiXSA9IDU3Nl0gPSBcIlJBV19TUE9SVFwiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIkVTU1RfQUMzXCJdID0gNTc3XSA9IFwiRVNTVF9BQzNcIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJEUk1cIl0gPSA5XSA9IFwiRFJNXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiRFRTMlwiXSA9IDgxOTNdID0gXCJEVFMyXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiTVBFR1wiXSA9IDgwXSA9IFwiTVBFR1wiO1xufSkoV2F2ZUZvcm1hdCA9IGV4cG9ydHMuV2F2ZUZvcm1hdCB8fCAoZXhwb3J0cy5XYXZlRm9ybWF0ID0ge30pKTtcbi8qKlxuICogZm9ybWF0IGNodW5rOyBjaHVuay1pZCBpcyBcImZtdCBcIlxuICogaHR0cDovL3NvdW5kZmlsZS5zYXBwLm9yZy9kb2MvV2F2ZUZvcm1hdC9cbiAqL1xuY2xhc3MgRm9ybWF0IHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIpIHtcbiAgICAgICAgYXNzZXJ0Lm9rKGhlYWRlci5jaHVua1NpemUgPj0gMTYsICcxNiBmb3IgUENNLicpO1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5jaHVua1NpemU7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd0Zvcm1hdFRhZzogYnVmLnJlYWRVSW50MTZMRShvZmYpLFxuICAgICAgICAgICAgbkNoYW5uZWxzOiBidWYucmVhZFVJbnQxNkxFKG9mZiArIDIpLFxuICAgICAgICAgICAgblNhbXBsZXNQZXJTZWM6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgNCksXG4gICAgICAgICAgICBuQXZnQnl0ZXNQZXJTZWM6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgOCksXG4gICAgICAgICAgICBuQmxvY2tBbGlnbjogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxMiksXG4gICAgICAgICAgICB3Qml0c1BlclNhbXBsZTogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxNClcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkZvcm1hdCA9IEZvcm1hdDtcbi8qKlxuICogRmFjdCBjaHVuazsgY2h1bmstaWQgaXMgXCJmYWN0XCJcbiAqIGh0dHA6Ly93d3ctbW1zcC5lY2UubWNnaWxsLmNhL0RvY3VtZW50cy9BdWRpb0Zvcm1hdHMvV0FWRS9XQVZFLmh0bWxcbiAqIGh0dHA6Ly93d3cucmVjb3JkaW5nYmxvZ3MuY29tL3dpa2kvZmFjdC1jaHVuay1vZi1hLXdhdmUtZmlsZVxuICovXG5jbGFzcyBGYWN0Q2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBhc3NlcnQub2soaGVhZGVyLmNodW5rU2l6ZSA+PSA0LCAnbWluaW11bSBmYWN0IGNodW5rIHNpemUuJyk7XG4gICAgICAgIHRoaXMubGVuID0gaGVhZGVyLmNodW5rU2l6ZTtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkd1NhbXBsZUxlbmd0aDogYnVmLnJlYWRVSW50MzJMRShvZmYpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5GYWN0Q2h1bmsgPSBGYWN0Q2h1bms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYXZlQ2h1bmsuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/wav/WaveChunk.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/wavpack/WavPackParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/wavpack/WavPackParser.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WavPackParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../apev2/APEv2Parser */ \"./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst WavPackToken_1 = __webpack_require__(/*! ./WavPackToken */ \"./node_modules/music-metadata/lib/wavpack/WavPackToken.js\");\nconst initDebug = __webpack_require__(/*! debug */ \"./node_modules/music-metadata/node_modules/debug/src/browser.js\");\nconst debug = initDebug('music-metadata:parser:WavPack');\n/**\n * WavPack Parser\n */\nclass WavPackParser extends BasicParser_1.BasicParser {\n    async parse() {\n        this.audioDataSize = 0;\n        // First parse all WavPack blocks\n        await this.parseWavPackBlocks();\n        // try to parse APEv2 header\n        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n    }\n    async parseWavPackBlocks() {\n        do {\n            const blockId = await this.tokenizer.peekToken(FourCC_1.FourCcToken);\n            if (blockId !== 'wvpk')\n                break;\n            const header = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);\n            assert.strictEqual(header.BlockID, 'wvpk', 'WavPack Block-ID');\n            debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`);\n            if (header.blockIndex === 0 && !this.metadata.format.container) {\n                this.metadata.setFormat('container', 'WavPack');\n                this.metadata.setFormat('lossless', !header.flags.isHybrid);\n                // tagTypes: this.type,\n                this.metadata.setFormat('bitsPerSample', header.flags.bitsPerSample);\n                if (!header.flags.isDSD) {\n                    // In case isDSD, these values will ne set in ID_DSD_BLOCK\n                    this.metadata.setFormat('sampleRate', header.flags.samplingRate);\n                    this.metadata.setFormat('duration', header.totalSamples / header.flags.samplingRate);\n                }\n                this.metadata.setFormat('numberOfChannels', header.flags.isMono ? 1 : 2);\n                this.metadata.setFormat('numberOfSamples', header.totalSamples);\n                this.metadata.setFormat('codec', header.flags.isDSD ? 'DSD' : 'PCM');\n            }\n            const ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);\n            if (header.blockIndex === 0) {\n                // Meta-data block\n                await this.parseMetadataSubBlock(header, ignoreBytes);\n            }\n            else {\n                await this.tokenizer.ignore(ignoreBytes);\n            }\n            if (header.blockSamples > 0) {\n                this.audioDataSize += header.blockSize; // Count audio data for bit-rate calculation\n            }\n        } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);\n        this.metadata.setFormat('bitrate', this.audioDataSize * 8 / this.metadata.format.duration);\n    }\n    /**\n     * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks\n     * @param remainingLength\n     */\n    async parseMetadataSubBlock(header, remainingLength) {\n        while (remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len) {\n            const id = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);\n            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? Token.UINT24_LE : Token.UINT8);\n            const data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));\n            await this.tokenizer.readBuffer(data);\n            debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);\n            switch (id.functionId) {\n                case 0x0: // ID_DUMMY: could be used to pad WavPack blocks\n                    break;\n                case 0xe: // ID_DSD_BLOCK\n                    debug('ID_DSD_BLOCK');\n                    // https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n                    const mp = 1 << data.readUInt8(0);\n                    const samplingRate = header.flags.samplingRate * mp * 8; // ToDo: second factor should be read from DSD-metadata block https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n                    assert.ok(header.flags.isDSD, 'Only expect DSD block if DSD-flag is set');\n                    this.metadata.setFormat('sampleRate', samplingRate);\n                    this.metadata.setFormat('duration', header.totalSamples / samplingRate);\n                    break;\n                case 0x24: // ID_ALT_TRAILER: maybe used to embed original ID3 tag header\n                    debug('ID_ALT_TRAILER: trailer for non-wav files');\n                    break;\n                case 0x26: // ID_MD5_CHECKSUM\n                    this.metadata.setFormat('audioMD5', data);\n                    break;\n                case 0x2f: // ID_BLOCK_CHECKSUM\n                    debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString('hex')}`);\n                    break;\n                default:\n                    debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);\n                    break;\n            }\n            remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token.UINT24_LE.len : Token.UINT8.len) + dataSizeInWords * 2;\n            debug(`remainingLength=${remainingLength}`);\n            if (id.isOddSize)\n                this.tokenizer.ignore(1);\n        }\n        assert.strictEqual(remainingLength, 0, 'metadata-sub-block should fit it remaining length');\n    }\n}\nexports.WavPackParser = WavPackParser;\n//# sourceMappingURL=WavPackParser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdnBhY2svV2F2UGFja1BhcnNlci5qcz9lOTA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDhFQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGlGQUFnQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0IsUUFBUSw0Q0FBNEM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCLGtCQUFrQixjQUFjLGFBQWEsWUFBWTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0EsK0VBQStFLDJCQUEyQjtBQUMxRztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdnBhY2svV2F2UGFja1BhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYXZQYWNrUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgQVBFdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IFdhdlBhY2tUb2tlbl8xID0gcmVxdWlyZShcIi4vV2F2UGFja1Rva2VuXCIpO1xuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSBpbml0RGVidWcoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpXYXZQYWNrJyk7XG4vKipcbiAqIFdhdlBhY2sgUGFyc2VyXG4gKi9cbmNsYXNzIFdhdlBhY2tQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdGhpcy5hdWRpb0RhdGFTaXplID0gMDtcbiAgICAgICAgLy8gRmlyc3QgcGFyc2UgYWxsIFdhdlBhY2sgYmxvY2tzXG4gICAgICAgIGF3YWl0IHRoaXMucGFyc2VXYXZQYWNrQmxvY2tzKCk7XG4gICAgICAgIC8vIHRyeSB0byBwYXJzZSBBUEV2MiBoZWFkZXJcbiAgICAgICAgcmV0dXJuIEFQRXYyUGFyc2VyXzEuQVBFdjJQYXJzZXIudHJ5UGFyc2VBcGVIZWFkZXIodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlV2F2UGFja0Jsb2NrcygpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tJZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgICAgICBpZiAoYmxvY2tJZCAhPT0gJ3d2cGsnKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFdhdlBhY2tUb2tlbl8xLldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbik7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoaGVhZGVyLkJsb2NrSUQsICd3dnBrJywgJ1dhdlBhY2sgQmxvY2stSUQnKTtcbiAgICAgICAgICAgIGRlYnVnKGBXYXZQYWNrIGhlYWRlciBibG9ja0luZGV4PSR7aGVhZGVyLmJsb2NrSW5kZXh9LCBsZW49JHtXYXZQYWNrVG9rZW5fMS5XYXZQYWNrLkJsb2NrSGVhZGVyVG9rZW4ubGVufWApO1xuICAgICAgICAgICAgaWYgKGhlYWRlci5ibG9ja0luZGV4ID09PSAwICYmICF0aGlzLm1ldGFkYXRhLmZvcm1hdC5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ1dhdlBhY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCAhaGVhZGVyLmZsYWdzLmlzSHlicmlkKTtcbiAgICAgICAgICAgICAgICAvLyB0YWdUeXBlczogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRzUGVyU2FtcGxlJywgaGVhZGVyLmZsYWdzLmJpdHNQZXJTYW1wbGUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVyLmZsYWdzLmlzRFNEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXNEU0QsIHRoZXNlIHZhbHVlcyB3aWxsIG5lIHNldCBpbiBJRF9EU0RfQkxPQ0tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBoZWFkZXIuZmxhZ3Muc2FtcGxpbmdSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgaGVhZGVyLnRvdGFsU2FtcGxlcyAvIGhlYWRlci5mbGFncy5zYW1wbGluZ1JhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGhlYWRlci5mbGFncy5pc01vbm8gPyAxIDogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mU2FtcGxlcycsIGhlYWRlci50b3RhbFNhbXBsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIGhlYWRlci5mbGFncy5pc0RTRCA/ICdEU0QnIDogJ1BDTScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWdub3JlQnl0ZXMgPSBoZWFkZXIuYmxvY2tTaXplIC0gKFdhdlBhY2tUb2tlbl8xLldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbi5sZW4gLSA4KTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIuYmxvY2tJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE1ldGEtZGF0YSBibG9ja1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VNZXRhZGF0YVN1YkJsb2NrKGhlYWRlciwgaWdub3JlQnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGlnbm9yZUJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIuYmxvY2tTYW1wbGVzID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9EYXRhU2l6ZSArPSBoZWFkZXIuYmxvY2tTaXplOyAvLyBDb3VudCBhdWRpbyBkYXRhIGZvciBiaXQtcmF0ZSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSB8fCB0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24gPj0gV2F2UGFja1Rva2VuXzEuV2F2UGFjay5CbG9ja0hlYWRlclRva2VuLmxlbik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgdGhpcy5hdWRpb0RhdGFTaXplICogOCAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmOiBodHRwOi8vd3d3LndhdnBhY2suY29tL1dhdlBhY2s1RmlsZUZvcm1hdC5wZGYsIDMuMCBNZXRhZGF0YSBTdWItYmxvY2tzXG4gICAgICogQHBhcmFtIHJlbWFpbmluZ0xlbmd0aFxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlTWV0YWRhdGFTdWJCbG9jayhoZWFkZXIsIHJlbWFpbmluZ0xlbmd0aCkge1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nTGVuZ3RoID4gV2F2UGFja1Rva2VuXzEuV2F2UGFjay5NZXRhZGF0YUlkVG9rZW4ubGVuKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihXYXZQYWNrVG9rZW5fMS5XYXZQYWNrLk1ldGFkYXRhSWRUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBkYXRhU2l6ZUluV29yZHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkTnVtYmVyKGlkLmxhcmdlQmxvY2sgPyBUb2tlbi5VSU5UMjRfTEUgOiBUb2tlbi5VSU5UOCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFTaXplSW5Xb3JkcyAqIDIgLSAoaWQuaXNPZGRTaXplID8gMSA6IDApKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICBkZWJ1ZyhgTWV0YWRhdGEgU3ViLUJsb2NrcyBmdW5jdGlvbklkPTB4JHtpZC5mdW5jdGlvbklkLnRvU3RyaW5nKDE2KX0sIGlkLmxhcmdlQmxvY2s9JHtpZC5sYXJnZUJsb2NrfSxkYXRhLXNpemU9JHtkYXRhLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaWQuZnVuY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwOiAvLyBJRF9EVU1NWTogY291bGQgYmUgdXNlZCB0byBwYWQgV2F2UGFjayBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweGU6IC8vIElEX0RTRF9CTE9DS1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnSURfRFNEX0JMT0NLJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYnJ5L1dhdlBhY2svaXNzdWVzLzcxI2lzc3VlY29tbWVudC00ODMwOTQ4MTNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXAgPSAxIDw8IGRhdGEucmVhZFVJbnQ4KDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBoZWFkZXIuZmxhZ3Muc2FtcGxpbmdSYXRlICogbXAgKiA4OyAvLyBUb0RvOiBzZWNvbmQgZmFjdG9yIHNob3VsZCBiZSByZWFkIGZyb20gRFNELW1ldGFkYXRhIGJsb2NrIGh0dHBzOi8vZ2l0aHViLmNvbS9kYnJ5L1dhdlBhY2svaXNzdWVzLzcxI2lzc3VlY29tbWVudC00ODMwOTQ4MTNcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGhlYWRlci5mbGFncy5pc0RTRCwgJ09ubHkgZXhwZWN0IERTRCBibG9jayBpZiBEU0QtZmxhZyBpcyBzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBzYW1wbGluZ1JhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBoZWFkZXIudG90YWxTYW1wbGVzIC8gc2FtcGxpbmdSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDI0OiAvLyBJRF9BTFRfVFJBSUxFUjogbWF5YmUgdXNlZCB0byBlbWJlZCBvcmlnaW5hbCBJRDMgdGFnIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnSURfQUxUX1RSQUlMRVI6IHRyYWlsZXIgZm9yIG5vbi13YXYgZmlsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDI2OiAvLyBJRF9NRDVfQ0hFQ0tTVU1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2F1ZGlvTUQ1JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyZjogLy8gSURfQkxPQ0tfQ0hFQ0tTVU1cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYElEX0JMT0NLX0NIRUNLU1VNOiBjaGVja3N1bT0ke2RhdGEudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlIHVuc3VwcG9ydGVkIG1ldGEtc3ViLWJsb2NrLWlkIGZ1bmN0aW9uSWQ9MHgke2lkLmZ1bmN0aW9uSWQudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbWFpbmluZ0xlbmd0aCAtPSBXYXZQYWNrVG9rZW5fMS5XYXZQYWNrLk1ldGFkYXRhSWRUb2tlbi5sZW4gKyAoaWQubGFyZ2VCbG9jayA/IFRva2VuLlVJTlQyNF9MRS5sZW4gOiBUb2tlbi5VSU5UOC5sZW4pICsgZGF0YVNpemVJbldvcmRzICogMjtcbiAgICAgICAgICAgIGRlYnVnKGByZW1haW5pbmdMZW5ndGg9JHtyZW1haW5pbmdMZW5ndGh9YCk7XG4gICAgICAgICAgICBpZiAoaWQuaXNPZGRTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmlnbm9yZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocmVtYWluaW5nTGVuZ3RoLCAwLCAnbWV0YWRhdGEtc3ViLWJsb2NrIHNob3VsZCBmaXQgaXQgcmVtYWluaW5nIGxlbmd0aCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2F2UGFja1BhcnNlciA9IFdhdlBhY2tQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYXZQYWNrUGFyc2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/wavpack/WavPackParser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/lib/wavpack/WavPackToken.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/wavpack/WavPackToken.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WavPack = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100,\n    48000, 64000, 88200, 96000, 192000, -1];\nclass WavPack {\n    static isBitSet(flags, bitOffset) {\n        return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\n    }\n    static getBitAllignedNumber(flags, bitOffset, len) {\n        return (flags >>> bitOffset) & (0xffffffff >>> (32 - len));\n    }\n}\nexports.WavPack = WavPack;\n/**\n * WavPack Block Header\n *\n * 32-byte little-endian header at the front of every WavPack block\n *\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\n */\nWavPack.BlockHeaderToken = {\n    len: 32,\n    get: (buf, off) => {\n        const flags = Token.UINT32_LE.get(buf, off + 24);\n        const res = {\n            // should equal 'wvpk'\n            BlockID: FourCC_1.FourCcToken.get(buf, off),\n            //  0x402 to 0x410 are valid for decode\n            blockSize: Token.UINT32_LE.get(buf, off + 4),\n            //  0x402 (1026) to 0x410 are valid for decode\n            version: Token.UINT16_LE.get(buf, off + 8),\n            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */ Token.UINT32_LE.get(buf, off + 12),\n            // 40-bit block_index\n            blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */ Token.UINT32_LE.get(buf, off + 16),\n            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            blockSamples: Token.UINT32_LE.get(buf, off + 20),\n            // various flags for id and decoding\n            flags: {\n                bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\n                isMono: WavPack.isBitSet(flags, 2),\n                isHybrid: WavPack.isBitSet(flags, 3),\n                isJointStereo: WavPack.isBitSet(flags, 4),\n                crossChannel: WavPack.isBitSet(flags, 5),\n                hybridNoiseShaping: WavPack.isBitSet(flags, 6),\n                floatingPoint: WavPack.isBitSet(flags, 7),\n                samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\n                isDSD: WavPack.isBitSet(flags, 31)\n            },\n            // crc for actual decoded data\n            crc: new Token.BufferType(4).get(buf, off + 28)\n        };\n        if (res.flags.isDSD) {\n            res.totalSamples *= 8;\n        }\n        return res;\n    }\n};\n/**\n * 3.0 Metadata Sub-Blocks\n *  Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\n */\nWavPack.MetadataIdToken = {\n    len: 1,\n    get: (buf, off) => {\n        return {\n            functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\n            isOptional: WavPack.isBitSet(buf[off], 5),\n            isOddSize: WavPack.isBitSet(buf[off], 6),\n            largeBlock: WavPack.isBitSet(buf[off], 7)\n        };\n    }\n};\n//# sourceMappingURL=WavPackToken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdnBhY2svV2F2UGFja1Rva2VuLmpzP2NiNGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0REFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdnBhY2svV2F2UGFja1Rva2VuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhdlBhY2sgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBTYW1wbGVSYXRlcyA9IFs2MDAwLCA4MDAwLCA5NjAwLCAxMTAyNSwgMTIwMDAsIDE2MDAwLCAyMjA1MCwgMjQwMDAsIDMyMDAwLCA0NDEwMCxcbiAgICA0ODAwMCwgNjQwMDAsIDg4MjAwLCA5NjAwMCwgMTkyMDAwLCAtMV07XG5jbGFzcyBXYXZQYWNrIHtcbiAgICBzdGF0aWMgaXNCaXRTZXQoZmxhZ3MsIGJpdE9mZnNldCkge1xuICAgICAgICByZXR1cm4gV2F2UGFjay5nZXRCaXRBbGxpZ25lZE51bWJlcihmbGFncywgYml0T2Zmc2V0LCAxKSA9PT0gMTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJpdEFsbGlnbmVkTnVtYmVyKGZsYWdzLCBiaXRPZmZzZXQsIGxlbikge1xuICAgICAgICByZXR1cm4gKGZsYWdzID4+PiBiaXRPZmZzZXQpICYgKDB4ZmZmZmZmZmYgPj4+ICgzMiAtIGxlbikpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2F2UGFjayA9IFdhdlBhY2s7XG4vKipcbiAqIFdhdlBhY2sgQmxvY2sgSGVhZGVyXG4gKlxuICogMzItYnl0ZSBsaXR0bGUtZW5kaWFuIGhlYWRlciBhdCB0aGUgZnJvbnQgb2YgZXZlcnkgV2F2UGFjayBibG9ja1xuICpcbiAqIFJlZjogaHR0cDovL3d3dy53YXZwYWNrLmNvbS9XYXZQYWNrNUZpbGVGb3JtYXQucGRmIChwYWdlIDIvNjogMi4wIFwiQmxvY2sgSGVhZGVyXCIpXG4gKi9cbldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbiA9IHtcbiAgICBsZW46IDMyLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDI0KTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGVxdWFsICd3dnBrJ1xuICAgICAgICAgICAgQmxvY2tJRDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIC8vICAweDQwMiB0byAweDQxMCBhcmUgdmFsaWQgZm9yIGRlY29kZVxuICAgICAgICAgICAgYmxvY2tTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICAvLyAgMHg0MDIgKDEwMjYpIHRvIDB4NDEwIGFyZSB2YWxpZCBmb3IgZGVjb2RlXG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICAvLyAgNDAtYml0IHRvdGFsIHNhbXBsZXMgZm9yIGVudGlyZSBmaWxlIChpZiBibG9ja19pbmRleCA9PSAwIGFuZCBhIHZhbHVlIG9mIC0xIGluZGljYXRlcyBhbiB1bmtub3duIGxlbmd0aClcbiAgICAgICAgICAgIHRvdGFsU2FtcGxlczogLyogcmVwbGFjZSB3aXRoIGJpZ2ludD8gKFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDExKSA8PCAzMikgKyAqLyBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgLy8gNDAtYml0IGJsb2NrX2luZGV4XG4gICAgICAgICAgICBibG9ja0luZGV4OiAvKiByZXBsYWNlIHdpdGggYmlnaW50PyAoVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMTApIDw8IDMyKSArICovIFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyA0MC1iaXQgdG90YWwgc2FtcGxlcyBmb3IgZW50aXJlIGZpbGUgKGlmIGJsb2NrX2luZGV4ID09IDAgYW5kIGEgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGFuIHVua25vd24gbGVuZ3RoKVxuICAgICAgICAgICAgYmxvY2tTYW1wbGVzOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgLy8gdmFyaW91cyBmbGFncyBmb3IgaWQgYW5kIGRlY29kaW5nXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgIGJpdHNQZXJTYW1wbGU6ICgxICsgV2F2UGFjay5nZXRCaXRBbGxpZ25lZE51bWJlcihmbGFncywgMCwgMikpICogOCxcbiAgICAgICAgICAgICAgICBpc01vbm86IFdhdlBhY2suaXNCaXRTZXQoZmxhZ3MsIDIpLFxuICAgICAgICAgICAgICAgIGlzSHlicmlkOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCAzKSxcbiAgICAgICAgICAgICAgICBpc0pvaW50U3RlcmVvOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCA0KSxcbiAgICAgICAgICAgICAgICBjcm9zc0NoYW5uZWw6IFdhdlBhY2suaXNCaXRTZXQoZmxhZ3MsIDUpLFxuICAgICAgICAgICAgICAgIGh5YnJpZE5vaXNlU2hhcGluZzogV2F2UGFjay5pc0JpdFNldChmbGFncywgNiksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdQb2ludDogV2F2UGFjay5pc0JpdFNldChmbGFncywgNyksXG4gICAgICAgICAgICAgICAgc2FtcGxpbmdSYXRlOiBTYW1wbGVSYXRlc1tXYXZQYWNrLmdldEJpdEFsbGlnbmVkTnVtYmVyKGZsYWdzLCAyMywgNCldLFxuICAgICAgICAgICAgICAgIGlzRFNEOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCAzMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjcmMgZm9yIGFjdHVhbCBkZWNvZGVkIGRhdGFcbiAgICAgICAgICAgIGNyYzogbmV3IFRva2VuLkJ1ZmZlclR5cGUoNCkuZ2V0KGJ1Ziwgb2ZmICsgMjgpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXMuZmxhZ3MuaXNEU0QpIHtcbiAgICAgICAgICAgIHJlcy50b3RhbFNhbXBsZXMgKj0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG4vKipcbiAqIDMuMCBNZXRhZGF0YSBTdWItQmxvY2tzXG4gKiAgUmVmOiBodHRwOi8vd3d3LndhdnBhY2suY29tL1dhdlBhY2s1RmlsZUZvcm1hdC5wZGYgKHBhZ2UgNC82OiAzLjAgXCJNZXRhZGF0YSBTdWItQmxvY2tcIilcbiAqL1xuV2F2UGFjay5NZXRhZGF0YUlkVG9rZW4gPSB7XG4gICAgbGVuOiAxLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdW5jdGlvbklkOiBXYXZQYWNrLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1ZltvZmZdLCAwLCA2KSxcbiAgICAgICAgICAgIGlzT3B0aW9uYWw6IFdhdlBhY2suaXNCaXRTZXQoYnVmW29mZl0sIDUpLFxuICAgICAgICAgICAgaXNPZGRTaXplOiBXYXZQYWNrLmlzQml0U2V0KGJ1ZltvZmZdLCA2KSxcbiAgICAgICAgICAgIGxhcmdlQmxvY2s6IFdhdlBhY2suaXNCaXRTZXQoYnVmW29mZl0sIDcpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhdlBhY2tUb2tlbi5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/lib/wavpack/WavPackToken.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/debug/src/browser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/debug/src/browser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/music-metadata/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzU5MDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7O0FBRW5DLE9BQU8sV0FBVzs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0Ly8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0Ly8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0cmV0dXJuIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuXHRcdGNvbnNvbGUubG9nICYmXG5cdFx0Y29uc29sZS5sb2coLi4uYXJncyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/debug/src/common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/debug/src/common.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/music-metadata/node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/MTBlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBSTs7QUFFcEM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0Ly8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdFx0Ly8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuXG5cdFx0Ly8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcblx0XHRcdGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/file-type/core.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/file-type/core.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nconst Token = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"./node_modules/strtok3/lib/core.js\");\nconst {\n\tstringToBytes,\n\ttarHeaderChecksumMatches,\n\tuint32SyncSafeToken\n} = __webpack_require__(/*! ./util */ \"./node_modules/music-metadata/node_modules/file-type/util.js\");\nconst supported = __webpack_require__(/*! ./supported */ \"./node_modules/music-metadata/node_modules/file-type/supported.js\");\n\nconst minimumBytes = 4100; // A fair amount of file-types are detectable within this range\n\nasync function fromStream(stream) {\n\tconst tokenizer = await strtok3.fromStream(stream);\n\ttry {\n\t\treturn await fromTokenizer(tokenizer);\n\t} finally {\n\t\tawait tokenizer.close();\n\t}\n}\n\nasync function fromBuffer(input) {\n\tif (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {\n\t\tthrow new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``);\n\t}\n\n\tconst buffer = input instanceof Buffer ? input : Buffer.from(input);\n\n\tif (!(buffer && buffer.length > 1)) {\n\t\treturn;\n\t}\n\n\tconst tokenizer = strtok3.fromBuffer(buffer);\n\treturn fromTokenizer(tokenizer);\n}\n\nfunction _check(buffer, headers, options) {\n\toptions = {\n\t\toffset: 0,\n\t\t...options\n\t};\n\n\tfor (const [index, header] of headers.entries()) {\n\t\t// If a bitmask is set\n\t\tif (options.mask) {\n\t\t\t// If header doesn't equal `buf` with bits masked off\n\t\t\tif (header !== (options.mask[index] & buffer[index + options.offset])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (header !== buffer[index + options.offset]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nasync function _checkSequence(sequence, tokenizer, ignoreBytes) {\n\tconst buffer = Buffer.alloc(minimumBytes);\n\tawait tokenizer.ignore(ignoreBytes);\n\n\tawait tokenizer.peekBuffer(buffer, {mayBeLess: true});\n\n\treturn buffer.includes(Buffer.from(sequence));\n}\n\nasync function fromTokenizer(tokenizer) {\n\ttry {\n\t\treturn _fromTokenizer(tokenizer);\n\t} catch (error) {\n\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function _fromTokenizer(tokenizer) {\n\tlet buffer = Buffer.alloc(minimumBytes);\n\tconst bytesRead = 12;\n\tconst check = (header, options) => _check(buffer, header, options);\n\tconst checkString = (header, options) => check(stringToBytes(header), options);\n\tconst checkSequence = (sequence, ignoreBytes) => _checkSequence(sequence, tokenizer, ignoreBytes);\n\n\t// Keep reading until EOF if the file size is unknown.\n\tif (!tokenizer.fileInfo.size) {\n\t\ttokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;\n\t}\n\n\tawait tokenizer.peekBuffer(buffer, {length: bytesRead, mayBeLess: true});\n\n\t// -- 2-byte signatures --\n\n\tif (check([0x42, 0x4D])) {\n\t\treturn {\n\t\t\text: 'bmp',\n\t\t\tmime: 'image/bmp'\n\t\t};\n\t}\n\n\tif (check([0x0B, 0x77])) {\n\t\treturn {\n\t\t\text: 'ac3',\n\t\t\tmime: 'audio/vnd.dolby.dd-raw'\n\t\t};\n\t}\n\n\tif (check([0x78, 0x01])) {\n\t\treturn {\n\t\t\text: 'dmg',\n\t\t\tmime: 'application/x-apple-diskimage'\n\t\t};\n\t}\n\n\tif (check([0x4D, 0x5A])) {\n\t\treturn {\n\t\t\text: 'exe',\n\t\t\tmime: 'application/x-msdownload'\n\t\t};\n\t}\n\n\tif (check([0x25, 0x21])) {\n\t\tawait tokenizer.peekBuffer(buffer, {length: 24, mayBeLess: true});\n\n\t\tif (checkString('PS-Adobe-', {offset: 2}) &&\n\t\t\tcheckString(' EPSF-', {offset: 14})) {\n\t\t\treturn {\n\t\t\t\text: 'eps',\n\t\t\t\tmime: 'application/eps'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'ps',\n\t\t\tmime: 'application/postscript'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x1F, 0xA0]) ||\n\t\tcheck([0x1F, 0x9D])\n\t) {\n\t\treturn {\n\t\t\text: 'Z',\n\t\t\tmime: 'application/x-compress'\n\t\t};\n\t}\n\n\t// -- 3-byte signatures --\n\n\tif (check([0xFF, 0xD8, 0xFF])) {\n\t\treturn {\n\t\t\text: 'jpg',\n\t\t\tmime: 'image/jpeg'\n\t\t};\n\t}\n\n\tif (check([0x49, 0x49, 0xBC])) {\n\t\treturn {\n\t\t\text: 'jxr',\n\t\t\tmime: 'image/vnd.ms-photo'\n\t\t};\n\t}\n\n\tif (check([0x1F, 0x8B, 0x8])) {\n\t\treturn {\n\t\t\text: 'gz',\n\t\t\tmime: 'application/gzip'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x5A, 0x68])) {\n\t\treturn {\n\t\t\text: 'bz2',\n\t\t\tmime: 'application/x-bzip2'\n\t\t};\n\t}\n\n\tif (checkString('ID3')) {\n\t\tawait tokenizer.ignore(6); // Skip ID3 header until the header size\n\t\tconst id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);\n\t\tif (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {\n\t\t\t// Guess file type based on ID3 header for backward compatibility\n\t\t\treturn {\n\t\t\t\text: 'mp3',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\tawait tokenizer.ignore(id3HeaderLen);\n\t\treturn fromTokenizer(tokenizer); // Skip ID3 header, recursion\n\t}\n\n\t// Musepack, SV7\n\tif (checkString('MP+')) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\tif (\n\t\t(buffer[0] === 0x43 || buffer[0] === 0x46) &&\n\t\tcheck([0x57, 0x53], {offset: 1})\n\t) {\n\t\treturn {\n\t\t\text: 'swf',\n\t\t\tmime: 'application/x-shockwave-flash'\n\t\t};\n\t}\n\n\t// -- 4-byte signatures --\n\n\tif (check([0x47, 0x49, 0x46])) {\n\t\treturn {\n\t\t\text: 'gif',\n\t\t\tmime: 'image/gif'\n\t\t};\n\t}\n\n\tif (checkString('FLIF')) {\n\t\treturn {\n\t\t\text: 'flif',\n\t\t\tmime: 'image/flif'\n\t\t};\n\t}\n\n\tif (checkString('8BPS')) {\n\t\treturn {\n\t\t\text: 'psd',\n\t\t\tmime: 'image/vnd.adobe.photoshop'\n\t\t};\n\t}\n\n\tif (checkString('WEBP', {offset: 8})) {\n\t\treturn {\n\t\t\text: 'webp',\n\t\t\tmime: 'image/webp'\n\t\t};\n\t}\n\n\t// Musepack, SV8\n\tif (checkString('MPCK')) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\tif (checkString('FORM')) {\n\t\treturn {\n\t\t\text: 'aif',\n\t\t\tmime: 'audio/aiff'\n\t\t};\n\t}\n\n\tif (checkString('icns', {offset: 0})) {\n\t\treturn {\n\t\t\text: 'icns',\n\t\t\tmime: 'image/icns'\n\t\t};\n\t}\n\n\t// Zip-based file formats\n\t// Need to be before the `zip` check\n\tif (check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature\n\t\ttry {\n\t\t\twhile (tokenizer.position + 30 < tokenizer.fileInfo.size) {\n\t\t\t\tawait tokenizer.readBuffer(buffer, {length: 30});\n\n\t\t\t\t// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers\n\t\t\t\tconst zipHeader = {\n\t\t\t\t\tcompressedSize: buffer.readUInt32LE(18),\n\t\t\t\t\tuncompressedSize: buffer.readUInt32LE(22),\n\t\t\t\t\tfilenameLength: buffer.readUInt16LE(26),\n\t\t\t\t\textraFieldLength: buffer.readUInt16LE(28)\n\t\t\t\t};\n\n\t\t\t\tzipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));\n\t\t\t\tawait tokenizer.ignore(zipHeader.extraFieldLength);\n\n\t\t\t\t// Assumes signed `.xpi` from addons.mozilla.org\n\t\t\t\tif (zipHeader.filename === 'META-INF/mozilla.rsa') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'xpi',\n\t\t\t\t\t\tmime: 'application/x-xpinstall'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {\n\t\t\t\t\tconst type = zipHeader.filename.split('/')[0];\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase '_rels':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'word':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'docx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'ppt':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'pptx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'xl':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'xlsx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (zipHeader.filename.startsWith('xl/')) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'xlsx',\n\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// The docx, xlsx and pptx file types extend the Office Open XML file format:\n\t\t\t\t// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats\n\t\t\t\t// We look for:\n\t\t\t\t// - one entry named '[Content_Types].xml' or '_rels/.rels',\n\t\t\t\t// - one entry indicating specific type of file.\n\t\t\t\t// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.\n\t\t\t\tif (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {\n\t\t\t\t\tconst mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));\n\n\t\t\t\t\tswitch (mimeType) {\n\t\t\t\t\t\tcase 'application/epub+zip':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'epub',\n\t\t\t\t\t\t\t\tmime: 'application/epub+zip'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.text':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'odt',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.text'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.spreadsheet':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'ods',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.spreadsheet'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.presentation':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'odp',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.presentation'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to find next header manually when current one is corrupted\n\t\t\t\tif (zipHeader.compressedSize === 0) {\n\t\t\t\t\tlet nextHeaderIndex = -1;\n\n\t\t\t\t\twhile (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {\n\t\t\t\t\t\tawait tokenizer.peekBuffer(buffer, {mayBeLess: true});\n\n\t\t\t\t\t\tnextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');\n\t\t\t\t\t\t// Move position to the next header if found, skip the whole buffer otherwise\n\t\t\t\t\t\tawait tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait tokenizer.ignore(zipHeader.compressedSize);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\text: 'zip',\n\t\t\tmime: 'application/zip'\n\t\t};\n\t}\n\n\tif (checkString('OggS')) {\n\t\t// This is an OGG container\n\t\tawait tokenizer.ignore(28);\n\t\tconst type = Buffer.alloc(8);\n\t\tawait tokenizer.readBuffer(type);\n\n\t\t// Needs to be before `ogg` check\n\t\tif (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {\n\t\t\treturn {\n\t\t\t\text: 'opus',\n\t\t\t\tmime: 'audio/opus'\n\t\t\t};\n\t\t}\n\n\t\t// If ' theora' in header.\n\t\tif (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {\n\t\t\treturn {\n\t\t\t\text: 'ogv',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01video' in header.\n\t\tif (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'ogm',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If ' FLAC' in header  https://xiph.org/flac/faq.html\n\t\tif (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {\n\t\t\treturn {\n\t\t\t\text: 'oga',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex\n\t\tif (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {\n\t\t\treturn {\n\t\t\t\text: 'spx',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01vorbis' in header\n\t\tif (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {\n\t\t\treturn {\n\t\t\t\text: 'ogg',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// Default OGG container https://www.iana.org/assignments/media-types/application/ogg\n\t\treturn {\n\t\t\text: 'ogx',\n\t\t\tmime: 'application/ogg'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x50, 0x4B]) &&\n\t\t(buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) &&\n\t\t(buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8)\n\t) {\n\t\treturn {\n\t\t\text: 'zip',\n\t\t\tmime: 'application/zip'\n\t\t};\n\t}\n\n\t//\n\n\t// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)\n\t// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.\n\t// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n\t// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n\tif (\n\t\tcheckString('ftyp', {offset: 4}) &&\n\t\t(buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?\n\t) {\n\t\t// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.\n\t\t// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.\n\t\tconst brandMajor = buffer.toString('binary', 8, 12).replace('\\0', ' ').trim();\n\t\tswitch (brandMajor) {\n\t\t\tcase 'avif':\n\t\t\t\treturn {ext: 'avif', mime: 'image/avif'};\n\t\t\tcase 'mif1':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heif'};\n\t\t\tcase 'msf1':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heif-sequence'};\n\t\t\tcase 'heic':\n\t\t\tcase 'heix':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heic'};\n\t\t\tcase 'hevc':\n\t\t\tcase 'hevx':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heic-sequence'};\n\t\t\tcase 'qt':\n\t\t\t\treturn {ext: 'mov', mime: 'video/quicktime'};\n\t\t\tcase 'M4V':\n\t\t\tcase 'M4VH':\n\t\t\tcase 'M4VP':\n\t\t\t\treturn {ext: 'm4v', mime: 'video/x-m4v'};\n\t\t\tcase 'M4P':\n\t\t\t\treturn {ext: 'm4p', mime: 'video/mp4'};\n\t\t\tcase 'M4B':\n\t\t\t\treturn {ext: 'm4b', mime: 'audio/mp4'};\n\t\t\tcase 'M4A':\n\t\t\t\treturn {ext: 'm4a', mime: 'audio/x-m4a'};\n\t\t\tcase 'F4V':\n\t\t\t\treturn {ext: 'f4v', mime: 'video/mp4'};\n\t\t\tcase 'F4P':\n\t\t\t\treturn {ext: 'f4p', mime: 'video/mp4'};\n\t\t\tcase 'F4A':\n\t\t\t\treturn {ext: 'f4a', mime: 'audio/mp4'};\n\t\t\tcase 'F4B':\n\t\t\t\treturn {ext: 'f4b', mime: 'audio/mp4'};\n\t\t\tcase 'crx':\n\t\t\t\treturn {ext: 'cr3', mime: 'image/x-canon-cr3'};\n\t\t\tdefault:\n\t\t\t\tif (brandMajor.startsWith('3g')) {\n\t\t\t\t\tif (brandMajor.startsWith('3g2')) {\n\t\t\t\t\t\treturn {ext: '3g2', mime: 'video/3gpp2'};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {ext: '3gp', mime: 'video/3gpp'};\n\t\t\t\t}\n\n\t\t\t\treturn {ext: 'mp4', mime: 'video/mp4'};\n\t\t}\n\t}\n\n\tif (checkString('MThd')) {\n\t\treturn {\n\t\t\text: 'mid',\n\t\t\tmime: 'audio/midi'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('wOFF') &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheckString('OTTO', {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff',\n\t\t\tmime: 'font/woff'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('wOF2') &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheckString('OTTO', {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff2',\n\t\t\tmime: 'font/woff2'\n\t\t};\n\t}\n\n\tif (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {\n\t\treturn {\n\t\t\text: 'pcap',\n\t\t\tmime: 'application/vnd.tcpdump.pcap'\n\t\t};\n\t}\n\n\t// Sony DSD Stream File (DSF)\n\tif (checkString('DSD ')) {\n\t\treturn {\n\t\t\text: 'dsf',\n\t\t\tmime: 'audio/x-dsf' // Non-standard\n\t\t};\n\t}\n\n\tif (checkString('LZIP')) {\n\t\treturn {\n\t\t\text: 'lz',\n\t\t\tmime: 'application/x-lzip'\n\t\t};\n\t}\n\n\tif (checkString('fLaC')) {\n\t\treturn {\n\t\t\text: 'flac',\n\t\t\tmime: 'audio/x-flac'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x50, 0x47, 0xFB])) {\n\t\treturn {\n\t\t\text: 'bpg',\n\t\t\tmime: 'image/bpg'\n\t\t};\n\t}\n\n\tif (checkString('wvpk')) {\n\t\treturn {\n\t\t\text: 'wv',\n\t\t\tmime: 'audio/wavpack'\n\t\t};\n\t}\n\n\tif (checkString('%PDF')) {\n\t\t// Check if this is an Adobe Illustrator file\n\t\tconst isAiFile = await checkSequence('Adobe Illustrator', 1350);\n\t\tif (isAiFile) {\n\t\t\treturn {\n\t\t\t\text: 'ai',\n\t\t\t\tmime: 'application/postscript'\n\t\t\t};\n\t\t}\n\n\t\t// Assume this is just a normal PDF\n\t\treturn {\n\t\t\text: 'pdf',\n\t\t\tmime: 'application/pdf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x61, 0x73, 0x6D])) {\n\t\treturn {\n\t\t\text: 'wasm',\n\t\t\tmime: 'application/wasm'\n\t\t};\n\t}\n\n\t// TIFF, little-endian type\n\tif (check([0x49, 0x49, 0x2A, 0x0])) {\n\t\tif (checkString('CR', {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'cr2',\n\t\t\t\tmime: 'image/x-canon-cr2'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || check([0x1F, 0x00, 0x0B, 0x00], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'nef',\n\t\t\t\tmime: 'image/x-nikon-nef'\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcheck([0x08, 0x00, 0x00, 0x00], {offset: 4}) &&\n\t\t\t(check([0x2D, 0x00, 0xFE, 0x00], {offset: 8}) ||\n\t\t\t\tcheck([0x27, 0x00, 0xFE, 0x00], {offset: 8}))\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'dng',\n\t\t\t\tmime: 'image/x-adobe-dng'\n\t\t\t};\n\t\t}\n\n\t\tbuffer = Buffer.alloc(24);\n\t\tawait tokenizer.peekBuffer(buffer);\n\t\tif (\n\t\t\t(check([0x10, 0xFB, 0x86, 0x01], {offset: 4}) || check([0x08, 0x00, 0x00, 0x00], {offset: 4})) &&\n\t\t\t// This pattern differentiates ARW from other TIFF-ish file types:\n\t\t\tcheck([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {offset: 9})\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'arw',\n\t\t\t\tmime: 'image/x-sony-arw'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'tif',\n\t\t\tmime: 'image/tiff'\n\t\t};\n\t}\n\n\t// TIFF, big-endian type\n\tif (check([0x4D, 0x4D, 0x0, 0x2A])) {\n\t\treturn {\n\t\t\text: 'tif',\n\t\t\tmime: 'image/tiff'\n\t\t};\n\t}\n\n\tif (checkString('MAC ')) {\n\t\treturn {\n\t\t\text: 'ape',\n\t\t\tmime: 'audio/ape'\n\t\t};\n\t}\n\n\t// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska\n\tif (check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML\n\t\tasync function readField() {\n\t\t\tconst msb = await tokenizer.peekNumber(Token.UINT8);\n\t\t\tlet mask = 0x80;\n\t\t\tlet ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D\n\n\t\t\twhile ((msb & mask) === 0) {\n\t\t\t\t++ic;\n\t\t\t\tmask >>= 1;\n\t\t\t}\n\n\t\t\tconst id = Buffer.alloc(ic + 1);\n\t\t\tawait tokenizer.readBuffer(id);\n\t\t\treturn id;\n\t\t}\n\n\t\tasync function readElement() {\n\t\t\tconst id = await readField();\n\t\t\tconst lenField = await readField();\n\t\t\tlenField[0] ^= 0x80 >> (lenField.length - 1);\n\t\t\tconst nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n\t\t\treturn {\n\t\t\t\tid: id.readUIntBE(0, id.length),\n\t\t\t\tlen: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n\t\t\t};\n\t\t}\n\n\t\tasync function readChildren(level, children) {\n\t\t\twhile (children > 0) {\n\t\t\t\tconst e = await readElement();\n\t\t\t\tif (e.id === 0x4282) {\n\t\t\t\t\treturn tokenizer.readToken(new Token.StringType(e.len, 'utf-8')); // Return DocType\n\t\t\t\t}\n\n\t\t\t\tawait tokenizer.ignore(e.len); // ignore payload\n\t\t\t\t--children;\n\t\t\t}\n\t\t}\n\n\t\tconst re = await readElement();\n\t\tconst docType = await readChildren(1, re.len);\n\n\t\tswitch (docType) {\n\t\t\tcase 'webm':\n\t\t\t\treturn {\n\t\t\t\t\text: 'webm',\n\t\t\t\t\tmime: 'video/webm'\n\t\t\t\t};\n\n\t\t\tcase 'matroska':\n\t\t\t\treturn {\n\t\t\t\t\text: 'mkv',\n\t\t\t\t\tmime: 'video/x-matroska'\n\t\t\t\t};\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// RIFF file format which might be AVI, WAV, QCP, etc\n\tif (check([0x52, 0x49, 0x46, 0x46])) {\n\t\tif (check([0x41, 0x56, 0x49], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'avi',\n\t\t\t\tmime: 'video/vnd.avi'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'wav',\n\t\t\t\tmime: 'audio/vnd.wave'\n\t\t\t};\n\t\t}\n\n\t\t// QLCM, QCP file\n\t\tif (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'qcp',\n\t\t\t\tmime: 'audio/qcelp'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (checkString('SQLi')) {\n\t\treturn {\n\t\t\text: 'sqlite',\n\t\t\tmime: 'application/x-sqlite3'\n\t\t};\n\t}\n\n\tif (check([0x4E, 0x45, 0x53, 0x1A])) {\n\t\treturn {\n\t\t\text: 'nes',\n\t\t\tmime: 'application/x-nintendo-nes-rom'\n\t\t};\n\t}\n\n\tif (checkString('Cr24')) {\n\t\treturn {\n\t\t\text: 'crx',\n\t\t\tmime: 'application/x-google-chrome-extension'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('MSCF') ||\n\t\tcheckString('ISc(')\n\t) {\n\t\treturn {\n\t\t\text: 'cab',\n\t\t\tmime: 'application/vnd.ms-cab-compressed'\n\t\t};\n\t}\n\n\tif (check([0xED, 0xAB, 0xEE, 0xDB])) {\n\t\treturn {\n\t\t\text: 'rpm',\n\t\t\tmime: 'application/x-rpm'\n\t\t};\n\t}\n\n\tif (check([0xC5, 0xD0, 0xD3, 0xC6])) {\n\t\treturn {\n\t\t\text: 'eps',\n\t\t\tmime: 'application/eps'\n\t\t};\n\t}\n\n\t// -- 5-byte signatures --\n\n\tif (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {\n\t\treturn {\n\t\t\text: 'otf',\n\t\t\tmime: 'font/otf'\n\t\t};\n\t}\n\n\tif (checkString('#!AMR')) {\n\t\treturn {\n\t\t\text: 'amr',\n\t\t\tmime: 'audio/amr'\n\t\t};\n\t}\n\n\tif (checkString('{\\\\rtf')) {\n\t\treturn {\n\t\t\text: 'rtf',\n\t\t\tmime: 'application/rtf'\n\t\t};\n\t}\n\n\tif (check([0x46, 0x4C, 0x56, 0x01])) {\n\t\treturn {\n\t\t\text: 'flv',\n\t\t\tmime: 'video/x-flv'\n\t\t};\n\t}\n\n\tif (checkString('IMPM')) {\n\t\treturn {\n\t\t\text: 'it',\n\t\t\tmime: 'audio/x-it'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('-lh0-', {offset: 2}) ||\n\t\tcheckString('-lh1-', {offset: 2}) ||\n\t\tcheckString('-lh2-', {offset: 2}) ||\n\t\tcheckString('-lh3-', {offset: 2}) ||\n\t\tcheckString('-lh4-', {offset: 2}) ||\n\t\tcheckString('-lh5-', {offset: 2}) ||\n\t\tcheckString('-lh6-', {offset: 2}) ||\n\t\tcheckString('-lh7-', {offset: 2}) ||\n\t\tcheckString('-lzs-', {offset: 2}) ||\n\t\tcheckString('-lz4-', {offset: 2}) ||\n\t\tcheckString('-lz5-', {offset: 2}) ||\n\t\tcheckString('-lhd-', {offset: 2})\n\t) {\n\t\treturn {\n\t\t\text: 'lzh',\n\t\t\tmime: 'application/x-lzh-compressed'\n\t\t};\n\t}\n\n\t// MPEG program stream (PS or MPEG-PS)\n\tif (check([0x00, 0x00, 0x01, 0xBA])) {\n\t\t//  MPEG-PS, MPEG-1 Part 1\n\t\tif (check([0x21], {offset: 4, mask: [0xF1]})) {\n\t\t\treturn {\n\t\t\t\text: 'mpg', // May also be .ps, .mpeg\n\t\t\t\tmime: 'video/MP1S'\n\t\t\t};\n\t\t}\n\n\t\t// MPEG-PS, MPEG-2 Part 1\n\t\tif (check([0x44], {offset: 4, mask: [0xC4]})) {\n\t\t\treturn {\n\t\t\t\text: 'mpg', // May also be .mpg, .m2p, .vob or .sub\n\t\t\t\tmime: 'video/MP2P'\n\t\t\t};\n\t\t}\n\t}\n\n\t// -- 6-byte signatures --\n\n\tif (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {\n\t\treturn {\n\t\t\text: 'xz',\n\t\t\tmime: 'application/x-xz'\n\t\t};\n\t}\n\n\tif (checkString('<?xml ')) {\n\t\treturn {\n\t\t\text: 'xml',\n\t\t\tmime: 'application/xml'\n\t\t};\n\t}\n\n\tif (checkString('BEGIN:')) {\n\t\treturn {\n\t\t\text: 'ics',\n\t\t\tmime: 'text/calendar'\n\t\t};\n\t}\n\n\tif (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {\n\t\treturn {\n\t\t\text: '7z',\n\t\t\tmime: 'application/x-7z-compressed'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&\n\t\t(buffer[6] === 0x0 || buffer[6] === 0x1)\n\t) {\n\t\treturn {\n\t\t\text: 'rar',\n\t\t\tmime: 'application/x-rar-compressed'\n\t\t};\n\t}\n\n\t// -- 7-byte signatures --\n\n\tif (checkString('BLENDER')) {\n\t\treturn {\n\t\t\text: 'blend',\n\t\t\tmime: 'application/x-blender'\n\t\t};\n\t}\n\n\tif (checkString('!<arch>')) {\n\t\tawait tokenizer.ignore(8);\n\t\tconst str = await tokenizer.readToken(new Token.StringType(13, 'ascii'));\n\t\tif (str === 'debian-binary') {\n\t\t\treturn {\n\t\t\t\text: 'deb',\n\t\t\t\tmime: 'application/x-deb'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'ar',\n\t\t\tmime: 'application/x-unix-archive'\n\t\t};\n\t}\n\n\t// -- 8-byte signatures --\n\n\tif (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\t// APNG format (https://wiki.mozilla.org/APNG_Specification)\n\t\t// 1. Find the first IDAT (image data) chunk (49 44 41 54)\n\t\t// 2. Check if there is an \"acTL\" chunk before the IDAT one (61 63 54 4C)\n\n\t\t// Offset calculated as follows:\n\t\t// - 8 bytes: PNG signature\n\t\t// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk\n\n\t\tawait tokenizer.ignore(8); // ignore PNG signature\n\n\t\tasync function readChunkHeader() {\n\t\t\treturn {\n\t\t\t\tlength: await tokenizer.readToken(Token.INT32_BE),\n\t\t\t\ttype: await tokenizer.readToken(new Token.StringType(4, 'binary'))\n\t\t\t};\n\t\t}\n\n\t\tdo {\n\t\t\tconst chunk = await readChunkHeader();\n\t\t\tswitch (chunk.type) {\n\t\t\t\tcase 'IDAT':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'png',\n\t\t\t\t\t\tmime: 'image/png'\n\t\t\t\t\t};\n\t\t\t\tcase 'acTL':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'apng',\n\t\t\t\t\t\tmime: 'image/apng'\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\tawait tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC\n\t\t\t}\n\t\t} while (tokenizer.position < tokenizer.fileInfo.size);\n\n\t\treturn {\n\t\t\text: 'png',\n\t\t\tmime: 'image/png'\n\t\t};\n\t}\n\n\tif (check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'arrow',\n\t\t\tmime: 'application/x-apache-arrow'\n\t\t};\n\t}\n\n\tif (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'glb',\n\t\t\tmime: 'model/gltf-binary'\n\t\t};\n\t}\n\n\t// `mov` format variants\n\tif (\n\t\tcheck([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // `free`\n\t\tcheck([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // `mdat` MJPEG\n\t\tcheck([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // `moov`\n\t\tcheck([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`\n\t) {\n\t\treturn {\n\t\t\text: 'mov',\n\t\t\tmime: 'video/quicktime'\n\t\t};\n\t}\n\n\t// -- 9-byte signatures --\n\n\tif (check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {\n\t\treturn {\n\t\t\text: 'orf',\n\t\t\tmime: 'image/x-olympus-orf'\n\t\t};\n\t}\n\n\t// -- 12-byte signatures --\n\n\tif (check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {\n\t\treturn {\n\t\t\text: 'rw2',\n\t\t\tmime: 'image/x-panasonic-rw2'\n\t\t};\n\t}\n\n\t// ASF_Header_Object first 80 bytes\n\tif (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {\n\t\tasync function readHeader() {\n\t\t\tconst guid = Buffer.alloc(16);\n\t\t\tawait tokenizer.readBuffer(guid);\n\t\t\treturn {\n\t\t\t\tid: guid,\n\t\t\t\tsize: await tokenizer.readToken(Token.UINT64_LE)\n\t\t\t};\n\t\t}\n\n\t\tawait tokenizer.ignore(30);\n\t\t// Search for header should be in first 1KB of file.\n\t\twhile (tokenizer.position + 24 < tokenizer.fileInfo.size) {\n\t\t\tconst header = await readHeader();\n\t\t\tlet payload = header.size - 24;\n\t\t\tif (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {\n\t\t\t\t// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)\n\t\t\t\tconst typeId = Buffer.alloc(16);\n\t\t\t\tpayload -= await tokenizer.readBuffer(typeId);\n\n\t\t\t\tif (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t// Found audio:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'wma',\n\t\t\t\t\t\tmime: 'audio/x-ms-wma'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t// Found video:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'wmv',\n\t\t\t\t\t\tmime: 'video/x-ms-asf'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait tokenizer.ignore(payload);\n\t\t}\n\n\t\t// Default to ASF generic extension\n\t\treturn {\n\t\t\text: 'asf',\n\t\t\tmime: 'application/vnd.ms-asf'\n\t\t};\n\t}\n\n\tif (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\treturn {\n\t\t\text: 'ktx',\n\t\t\tmime: 'image/ktx'\n\t\t};\n\t}\n\n\tif ((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {\n\t\treturn {\n\t\t\text: 'mie',\n\t\t\tmime: 'application/x-mie'\n\t\t};\n\t}\n\n\tif (check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {\n\t\treturn {\n\t\t\text: 'shp',\n\t\t\tmime: 'application/x-esri-shape'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {\n\t\t// JPEG-2000 family\n\n\t\tawait tokenizer.ignore(20);\n\t\tconst type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));\n\t\tswitch (type) {\n\t\t\tcase 'jp2 ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jp2',\n\t\t\t\t\tmime: 'image/jp2'\n\t\t\t\t};\n\t\t\tcase 'jpx ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jpx',\n\t\t\t\t\tmime: 'image/jpx'\n\t\t\t\t};\n\t\t\tcase 'jpm ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jpm',\n\t\t\t\t\tmime: 'image/jpm'\n\t\t\t\t};\n\t\t\tcase 'mjp2':\n\t\t\t\treturn {\n\t\t\t\t\text: 'mj2',\n\t\t\t\t\tmime: 'image/mj2'\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// -- Unsafe signatures --\n\n\tif (\n\t\tcheck([0x0, 0x0, 0x1, 0xBA]) ||\n\t\tcheck([0x0, 0x0, 0x1, 0xB3])\n\t) {\n\t\treturn {\n\t\t\text: 'mpg',\n\t\t\tmime: 'video/mpeg'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x01, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'ttf',\n\t\t\tmime: 'font/ttf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x01, 0x00])) {\n\t\treturn {\n\t\t\text: 'ico',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x02, 0x00])) {\n\t\treturn {\n\t\t\text: 'cur',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {\n\t\t// Detected Microsoft Compound File Binary File (MS-CFB) Format.\n\t\treturn {\n\t\t\text: 'cfb',\n\t\t\tmime: 'application/x-cfb'\n\t\t};\n\t}\n\n\t// Increase sample size from 12 to 256.\n\tawait tokenizer.peekBuffer(buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t// `raf` is here just to keep all the raw image detectors together.\n\tif (checkString('FUJIFILMCCD-RAW')) {\n\t\treturn {\n\t\t\text: 'raf',\n\t\t\tmime: 'image/x-fujifilm-raf'\n\t\t};\n\t}\n\n\tif (checkString('Extended Module:')) {\n\t\treturn {\n\t\t\text: 'xm',\n\t\t\tmime: 'audio/x-xm'\n\t\t};\n\t}\n\n\tif (checkString('Creative Voice File')) {\n\t\treturn {\n\t\t\text: 'voc',\n\t\t\tmime: 'audio/x-voc'\n\t\t};\n\t}\n\n\tif (check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16) { // Rough & quick check Pickle/ASAR\n\t\tconst jsonSize = buffer.readUInt32LE(12);\n\t\tif (jsonSize > 12 && jsonSize < 240 && buffer.length >= jsonSize + 16) {\n\t\t\ttry {\n\t\t\t\tconst header = buffer.slice(16, jsonSize + 16).toString();\n\t\t\t\tconst json = JSON.parse(header);\n\t\t\t\t// Check if Pickle is ASAR\n\t\t\t\tif (json.files) { // Final check, assuring Pickle/ASAR format\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'asar',\n\t\t\t\t\t\tmime: 'application/x-asar'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t}\n\t\t}\n\t}\n\n\tif (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {\n\t\treturn {\n\t\t\text: 'mxf',\n\t\t\tmime: 'application/mxf'\n\t\t};\n\t}\n\n\tif (checkString('SCRM', {offset: 44})) {\n\t\treturn {\n\t\t\text: 's3m',\n\t\t\tmime: 'audio/x-s3m'\n\t\t};\n\t}\n\n\tif (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {\n\t\treturn {\n\t\t\text: 'mts',\n\t\t\tmime: 'video/mp2t'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {\n\t\treturn {\n\t\t\text: 'mobi',\n\t\t\tmime: 'application/x-mobipocket-ebook'\n\t\t};\n\t}\n\n\tif (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {\n\t\treturn {\n\t\t\text: 'dcm',\n\t\t\tmime: 'application/dicom'\n\t\t};\n\t}\n\n\tif (check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {\n\t\treturn {\n\t\t\text: 'lnk',\n\t\t\tmime: 'application/x.ms.shortcut' // Invented by us\n\t\t};\n\t}\n\n\tif (check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'alias',\n\t\t\tmime: 'application/x.apple.alias' // Invented by us\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x4C, 0x50], {offset: 34}) &&\n\t\t(\n\t\t\tcheck([0x00, 0x00, 0x01], {offset: 8}) ||\n\t\t\tcheck([0x01, 0x00, 0x02], {offset: 8}) ||\n\t\t\tcheck([0x02, 0x00, 0x02], {offset: 8})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'eot',\n\t\t\tmime: 'application/vnd.ms-fontobject'\n\t\t};\n\t}\n\n\tif (check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {\n\t\treturn {\n\t\t\text: 'indd',\n\t\t\tmime: 'application/x-indesign'\n\t\t};\n\t}\n\n\t// Increase sample size from 256 to 512\n\tawait tokenizer.peekBuffer(buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t// Requires a buffer size of 512 bytes\n\tif (tarHeaderChecksumMatches(buffer)) {\n\t\treturn {\n\t\t\text: 'tar',\n\t\t\tmime: 'application/x-tar'\n\t\t};\n\t}\n\n\tif (check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {\n\t\treturn {\n\t\t\text: 'skp',\n\t\t\tmime: 'application/vnd.sketchup.skp'\n\t\t};\n\t}\n\n\tif (checkString('-----BEGIN PGP MESSAGE-----')) {\n\t\treturn {\n\t\t\text: 'pgp',\n\t\t\tmime: 'application/pgp-encrypted'\n\t\t};\n\t}\n\n\t// Check for MPEG header at different starting offsets\n\tfor (let start = 0; start < 2 && start < (buffer.length - 16); start++) {\n\t\t// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)\n\t\tif (buffer.length >= start + 2 && check([0xFF, 0xE0], {offset: start, mask: [0xFF, 0xE0]})) {\n\t\t\tif (check([0x10], {offset: start + 1, mask: [0x16]})) {\n\t\t\t\t// Check for (ADTS) MPEG-2\n\t\t\t\tif (check([0x08], {offset: start + 1, mask: [0x08]})) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'aac',\n\t\t\t\t\t\tmime: 'audio/aac'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Must be (ADTS) MPEG-4\n\t\t\t\treturn {\n\t\t\t\t\text: 'aac',\n\t\t\t\t\tmime: 'audio/aac'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// MPEG 1 or 2 Layer 3 header\n\t\t\t// Check for MPEG layer 3\n\t\t\tif (check([0x02], {offset: start + 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp3',\n\t\t\t\t\tmime: 'audio/mpeg'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check for MPEG layer 2\n\t\t\tif (check([0x04], {offset: start + 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp2',\n\t\t\t\t\tmime: 'audio/mpeg'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check for MPEG layer 1\n\t\t\tif (check([0x06], {offset: start + 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp1',\n\t\t\t\t\tmime: 'audio/mpeg'\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst stream = readableStream => new Promise((resolve, reject) => {\n\t// Using `eval` to work around issues when bundling with Webpack\n\tconst stream = eval('require')('stream'); // eslint-disable-line no-eval\n\n\treadableStream.on('error', reject);\n\treadableStream.once('readable', async () => {\n\t\t// Set up output stream\n\t\tconst pass = new stream.PassThrough();\n\t\tlet outputStream;\n\t\tif (stream.pipeline) {\n\t\t\toutputStream = stream.pipeline(readableStream, pass, () => {\n\t\t\t});\n\t\t} else {\n\t\t\toutputStream = readableStream.pipe(pass);\n\t\t}\n\n\t\t// Read the input stream and detect the filetype\n\t\tconst chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);\n\t\ttry {\n\t\t\tconst fileType = await fromBuffer(chunk);\n\t\t\tpass.fileType = fileType;\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\n\t\tresolve(outputStream);\n\t});\n});\n\nconst fileType = {\n\tfromStream,\n\tfromTokenizer,\n\tfromBuffer,\n\tstream\n};\n\nObject.defineProperty(fileType, 'extensions', {\n\tget() {\n\t\treturn new Set(supported.extensions);\n\t}\n});\n\nObject.defineProperty(fileType, 'mimeTypes', {\n\tget() {\n\t\treturn new Set(supported.mimeTypes);\n\t}\n});\n\nmodule.exports = fileType;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2ZpbGUtdHlwZS9jb3JlLmpzPzMxYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsNERBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsNEVBQVE7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWE7O0FBRXZDLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4SEFBOEgsYUFBYTtBQUMzSTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxnQkFBZ0I7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxtQ0FBbUM7O0FBRXhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyw0QkFBNEI7O0FBRWxFLGdDQUFnQyxVQUFVO0FBQzFDLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxXQUFXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGdCQUFnQjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLGFBQWE7QUFDYjs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsVUFBVSxzQ0FBc0MsVUFBVTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMscUNBQXFDLFVBQVU7QUFDL0MscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVLHNDQUFzQyxVQUFVO0FBQy9GO0FBQ0Esc0dBQXNHLFVBQVU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQyx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtHQUFrRyxVQUFVO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGLFVBQVU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsZ0VBQWdFOztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFVBQVUscUJBQXFCLFlBQVksb0JBQW9CLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGdFQUFnRTs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQSx5REFBeUQsa0NBQWtDO0FBQzNGLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2ZpbGUtdHlwZS9jb3JlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKCd0b2tlbi10eXBlcycpO1xuY29uc3Qgc3RydG9rMyA9IHJlcXVpcmUoJ3N0cnRvazMvbGliL2NvcmUnKTtcbmNvbnN0IHtcblx0c3RyaW5nVG9CeXRlcyxcblx0dGFySGVhZGVyQ2hlY2tzdW1NYXRjaGVzLFxuXHR1aW50MzJTeW5jU2FmZVRva2VuXG59ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBzdXBwb3J0ZWQgPSByZXF1aXJlKCcuL3N1cHBvcnRlZCcpO1xuXG5jb25zdCBtaW5pbXVtQnl0ZXMgPSA0MTAwOyAvLyBBIGZhaXIgYW1vdW50IG9mIGZpbGUtdHlwZXMgYXJlIGRldGVjdGFibGUgd2l0aGluIHRoaXMgcmFuZ2VcblxuYXN5bmMgZnVuY3Rpb24gZnJvbVN0cmVhbShzdHJlYW0pIHtcblx0Y29uc3QgdG9rZW5pemVyID0gYXdhaXQgc3RydG9rMy5mcm9tU3RyZWFtKHN0cmVhbSk7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGF3YWl0IGZyb21Ub2tlbml6ZXIodG9rZW5pemVyKTtcblx0fSBmaW5hbGx5IHtcblx0XHRhd2FpdCB0b2tlbml6ZXIuY2xvc2UoKTtcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBmcm9tQnVmZmVyKGlucHV0KSB7XG5cdGlmICghKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIFxcYGlucHV0XFxgIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgXFxgVWludDhBcnJheVxcYCBvciBcXGBCdWZmZXJcXGAgb3IgXFxgQXJyYXlCdWZmZXJcXGAsIGdvdCBcXGAke3R5cGVvZiBpbnB1dH1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGJ1ZmZlciA9IGlucHV0IGluc3RhbmNlb2YgQnVmZmVyID8gaW5wdXQgOiBCdWZmZXIuZnJvbShpbnB1dCk7XG5cblx0aWYgKCEoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggPiAxKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRva2VuaXplciA9IHN0cnRvazMuZnJvbUJ1ZmZlcihidWZmZXIpO1xuXHRyZXR1cm4gZnJvbVRva2VuaXplcih0b2tlbml6ZXIpO1xufVxuXG5mdW5jdGlvbiBfY2hlY2soYnVmZmVyLCBoZWFkZXJzLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0b2Zmc2V0OiAwLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRmb3IgKGNvbnN0IFtpbmRleCwgaGVhZGVyXSBvZiBoZWFkZXJzLmVudHJpZXMoKSkge1xuXHRcdC8vIElmIGEgYml0bWFzayBpcyBzZXRcblx0XHRpZiAob3B0aW9ucy5tYXNrKSB7XG5cdFx0XHQvLyBJZiBoZWFkZXIgZG9lc24ndCBlcXVhbCBgYnVmYCB3aXRoIGJpdHMgbWFza2VkIG9mZlxuXHRcdFx0aWYgKGhlYWRlciAhPT0gKG9wdGlvbnMubWFza1tpbmRleF0gJiBidWZmZXJbaW5kZXggKyBvcHRpb25zLm9mZnNldF0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlYWRlciAhPT0gYnVmZmVyW2luZGV4ICsgb3B0aW9ucy5vZmZzZXRdKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9jaGVja1NlcXVlbmNlKHNlcXVlbmNlLCB0b2tlbml6ZXIsIGlnbm9yZUJ5dGVzKSB7XG5cdGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhtaW5pbXVtQnl0ZXMpO1xuXHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKGlnbm9yZUJ5dGVzKTtcblxuXHRhd2FpdCB0b2tlbml6ZXIucGVla0J1ZmZlcihidWZmZXIsIHttYXlCZUxlc3M6IHRydWV9KTtcblxuXHRyZXR1cm4gYnVmZmVyLmluY2x1ZGVzKEJ1ZmZlci5mcm9tKHNlcXVlbmNlKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZyb21Ub2tlbml6ZXIodG9rZW5pemVyKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIF9mcm9tVG9rZW5pemVyKHRva2VuaXplcik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBzdHJ0b2szLkVuZE9mU3RyZWFtRXJyb3IpKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX2Zyb21Ub2tlbml6ZXIodG9rZW5pemVyKSB7XG5cdGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MobWluaW11bUJ5dGVzKTtcblx0Y29uc3QgYnl0ZXNSZWFkID0gMTI7XG5cdGNvbnN0IGNoZWNrID0gKGhlYWRlciwgb3B0aW9ucykgPT4gX2NoZWNrKGJ1ZmZlciwgaGVhZGVyLCBvcHRpb25zKTtcblx0Y29uc3QgY2hlY2tTdHJpbmcgPSAoaGVhZGVyLCBvcHRpb25zKSA9PiBjaGVjayhzdHJpbmdUb0J5dGVzKGhlYWRlciksIG9wdGlvbnMpO1xuXHRjb25zdCBjaGVja1NlcXVlbmNlID0gKHNlcXVlbmNlLCBpZ25vcmVCeXRlcykgPT4gX2NoZWNrU2VxdWVuY2Uoc2VxdWVuY2UsIHRva2VuaXplciwgaWdub3JlQnl0ZXMpO1xuXG5cdC8vIEtlZXAgcmVhZGluZyB1bnRpbCBFT0YgaWYgdGhlIGZpbGUgc2l6ZSBpcyB1bmtub3duLlxuXHRpZiAoIXRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG5cdFx0dG9rZW5pemVyLmZpbGVJbmZvLnNpemUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblx0fVxuXG5cdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge2xlbmd0aDogYnl0ZXNSZWFkLCBtYXlCZUxlc3M6IHRydWV9KTtcblxuXHQvLyAtLSAyLWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHg0MiwgMHg0RF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2JtcCcsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvYm1wJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MEIsIDB4NzddKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhYzMnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL3ZuZC5kb2xieS5kZC1yYXcnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg3OCwgMHgwMV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2RtZycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1hcHBsZS1kaXNraW1hZ2UnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RCwgMHg1QV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2V4ZScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MjUsIDB4MjFdKSkge1xuXHRcdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge2xlbmd0aDogMjQsIG1heUJlTGVzczogdHJ1ZX0pO1xuXG5cdFx0aWYgKGNoZWNrU3RyaW5nKCdQUy1BZG9iZS0nLCB7b2Zmc2V0OiAyfSkgJiZcblx0XHRcdGNoZWNrU3RyaW5nKCcgRVBTRi0nLCB7b2Zmc2V0OiAxNH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdlcHMnLFxuXHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZXBzJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncHMnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVjayhbMHgxRiwgMHhBMF0pIHx8XG5cdFx0Y2hlY2soWzB4MUYsIDB4OURdKVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnWicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1jb21wcmVzcydcblx0XHR9O1xuXHR9XG5cblx0Ly8gLS0gMy1ieXRlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoY2hlY2soWzB4RkYsIDB4RDgsIDB4RkZdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdqcGcnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2pwZWcnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0OSwgMHg0OSwgMHhCQ10pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2p4cicsXG5cdFx0XHRtaW1lOiAnaW1hZ2Uvdm5kLm1zLXBob3RvJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MUYsIDB4OEIsIDB4OF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2d6Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9nemlwJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDIsIDB4NUEsIDB4NjhdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdiejInLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtYnppcDInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnSUQzJykpIHtcblx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDYpOyAvLyBTa2lwIElEMyBoZWFkZXIgdW50aWwgdGhlIGhlYWRlciBzaXplXG5cdFx0Y29uc3QgaWQzSGVhZGVyTGVuID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbih1aW50MzJTeW5jU2FmZVRva2VuKTtcblx0XHRpZiAodG9rZW5pemVyLnBvc2l0aW9uICsgaWQzSGVhZGVyTGVuID4gdG9rZW5pemVyLmZpbGVJbmZvLnNpemUpIHtcblx0XHRcdC8vIEd1ZXNzIGZpbGUgdHlwZSBiYXNlZCBvbiBJRDMgaGVhZGVyIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcDMnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShpZDNIZWFkZXJMZW4pO1xuXHRcdHJldHVybiBmcm9tVG9rZW5pemVyKHRva2VuaXplcik7IC8vIFNraXAgSUQzIGhlYWRlciwgcmVjdXJzaW9uXG5cdH1cblxuXHQvLyBNdXNlcGFjaywgU1Y3XG5cdGlmIChjaGVja1N0cmluZygnTVArJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbXBjJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LW11c2VwYWNrJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0KGJ1ZmZlclswXSA9PT0gMHg0MyB8fCBidWZmZXJbMF0gPT09IDB4NDYpICYmXG5cdFx0Y2hlY2soWzB4NTcsIDB4NTNdLCB7b2Zmc2V0OiAxfSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3N3ZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXG5cdFx0fTtcblx0fVxuXG5cdC8vIC0tIDQtYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweDQ3LCAweDQ5LCAweDQ2XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnZ2lmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9naWYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnRkxJRicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ZsaWYnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2ZsaWYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnOEJQUycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BzZCcsXG5cdFx0XHRtaW1lOiAnaW1hZ2Uvdm5kLmFkb2JlLnBob3Rvc2hvcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdXRUJQJywge29mZnNldDogOH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3dlYnAnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3dlYnAnXG5cdFx0fTtcblx0fVxuXG5cdC8vIE11c2VwYWNrLCBTVjhcblx0aWYgKGNoZWNrU3RyaW5nKCdNUENLJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbXBjJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LW11c2VwYWNrJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0ZPUk0nKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhaWYnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL2FpZmYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnaWNucycsIHtvZmZzZXQ6IDB9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdpY25zJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9pY25zJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBaaXAtYmFzZWQgZmlsZSBmb3JtYXRzXG5cdC8vIE5lZWQgdG8gYmUgYmVmb3JlIHRoZSBgemlwYCBjaGVja1xuXHRpZiAoY2hlY2soWzB4NTAsIDB4NEIsIDB4MywgMHg0XSkpIHsgLy8gTG9jYWwgZmlsZSBoZWFkZXIgc2lnbmF0dXJlXG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlICh0b2tlbml6ZXIucG9zaXRpb24gKyAzMCA8IHRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG5cdFx0XHRcdGF3YWl0IHRva2VuaXplci5yZWFkQnVmZmVyKGJ1ZmZlciwge2xlbmd0aDogMzB9KTtcblxuXHRcdFx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9aaXBfKGZpbGVfZm9ybWF0KSNGaWxlX2hlYWRlcnNcblx0XHRcdFx0Y29uc3QgemlwSGVhZGVyID0ge1xuXHRcdFx0XHRcdGNvbXByZXNzZWRTaXplOiBidWZmZXIucmVhZFVJbnQzMkxFKDE4KSxcblx0XHRcdFx0XHR1bmNvbXByZXNzZWRTaXplOiBidWZmZXIucmVhZFVJbnQzMkxFKDIyKSxcblx0XHRcdFx0XHRmaWxlbmFtZUxlbmd0aDogYnVmZmVyLnJlYWRVSW50MTZMRSgyNiksXG5cdFx0XHRcdFx0ZXh0cmFGaWVsZExlbmd0aDogYnVmZmVyLnJlYWRVSW50MTZMRSgyOClcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR6aXBIZWFkZXIuZmlsZW5hbWUgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKHppcEhlYWRlci5maWxlbmFtZUxlbmd0aCwgJ3V0Zi04JykpO1xuXHRcdFx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKHppcEhlYWRlci5leHRyYUZpZWxkTGVuZ3RoKTtcblxuXHRcdFx0XHQvLyBBc3N1bWVzIHNpZ25lZCBgLnhwaWAgZnJvbSBhZGRvbnMubW96aWxsYS5vcmdcblx0XHRcdFx0aWYgKHppcEhlYWRlci5maWxlbmFtZSA9PT0gJ01FVEEtSU5GL21vemlsbGEucnNhJykge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICd4cGknLFxuXHRcdFx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoemlwSGVhZGVyLmZpbGVuYW1lLmVuZHNXaXRoKCcucmVscycpIHx8IHppcEhlYWRlci5maWxlbmFtZS5lbmRzV2l0aCgnLnhtbCcpKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IHppcEhlYWRlci5maWxlbmFtZS5zcGxpdCgnLycpWzBdO1xuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnX3JlbHMnOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3dvcmQnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGV4dDogJ2RvY3gnLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNhc2UgJ3BwdCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAncHB0eCcsXG5cdFx0XHRcdFx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRjYXNlICd4bCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAneGxzeCcsXG5cdFx0XHRcdFx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0J1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHppcEhlYWRlci5maWxlbmFtZS5zdGFydHNXaXRoKCd4bC8nKSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICd4bHN4Jyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIGRvY3gsIHhsc3ggYW5kIHBwdHggZmlsZSB0eXBlcyBleHRlbmQgdGhlIE9mZmljZSBPcGVuIFhNTCBmaWxlIGZvcm1hdDpcblx0XHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2ZmaWNlX09wZW5fWE1MX2ZpbGVfZm9ybWF0c1xuXHRcdFx0XHQvLyBXZSBsb29rIGZvcjpcblx0XHRcdFx0Ly8gLSBvbmUgZW50cnkgbmFtZWQgJ1tDb250ZW50X1R5cGVzXS54bWwnIG9yICdfcmVscy8ucmVscycsXG5cdFx0XHRcdC8vIC0gb25lIGVudHJ5IGluZGljYXRpbmcgc3BlY2lmaWMgdHlwZSBvZiBmaWxlLlxuXHRcdFx0XHQvLyBNUyBPZmZpY2UsIE9wZW5PZmZpY2UgYW5kIExpYnJlT2ZmaWNlIG1heSBwdXQgdGhlIHBhcnRzIGluIGRpZmZlcmVudCBvcmRlciwgc28gdGhlIGNoZWNrIHNob3VsZCBub3QgcmVseSBvbiBpdC5cblx0XHRcdFx0aWYgKHppcEhlYWRlci5maWxlbmFtZSA9PT0gJ21pbWV0eXBlJyAmJiB6aXBIZWFkZXIuY29tcHJlc3NlZFNpemUgPT09IHppcEhlYWRlci51bmNvbXByZXNzZWRTaXplKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWltZVR5cGUgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSwgJ3V0Zi04JykpO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChtaW1lVHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXBwbGljYXRpb24vZXB1Yit6aXAnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGV4dDogJ2VwdWInLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNhc2UgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAnb2R0Jyxcblx0XHRcdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0J1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAnb2RzJyxcblx0XHRcdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNhc2UgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRleHQ6ICdvZHAnLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbidcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgbmV4dCBoZWFkZXIgbWFudWFsbHkgd2hlbiBjdXJyZW50IG9uZSBpcyBjb3JydXB0ZWRcblx0XHRcdFx0aWYgKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSA9PT0gMCkge1xuXHRcdFx0XHRcdGxldCBuZXh0SGVhZGVySW5kZXggPSAtMTtcblxuXHRcdFx0XHRcdHdoaWxlIChuZXh0SGVhZGVySW5kZXggPCAwICYmICh0b2tlbml6ZXIucG9zaXRpb24gPCB0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge21heUJlTGVzczogdHJ1ZX0pO1xuXG5cdFx0XHRcdFx0XHRuZXh0SGVhZGVySW5kZXggPSBidWZmZXIuaW5kZXhPZignNTA0QjAzMDQnLCAwLCAnaGV4Jyk7XG5cdFx0XHRcdFx0XHQvLyBNb3ZlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGhlYWRlciBpZiBmb3VuZCwgc2tpcCB0aGUgd2hvbGUgYnVmZmVyIG90aGVyd2lzZVxuXHRcdFx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShuZXh0SGVhZGVySW5kZXggPj0gMCA/IG5leHRIZWFkZXJJbmRleCA6IGJ1ZmZlci5sZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBzdHJ0b2szLkVuZE9mU3RyZWFtRXJyb3IpKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd6aXAnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ppcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdPZ2dTJykpIHtcblx0XHQvLyBUaGlzIGlzIGFuIE9HRyBjb250YWluZXJcblx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDI4KTtcblx0XHRjb25zdCB0eXBlID0gQnVmZmVyLmFsbG9jKDgpO1xuXHRcdGF3YWl0IHRva2VuaXplci5yZWFkQnVmZmVyKHR5cGUpO1xuXG5cdFx0Ly8gTmVlZHMgdG8gYmUgYmVmb3JlIGBvZ2dgIGNoZWNrXG5cdFx0aWYgKF9jaGVjayh0eXBlLCBbMHg0RiwgMHg3MCwgMHg3NSwgMHg3MywgMHg0OCwgMHg2NSwgMHg2MSwgMHg2NF0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvcHVzJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29wdXMnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmICcgdGhlb3JhJyBpbiBoZWFkZXIuXG5cdFx0aWYgKF9jaGVjayh0eXBlLCBbMHg4MCwgMHg3NCwgMHg2OCwgMHg2NSwgMHg2RiwgMHg3MiwgMHg2MV0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvZ3YnLFxuXHRcdFx0XHRtaW1lOiAndmlkZW8vb2dnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiAnXFx4MDF2aWRlbycgaW4gaGVhZGVyLlxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4MDEsIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NkYsIDB4MDBdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2dtJyxcblx0XHRcdFx0bWltZTogJ3ZpZGVvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgJyBGTEFDJyBpbiBoZWFkZXIgIGh0dHBzOi8veGlwaC5vcmcvZmxhYy9mYXEuaHRtbFxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4N0YsIDB4NDYsIDB4NEMsIDB4NDEsIDB4NDNdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2dhJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gJ1NwZWV4ICAnIGluIGhlYWRlciBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGVleFxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4NTMsIDB4NzAsIDB4NjUsIDB4NjUsIDB4NzgsIDB4MjAsIDB4MjBdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnc3B4Jyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgJ1xceDAxdm9yYmlzJyBpbiBoZWFkZXJcblx0XHRpZiAoX2NoZWNrKHR5cGUsIFsweDAxLCAweDc2LCAweDZGLCAweDcyLCAweDYyLCAweDY5LCAweDczXSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ29nZycsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9vZ2cnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgT0dHIGNvbnRhaW5lciBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9hcHBsaWNhdGlvbi9vZ2dcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnb2d4Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9vZ2cnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVjayhbMHg1MCwgMHg0Ql0pICYmXG5cdFx0KGJ1ZmZlclsyXSA9PT0gMHgzIHx8IGJ1ZmZlclsyXSA9PT0gMHg1IHx8IGJ1ZmZlclsyXSA9PT0gMHg3KSAmJlxuXHRcdChidWZmZXJbM10gPT09IDB4NCB8fCBidWZmZXJbM10gPT09IDB4NiB8fCBidWZmZXJbM10gPT09IDB4OClcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3ppcCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vemlwJ1xuXHRcdH07XG5cdH1cblxuXHQvL1xuXG5cdC8vIEZpbGUgVHlwZSBCb3ggKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT19iYXNlX21lZGlhX2ZpbGVfZm9ybWF0KVxuXHQvLyBJdCdzIG5vdCByZXF1aXJlZCB0byBiZSBmaXJzdCwgYnV0IGl0J3MgcmVjb21tZW5kZWQgdG8gYmUuIEFsbW9zdCBhbGwgSVNPIGJhc2UgbWVkaWEgZmlsZXMgc3RhcnQgd2l0aCBgZnR5cGAgYm94LlxuXHQvLyBgZnR5cGAgYm94IG11c3QgY29udGFpbiBhIGJyYW5kIG1ham9yIGlkZW50aWZpZXIsIHdoaWNoIG11c3QgY29uc2lzdCBvZiBJU08gODg1OS0xIHByaW50YWJsZSBjaGFyYWN0ZXJzLlxuXHQvLyBIZXJlIHdlIGNoZWNrIGZvciA4ODU5LTEgcHJpbnRhYmxlIGNoYXJhY3RlcnMgKGZvciBzaW1wbGljaXR5LCBpdCdzIGEgbWFzayB3aGljaCBhbHNvIGNhdGNoZXMgb25lIG5vbi1wcmludGFibGUgY2hhcmFjdGVyKS5cblx0aWYgKFxuXHRcdGNoZWNrU3RyaW5nKCdmdHlwJywge29mZnNldDogNH0pICYmXG5cdFx0KGJ1ZmZlcls4XSAmIDB4NjApICE9PSAweDAwIC8vIEJyYW5kIG1ham9yLCBmaXJzdCBjaGFyYWN0ZXIgQVNDSUk/XG5cdCkge1xuXHRcdC8vIFRoZXkgYWxsIGNhbiBoYXZlIE1JTUUgYHZpZGVvL21wNGAgZXhjZXB0IGBhcHBsaWNhdGlvbi9tcDRgIHNwZWNpYWwtY2FzZSB3aGljaCBpcyBoYXJkIHRvIGRldGVjdC5cblx0XHQvLyBGb3Igc29tZSBjYXNlcywgd2UncmUgc3BlY2lmaWMsIGV2ZXJ5dGhpbmcgZWxzZSBmYWxscyB0byBgdmlkZW8vbXA0YCB3aXRoIGBtcDRgIGV4dGVuc2lvbi5cblx0XHRjb25zdCBicmFuZE1ham9yID0gYnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknLCA4LCAxMikucmVwbGFjZSgnXFwwJywgJyAnKS50cmltKCk7XG5cdFx0c3dpdGNoIChicmFuZE1ham9yKSB7XG5cdFx0XHRjYXNlICdhdmlmJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdhdmlmJywgbWltZTogJ2ltYWdlL2F2aWYnfTtcblx0XHRcdGNhc2UgJ21pZjEnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2hlaWMnLCBtaW1lOiAnaW1hZ2UvaGVpZid9O1xuXHRcdFx0Y2FzZSAnbXNmMSc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnaGVpYycsIG1pbWU6ICdpbWFnZS9oZWlmLXNlcXVlbmNlJ307XG5cdFx0XHRjYXNlICdoZWljJzpcblx0XHRcdGNhc2UgJ2hlaXgnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2hlaWMnLCBtaW1lOiAnaW1hZ2UvaGVpYyd9O1xuXHRcdFx0Y2FzZSAnaGV2Yyc6XG5cdFx0XHRjYXNlICdoZXZ4Jzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdoZWljJywgbWltZTogJ2ltYWdlL2hlaWMtc2VxdWVuY2UnfTtcblx0XHRcdGNhc2UgJ3F0Jzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtb3YnLCBtaW1lOiAndmlkZW8vcXVpY2t0aW1lJ307XG5cdFx0XHRjYXNlICdNNFYnOlxuXHRcdFx0Y2FzZSAnTTRWSCc6XG5cdFx0XHRjYXNlICdNNFZQJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtNHYnLCBtaW1lOiAndmlkZW8veC1tNHYnfTtcblx0XHRcdGNhc2UgJ000UCc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnbTRwJywgbWltZTogJ3ZpZGVvL21wNCd9O1xuXHRcdFx0Y2FzZSAnTTRCJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtNGInLCBtaW1lOiAnYXVkaW8vbXA0J307XG5cdFx0XHRjYXNlICdNNEEnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ200YScsIG1pbWU6ICdhdWRpby94LW00YSd9O1xuXHRcdFx0Y2FzZSAnRjRWJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdmNHYnLCBtaW1lOiAndmlkZW8vbXA0J307XG5cdFx0XHRjYXNlICdGNFAnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2Y0cCcsIG1pbWU6ICd2aWRlby9tcDQnfTtcblx0XHRcdGNhc2UgJ0Y0QSc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnZjRhJywgbWltZTogJ2F1ZGlvL21wNCd9O1xuXHRcdFx0Y2FzZSAnRjRCJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdmNGInLCBtaW1lOiAnYXVkaW8vbXA0J307XG5cdFx0XHRjYXNlICdjcngnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2NyMycsIG1pbWU6ICdpbWFnZS94LWNhbm9uLWNyMyd9O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aWYgKGJyYW5kTWFqb3Iuc3RhcnRzV2l0aCgnM2cnKSkge1xuXHRcdFx0XHRcdGlmIChicmFuZE1ham9yLnN0YXJ0c1dpdGgoJzNnMicpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge2V4dDogJzNnMicsIG1pbWU6ICd2aWRlby8zZ3BwMid9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB7ZXh0OiAnM2dwJywgbWltZTogJ3ZpZGVvLzNncHAnfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnbXA0JywgbWltZTogJ3ZpZGVvL21wNCd9O1xuXHRcdH1cblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnTVRoZCcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21pZCcsXG5cdFx0XHRtaW1lOiAnYXVkaW8vbWlkaSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrU3RyaW5nKCd3T0ZGJykgJiZcblx0XHQoXG5cdFx0XHRjaGVjayhbMHgwMCwgMHgwMSwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDR9KSB8fFxuXHRcdFx0Y2hlY2tTdHJpbmcoJ09UVE8nLCB7b2Zmc2V0OiA0fSlcblx0XHQpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3b2ZmJyxcblx0XHRcdG1pbWU6ICdmb250L3dvZmYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVja1N0cmluZygnd09GMicpICYmXG5cdFx0KFxuXHRcdFx0Y2hlY2soWzB4MDAsIDB4MDEsIDB4MDAsIDB4MDBdLCB7b2Zmc2V0OiA0fSkgfHxcblx0XHRcdGNoZWNrU3RyaW5nKCdPVFRPJywge29mZnNldDogNH0pXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnd29mZjInLFxuXHRcdFx0bWltZTogJ2ZvbnQvd29mZjInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhENCwgMHhDMywgMHhCMiwgMHhBMV0pIHx8IGNoZWNrKFsweEExLCAweEIyLCAweEMzLCAweEQ0XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncGNhcCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLnRjcGR1bXAucGNhcCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gU29ueSBEU0QgU3RyZWFtIEZpbGUgKERTRilcblx0aWYgKGNoZWNrU3RyaW5nKCdEU0QgJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnZHNmJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LWRzZicgLy8gTm9uLXN0YW5kYXJkXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnTFpJUCcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2x6Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWx6aXAnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnZkxhQycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ZsYWMnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL3gtZmxhYydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDUwLCAweDQ3LCAweEZCXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYnBnJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9icGcnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnd3ZwaycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3d2Jyxcblx0XHRcdG1pbWU6ICdhdWRpby93YXZwYWNrJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJyVQREYnKSkge1xuXHRcdC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gQWRvYmUgSWxsdXN0cmF0b3IgZmlsZVxuXHRcdGNvbnN0IGlzQWlGaWxlID0gYXdhaXQgY2hlY2tTZXF1ZW5jZSgnQWRvYmUgSWxsdXN0cmF0b3InLCAxMzUwKTtcblx0XHRpZiAoaXNBaUZpbGUpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2FpJyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEFzc3VtZSB0aGlzIGlzIGp1c3QgYSBub3JtYWwgUERGXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BkZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vcGRmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDAsIDB4NjEsIDB4NzMsIDB4NkRdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3YXNtJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi93YXNtJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBUSUZGLCBsaXR0bGUtZW5kaWFuIHR5cGVcblx0aWYgKGNoZWNrKFsweDQ5LCAweDQ5LCAweDJBLCAweDBdKSkge1xuXHRcdGlmIChjaGVja1N0cmluZygnQ1InLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2NyMicsXG5cdFx0XHRcdG1pbWU6ICdpbWFnZS94LWNhbm9uLWNyMidcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrKFsweDFDLCAweDAwLCAweEZFLCAweDAwXSwge29mZnNldDogOH0pIHx8IGNoZWNrKFsweDFGLCAweDAwLCAweDBCLCAweDAwXSwge29mZnNldDogOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICduZWYnLFxuXHRcdFx0XHRtaW1lOiAnaW1hZ2UveC1uaWtvbi1uZWYnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGNoZWNrKFsweDA4LCAweDAwLCAweDAwLCAweDAwXSwge29mZnNldDogNH0pICYmXG5cdFx0XHQoY2hlY2soWzB4MkQsIDB4MDAsIDB4RkUsIDB4MDBdLCB7b2Zmc2V0OiA4fSkgfHxcblx0XHRcdFx0Y2hlY2soWzB4MjcsIDB4MDAsIDB4RkUsIDB4MDBdLCB7b2Zmc2V0OiA4fSkpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdkbmcnLFxuXHRcdFx0XHRtaW1lOiAnaW1hZ2UveC1hZG9iZS1kbmcnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyNCk7XG5cdFx0YXdhaXQgdG9rZW5pemVyLnBlZWtCdWZmZXIoYnVmZmVyKTtcblx0XHRpZiAoXG5cdFx0XHQoY2hlY2soWzB4MTAsIDB4RkIsIDB4ODYsIDB4MDFdLCB7b2Zmc2V0OiA0fSkgfHwgY2hlY2soWzB4MDgsIDB4MDAsIDB4MDAsIDB4MDBdLCB7b2Zmc2V0OiA0fSkpICYmXG5cdFx0XHQvLyBUaGlzIHBhdHRlcm4gZGlmZmVyZW50aWF0ZXMgQVJXIGZyb20gb3RoZXIgVElGRi1pc2ggZmlsZSB0eXBlczpcblx0XHRcdGNoZWNrKFsweDAwLCAweEZFLCAweDAwLCAweDA0LCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAweDAxXSwge29mZnNldDogOX0pXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdhcncnLFxuXHRcdFx0XHRtaW1lOiAnaW1hZ2UveC1zb255LWFydydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3RpZicsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvdGlmZidcblx0XHR9O1xuXHR9XG5cblx0Ly8gVElGRiwgYmlnLWVuZGlhbiB0eXBlXG5cdGlmIChjaGVjayhbMHg0RCwgMHg0RCwgMHgwLCAweDJBXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndGlmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS90aWZmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ01BQyAnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhcGUnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL2FwZSdcblx0XHR9O1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RocmVhdHN0YWNrL2xpYm1hZ2ljL2Jsb2IvbWFzdGVyL21hZ2ljL01hZ2Rpci9tYXRyb3NrYVxuXHRpZiAoY2hlY2soWzB4MUEsIDB4NDUsIDB4REYsIDB4QTNdKSkgeyAvLyBSb290IGVsZW1lbnQ6IEVCTUxcblx0XHRhc3luYyBmdW5jdGlvbiByZWFkRmllbGQoKSB7XG5cdFx0XHRjb25zdCBtc2IgPSBhd2FpdCB0b2tlbml6ZXIucGVla051bWJlcihUb2tlbi5VSU5UOCk7XG5cdFx0XHRsZXQgbWFzayA9IDB4ODA7XG5cdFx0XHRsZXQgaWMgPSAwOyAvLyAwID0gQSwgMSA9IEIsIDIgPSBDLCAzID0gRFxuXG5cdFx0XHR3aGlsZSAoKG1zYiAmIG1hc2spID09PSAwKSB7XG5cdFx0XHRcdCsraWM7XG5cdFx0XHRcdG1hc2sgPj49IDE7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlkID0gQnVmZmVyLmFsbG9jKGljICsgMSk7XG5cdFx0XHRhd2FpdCB0b2tlbml6ZXIucmVhZEJ1ZmZlcihpZCk7XG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fVxuXG5cdFx0YXN5bmMgZnVuY3Rpb24gcmVhZEVsZW1lbnQoKSB7XG5cdFx0XHRjb25zdCBpZCA9IGF3YWl0IHJlYWRGaWVsZCgpO1xuXHRcdFx0Y29uc3QgbGVuRmllbGQgPSBhd2FpdCByZWFkRmllbGQoKTtcblx0XHRcdGxlbkZpZWxkWzBdIF49IDB4ODAgPj4gKGxlbkZpZWxkLmxlbmd0aCAtIDEpO1xuXHRcdFx0Y29uc3QgbnJMZW4gPSBNYXRoLm1pbig2LCBsZW5GaWVsZC5sZW5ndGgpOyAvLyBKYXZhU2NyaXB0IGNhbiBtYXggcmVhZCA2IGJ5dGVzIGludGVnZXJcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBpZC5yZWFkVUludEJFKDAsIGlkLmxlbmd0aCksXG5cdFx0XHRcdGxlbjogbGVuRmllbGQucmVhZFVJbnRCRShsZW5GaWVsZC5sZW5ndGggLSBuckxlbiwgbnJMZW4pXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGFzeW5jIGZ1bmN0aW9uIHJlYWRDaGlsZHJlbihsZXZlbCwgY2hpbGRyZW4pIHtcblx0XHRcdHdoaWxlIChjaGlsZHJlbiA+IDApIHtcblx0XHRcdFx0Y29uc3QgZSA9IGF3YWl0IHJlYWRFbGVtZW50KCk7XG5cdFx0XHRcdGlmIChlLmlkID09PSAweDQyODIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShlLmxlbiwgJ3V0Zi04JykpOyAvLyBSZXR1cm4gRG9jVHlwZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShlLmxlbik7IC8vIGlnbm9yZSBwYXlsb2FkXG5cdFx0XHRcdC0tY2hpbGRyZW47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmUgPSBhd2FpdCByZWFkRWxlbWVudCgpO1xuXHRcdGNvbnN0IGRvY1R5cGUgPSBhd2FpdCByZWFkQ2hpbGRyZW4oMSwgcmUubGVuKTtcblxuXHRcdHN3aXRjaCAoZG9jVHlwZSkge1xuXHRcdFx0Y2FzZSAnd2VibSc6XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnd2VibScsXG5cdFx0XHRcdFx0bWltZTogJ3ZpZGVvL3dlYm0nXG5cdFx0XHRcdH07XG5cblx0XHRcdGNhc2UgJ21hdHJvc2thJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdta3YnLFxuXHRcdFx0XHRcdG1pbWU6ICd2aWRlby94LW1hdHJvc2thJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0Ly8gUklGRiBmaWxlIGZvcm1hdCB3aGljaCBtaWdodCBiZSBBVkksIFdBViwgUUNQLCBldGNcblx0aWYgKGNoZWNrKFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSkpIHtcblx0XHRpZiAoY2hlY2soWzB4NDEsIDB4NTYsIDB4NDldLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2F2aScsXG5cdFx0XHRcdG1pbWU6ICd2aWRlby92bmQuYXZpJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2soWzB4NTcsIDB4NDEsIDB4NTYsIDB4NDVdLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ3dhdicsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby92bmQud2F2ZSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUUxDTSwgUUNQIGZpbGVcblx0XHRpZiAoY2hlY2soWzB4NTEsIDB4NEMsIDB4NDMsIDB4NERdLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ3FjcCcsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9xY2VscCdcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdTUUxpJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnc3FsaXRlJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXNxbGl0ZTMnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RSwgMHg0NSwgMHg1MywgMHgxQV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ25lcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1uaW50ZW5kby1uZXMtcm9tJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0NyMjQnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdjcngnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZ29vZ2xlLWNocm9tZS1leHRlbnNpb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVja1N0cmluZygnTVNDRicpIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJ0lTYygnKVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY2FiJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhFRCwgMHhBQiwgMHhFRSwgMHhEQl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3JwbScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1ycG0nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhDNSwgMHhEMCwgMHhEMywgMHhDNl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2VwcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZXBzJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSA1LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHg0RiwgMHg1NCwgMHg1NCwgMHg0RiwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ290ZicsXG5cdFx0XHRtaW1lOiAnZm9udC9vdGYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnIyFBTVInKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhbXInLFxuXHRcdFx0bWltZTogJ2F1ZGlvL2Ftcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCd7XFxcXHJ0ZicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3J0ZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vcnRmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDYsIDB4NEMsIDB4NTYsIDB4MDFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdmbHYnLFxuXHRcdFx0bWltZTogJ3ZpZGVvL3gtZmx2J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0lNUE0nKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdpdCcsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC1pdCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrU3RyaW5nKCctbGgwLScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGgxLScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGgyLScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGgzLScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGg0LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGg1LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGg2LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGg3LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbHpzLScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbHo0LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbHo1LScsIHtvZmZzZXQ6IDJ9KSB8fFxuXHRcdGNoZWNrU3RyaW5nKCctbGhkLScsIHtvZmZzZXQ6IDJ9KVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbHpoJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWx6aC1jb21wcmVzc2VkJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBNUEVHIHByb2dyYW0gc3RyZWFtIChQUyBvciBNUEVHLVBTKVxuXHRpZiAoY2hlY2soWzB4MDAsIDB4MDAsIDB4MDEsIDB4QkFdKSkge1xuXHRcdC8vICBNUEVHLVBTLCBNUEVHLTEgUGFydCAxXG5cdFx0aWYgKGNoZWNrKFsweDIxXSwge29mZnNldDogNCwgbWFzazogWzB4RjFdfSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ21wZycsIC8vIE1heSBhbHNvIGJlIC5wcywgLm1wZWdcblx0XHRcdFx0bWltZTogJ3ZpZGVvL01QMVMnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIE1QRUctUFMsIE1QRUctMiBQYXJ0IDFcblx0XHRpZiAoY2hlY2soWzB4NDRdLCB7b2Zmc2V0OiA0LCBtYXNrOiBbMHhDNF19KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbXBnJywgLy8gTWF5IGFsc28gYmUgLm1wZywgLm0ycCwgLnZvYiBvciAuc3ViXG5cdFx0XHRcdG1pbWU6ICd2aWRlby9NUDJQJ1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyAtLSA2LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHhGRCwgMHgzNywgMHg3QSwgMHg1OCwgMHg1QSwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3h6Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXh6J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJzw/eG1sICcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3htbCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veG1sJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0JFR0lOOicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ljcycsXG5cdFx0XHRtaW1lOiAndGV4dC9jYWxlbmRhcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDM3LCAweDdBLCAweEJDLCAweEFGLCAweDI3LCAweDFDXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnN3onLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDUyLCAweDYxLCAweDcyLCAweDIxLCAweDFBLCAweDddKSAmJlxuXHRcdChidWZmZXJbNl0gPT09IDB4MCB8fCBidWZmZXJbNl0gPT09IDB4MSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3JhcicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gLS0gNy1ieXRlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0JMRU5ERVInKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdibGVuZCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1ibGVuZGVyJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJyE8YXJjaD4nKSkge1xuXHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUoOCk7XG5cdFx0Y29uc3Qgc3RyID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZSgxMywgJ2FzY2lpJykpO1xuXHRcdGlmIChzdHIgPT09ICdkZWJpYW4tYmluYXJ5Jykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnZGViJyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZGViJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYXInLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtdW5peC1hcmNoaXZlJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSA4LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHg4OSwgMHg1MCwgMHg0RSwgMHg0NywgMHgwRCwgMHgwQSwgMHgxQSwgMHgwQV0pKSB7XG5cdFx0Ly8gQVBORyBmb3JtYXQgKGh0dHBzOi8vd2lraS5tb3ppbGxhLm9yZy9BUE5HX1NwZWNpZmljYXRpb24pXG5cdFx0Ly8gMS4gRmluZCB0aGUgZmlyc3QgSURBVCAoaW1hZ2UgZGF0YSkgY2h1bmsgKDQ5IDQ0IDQxIDU0KVxuXHRcdC8vIDIuIENoZWNrIGlmIHRoZXJlIGlzIGFuIFwiYWNUTFwiIGNodW5rIGJlZm9yZSB0aGUgSURBVCBvbmUgKDYxIDYzIDU0IDRDKVxuXG5cdFx0Ly8gT2Zmc2V0IGNhbGN1bGF0ZWQgYXMgZm9sbG93czpcblx0XHQvLyAtIDggYnl0ZXM6IFBORyBzaWduYXR1cmVcblx0XHQvLyAtIDQgKGxlbmd0aCkgKyA0IChjaHVuayB0eXBlKSArIDEzIChjaHVuayBkYXRhKSArIDQgKENSQyk6IElIRFIgY2h1bmtcblxuXHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUoOCk7IC8vIGlnbm9yZSBQTkcgc2lnbmF0dXJlXG5cblx0XHRhc3luYyBmdW5jdGlvbiByZWFkQ2h1bmtIZWFkZXIoKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRsZW5ndGg6IGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uSU5UMzJfQkUpLFxuXHRcdFx0XHR0eXBlOiBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdiaW5hcnknKSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZG8ge1xuXHRcdFx0Y29uc3QgY2h1bmsgPSBhd2FpdCByZWFkQ2h1bmtIZWFkZXIoKTtcblx0XHRcdHN3aXRjaCAoY2h1bmsudHlwZSkge1xuXHRcdFx0XHRjYXNlICdJREFUJzpcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAncG5nJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9wbmcnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0Y2FzZSAnYWNUTCc6XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGV4dDogJ2FwbmcnLFxuXHRcdFx0XHRcdFx0bWltZTogJ2ltYWdlL2FwbmcnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKGNodW5rLmxlbmd0aCArIDQpOyAvLyBJZ25vcmUgY2h1bmstZGF0YSArIENSQ1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKHRva2VuaXplci5wb3NpdGlvbiA8IHRva2VuaXplci5maWxlSW5mby5zaXplKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdwbmcnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3BuZydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQxLCAweDUyLCAweDUyLCAweDRGLCAweDU3LCAweDMxLCAweDAwLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYXJyb3cnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtYXBhY2hlLWFycm93J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NjcsIDB4NkMsIDB4NTQsIDB4NDYsIDB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdnbGInLFxuXHRcdFx0bWltZTogJ21vZGVsL2dsdGYtYmluYXJ5J1xuXHRcdH07XG5cdH1cblxuXHQvLyBgbW92YCBmb3JtYXQgdmFyaWFudHNcblx0aWYgKFxuXHRcdGNoZWNrKFsweDY2LCAweDcyLCAweDY1LCAweDY1XSwge29mZnNldDogNH0pIHx8IC8vIGBmcmVlYFxuXHRcdGNoZWNrKFsweDZELCAweDY0LCAweDYxLCAweDc0XSwge29mZnNldDogNH0pIHx8IC8vIGBtZGF0YCBNSlBFR1xuXHRcdGNoZWNrKFsweDZELCAweDZGLCAweDZGLCAweDc2XSwge29mZnNldDogNH0pIHx8IC8vIGBtb292YFxuXHRcdGNoZWNrKFsweDc3LCAweDY5LCAweDY0LCAweDY1XSwge29mZnNldDogNH0pIC8vIGB3aWRlYFxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbW92Jyxcblx0XHRcdG1pbWU6ICd2aWRlby9xdWlja3RpbWUnXG5cdFx0fTtcblx0fVxuXG5cdC8vIC0tIDktYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweDQ5LCAweDQ5LCAweDUyLCAweDRGLCAweDA4LCAweDAwLCAweDAwLCAweDAwLCAweDE4XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnb3JmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LW9seW1wdXMtb3JmJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSAxMi1ieXRlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoY2hlY2soWzB4NDksIDB4NDksIDB4NTUsIDB4MDAsIDB4MTgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4ODgsIDB4RTcsIDB4NzQsIDB4RDhdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdydzInLFxuXHRcdFx0bWltZTogJ2ltYWdlL3gtcGFuYXNvbmljLXJ3Midcblx0XHR9O1xuXHR9XG5cblx0Ly8gQVNGX0hlYWRlcl9PYmplY3QgZmlyc3QgODAgYnl0ZXNcblx0aWYgKGNoZWNrKFsweDMwLCAweDI2LCAweEIyLCAweDc1LCAweDhFLCAweDY2LCAweENGLCAweDExLCAweEE2LCAweEQ5XSkpIHtcblx0XHRhc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyKCkge1xuXHRcdFx0Y29uc3QgZ3VpZCA9IEJ1ZmZlci5hbGxvYygxNik7XG5cdFx0XHRhd2FpdCB0b2tlbml6ZXIucmVhZEJ1ZmZlcihndWlkKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBndWlkLFxuXHRcdFx0XHRzaXplOiBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQ2NF9MRSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSgzMCk7XG5cdFx0Ly8gU2VhcmNoIGZvciBoZWFkZXIgc2hvdWxkIGJlIGluIGZpcnN0IDFLQiBvZiBmaWxlLlxuXHRcdHdoaWxlICh0b2tlbml6ZXIucG9zaXRpb24gKyAyNCA8IHRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG5cdFx0XHRjb25zdCBoZWFkZXIgPSBhd2FpdCByZWFkSGVhZGVyKCk7XG5cdFx0XHRsZXQgcGF5bG9hZCA9IGhlYWRlci5zaXplIC0gMjQ7XG5cdFx0XHRpZiAoX2NoZWNrKGhlYWRlci5pZCwgWzB4OTEsIDB4MDcsIDB4REMsIDB4QjcsIDB4QjcsIDB4QTksIDB4Q0YsIDB4MTEsIDB4OEUsIDB4RTYsIDB4MDAsIDB4QzAsIDB4MEMsIDB4MjAsIDB4NTMsIDB4NjVdKSkge1xuXHRcdFx0XHQvLyBTeW5jIG9uIFN0cmVhbS1Qcm9wZXJ0aWVzLU9iamVjdCAoQjdEQzA3OTEtQTlCNy0xMUNGLThFRTYtMDBDMDBDMjA1MzY1KVxuXHRcdFx0XHRjb25zdCB0eXBlSWQgPSBCdWZmZXIuYWxsb2MoMTYpO1xuXHRcdFx0XHRwYXlsb2FkIC09IGF3YWl0IHRva2VuaXplci5yZWFkQnVmZmVyKHR5cGVJZCk7XG5cblx0XHRcdFx0aWYgKF9jaGVjayh0eXBlSWQsIFsweDQwLCAweDlFLCAweDY5LCAweEY4LCAweDRELCAweDVCLCAweENGLCAweDExLCAweEE4LCAweEZELCAweDAwLCAweDgwLCAweDVGLCAweDVDLCAweDQ0LCAweDJCXSkpIHtcblx0XHRcdFx0XHQvLyBGb3VuZCBhdWRpbzpcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnd21hJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhdWRpby94LW1zLXdtYSdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9jaGVjayh0eXBlSWQsIFsweEMwLCAweEVGLCAweDE5LCAweEJDLCAweDRELCAweDVCLCAweENGLCAweDExLCAweEE4LCAweEZELCAweDAwLCAweDgwLCAweDVGLCAweDVDLCAweDQ0LCAweDJCXSkpIHtcblx0XHRcdFx0XHQvLyBGb3VuZCB2aWRlbzpcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnd212Jyxcblx0XHRcdFx0XHRcdG1pbWU6ICd2aWRlby94LW1zLWFzZidcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUocGF5bG9hZCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byBBU0YgZ2VuZXJpYyBleHRlbnNpb25cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYXNmJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQubXMtYXNmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4QUIsIDB4NEIsIDB4NTQsIDB4NTgsIDB4MjAsIDB4MzEsIDB4MzEsIDB4QkIsIDB4MEQsIDB4MEEsIDB4MUEsIDB4MEFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdrdHgnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2t0eCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKChjaGVjayhbMHg3RSwgMHgxMCwgMHgwNF0pIHx8IGNoZWNrKFsweDdFLCAweDE4LCAweDA0XSkpICYmIGNoZWNrKFsweDMwLCAweDRELCAweDQ5LCAweDQ1XSwge29mZnNldDogNH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21pZScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1taWUnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgyNywgMHgwQSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDJ9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdzaHAnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZXNyaS1zaGFwZSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAwLCAweDAwLCAweDBDLCAweDZBLCAweDUwLCAweDIwLCAweDIwLCAweDBELCAweDBBLCAweDg3LCAweDBBXSkpIHtcblx0XHQvLyBKUEVHLTIwMDAgZmFtaWx5XG5cblx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDIwKTtcblx0XHRjb25zdCB0eXBlID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZSg0LCAnYXNjaWknKSk7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdqcDIgJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcDInLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcDInXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdqcHggJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcHgnLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcHgnXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdqcG0gJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcG0nLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcG0nXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdtanAyJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdtajInLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9tajInXG5cdFx0XHRcdH07XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0Ly8gLS0gVW5zYWZlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4MCwgMHgwLCAweDEsIDB4QkFdKSB8fFxuXHRcdGNoZWNrKFsweDAsIDB4MCwgMHgxLCAweEIzXSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wZycsXG5cdFx0XHRtaW1lOiAndmlkZW8vbXBlZydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndHRmJyxcblx0XHRcdG1pbWU6ICdmb250L3R0Zidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAwLCAweDAxLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnaWNvJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LWljb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgwMCwgMHgwMCwgMHgwMiwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2N1cicsXG5cdFx0XHRtaW1lOiAnaW1hZ2UveC1pY29uJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4RDAsIDB4Q0YsIDB4MTEsIDB4RTAsIDB4QTEsIDB4QjEsIDB4MUEsIDB4RTFdKSkge1xuXHRcdC8vIERldGVjdGVkIE1pY3Jvc29mdCBDb21wb3VuZCBGaWxlIEJpbmFyeSBGaWxlIChNUy1DRkIpIEZvcm1hdC5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY2ZiJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWNmYidcblx0XHR9O1xuXHR9XG5cblx0Ly8gSW5jcmVhc2Ugc2FtcGxlIHNpemUgZnJvbSAxMiB0byAyNTYuXG5cdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge2xlbmd0aDogTWF0aC5taW4oMjU2LCB0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSksIG1heUJlTGVzczogdHJ1ZX0pO1xuXG5cdC8vIGByYWZgIGlzIGhlcmUganVzdCB0byBrZWVwIGFsbCB0aGUgcmF3IGltYWdlIGRldGVjdG9ycyB0b2dldGhlci5cblx0aWYgKGNoZWNrU3RyaW5nKCdGVUpJRklMTUNDRC1SQVcnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdyYWYnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3gtZnVqaWZpbG0tcmFmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0V4dGVuZGVkIE1vZHVsZTonKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd4bScsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC14bSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdDcmVhdGl2ZSBWb2ljZSBGaWxlJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndm9jJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LXZvYydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDA0LCAweDAwLCAweDAwLCAweDAwXSkgJiYgYnVmZmVyLmxlbmd0aCA+PSAxNikgeyAvLyBSb3VnaCAmIHF1aWNrIGNoZWNrIFBpY2tsZS9BU0FSXG5cdFx0Y29uc3QganNvblNpemUgPSBidWZmZXIucmVhZFVJbnQzMkxFKDEyKTtcblx0XHRpZiAoanNvblNpemUgPiAxMiAmJiBqc29uU2l6ZSA8IDI0MCAmJiBidWZmZXIubGVuZ3RoID49IGpzb25TaXplICsgMTYpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGhlYWRlciA9IGJ1ZmZlci5zbGljZSgxNiwganNvblNpemUgKyAxNikudG9TdHJpbmcoKTtcblx0XHRcdFx0Y29uc3QganNvbiA9IEpTT04ucGFyc2UoaGVhZGVyKTtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgUGlja2xlIGlzIEFTQVJcblx0XHRcdFx0aWYgKGpzb24uZmlsZXMpIHsgLy8gRmluYWwgY2hlY2ssIGFzc3VyaW5nIFBpY2tsZS9BU0FSIGZvcm1hdFxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICdhc2FyJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWFzYXInXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChjaGVjayhbMHgwNiwgMHgwRSwgMHgyQiwgMHgzNCwgMHgwMiwgMHgwNSwgMHgwMSwgMHgwMSwgMHgwRCwgMHgwMSwgMHgwMiwgMHgwMSwgMHgwMSwgMHgwMl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ214ZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vbXhmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ1NDUk0nLCB7b2Zmc2V0OiA0NH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3MzbScsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC1zM20nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0N10sIHtvZmZzZXQ6IDR9KSAmJiAoY2hlY2soWzB4NDddLCB7b2Zmc2V0OiAxOTJ9KSB8fCBjaGVjayhbMHg0N10sIHtvZmZzZXQ6IDE5Nn0pKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdtdHMnLFxuXHRcdFx0bWltZTogJ3ZpZGVvL21wMnQnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0MiwgMHg0RiwgMHg0RiwgMHg0QiwgMHg0RCwgMHg0RiwgMHg0MiwgMHg0OV0sIHtvZmZzZXQ6IDYwfSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbW9iaScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDQsIDB4NDksIDB4NDMsIDB4NERdLCB7b2Zmc2V0OiAxMjh9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdkY20nLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL2RpY29tJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NEMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MTQsIDB4MDIsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4QzAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDZdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdsbmsnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gubXMuc2hvcnRjdXQnIC8vIEludmVudGVkIGJ5IHVzXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg2MiwgMHg2RiwgMHg2RiwgMHg2QiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg2RCwgMHg2MSwgMHg3MiwgMHg2QiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2FsaWFzJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LmFwcGxlLmFsaWFzJyAvLyBJbnZlbnRlZCBieSB1c1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NEMsIDB4NTBdLCB7b2Zmc2V0OiAzNH0pICYmXG5cdFx0KFxuXHRcdFx0Y2hlY2soWzB4MDAsIDB4MDAsIDB4MDFdLCB7b2Zmc2V0OiA4fSkgfHxcblx0XHRcdGNoZWNrKFsweDAxLCAweDAwLCAweDAyXSwge29mZnNldDogOH0pIHx8XG5cdFx0XHRjaGVjayhbMHgwMiwgMHgwMCwgMHgwMl0sIHtvZmZzZXQ6IDh9KVxuXHRcdClcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2VvdCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgwNiwgMHgwNiwgMHhFRCwgMHhGNSwgMHhEOCwgMHgxRCwgMHg0NiwgMHhFNSwgMHhCRCwgMHgzMSwgMHhFRiwgMHhFNywgMHhGRSwgMHg3NCwgMHhCNywgMHgxRF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2luZGQnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtaW5kZXNpZ24nXG5cdFx0fTtcblx0fVxuXG5cdC8vIEluY3JlYXNlIHNhbXBsZSBzaXplIGZyb20gMjU2IHRvIDUxMlxuXHRhd2FpdCB0b2tlbml6ZXIucGVla0J1ZmZlcihidWZmZXIsIHtsZW5ndGg6IE1hdGgubWluKDUxMiwgdG9rZW5pemVyLmZpbGVJbmZvLnNpemUpLCBtYXlCZUxlc3M6IHRydWV9KTtcblxuXHQvLyBSZXF1aXJlcyBhIGJ1ZmZlciBzaXplIG9mIDUxMiBieXRlc1xuXHRpZiAodGFySGVhZGVyQ2hlY2tzdW1NYXRjaGVzKGJ1ZmZlcikpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndGFyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXRhcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweEZGLCAweEZFLCAweEZGLCAweDBFLCAweDUzLCAweDAwLCAweDZCLCAweDAwLCAweDY1LCAweDAwLCAweDc0LCAweDAwLCAweDYzLCAweDAwLCAweDY4LCAweDAwLCAweDU1LCAweDAwLCAweDcwLCAweDAwLCAweDIwLCAweDAwLCAweDRELCAweDAwLCAweDZGLCAweDAwLCAweDY0LCAweDAwLCAweDY1LCAweDAwLCAweDZDLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnc2twJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQuc2tldGNodXAuc2twJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJy0tLS0tQkVHSU4gUEdQIE1FU1NBR0UtLS0tLScpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BncCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIE1QRUcgaGVhZGVyIGF0IGRpZmZlcmVudCBzdGFydGluZyBvZmZzZXRzXG5cdGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCAyICYmIHN0YXJ0IDwgKGJ1ZmZlci5sZW5ndGggLSAxNik7IHN0YXJ0KyspIHtcblx0XHQvLyBDaGVjayBNUEVHIDEgb3IgMiBMYXllciAzIGhlYWRlciwgb3IgJ2xheWVyIDAnIGZvciBBRFRTIChNUEVHIHN5bmMtd29yZCAweEZGRSlcblx0XHRpZiAoYnVmZmVyLmxlbmd0aCA+PSBzdGFydCArIDIgJiYgY2hlY2soWzB4RkYsIDB4RTBdLCB7b2Zmc2V0OiBzdGFydCwgbWFzazogWzB4RkYsIDB4RTBdfSkpIHtcblx0XHRcdGlmIChjaGVjayhbMHgxMF0sIHtvZmZzZXQ6IHN0YXJ0ICsgMSwgbWFzazogWzB4MTZdfSkpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIChBRFRTKSBNUEVHLTJcblx0XHRcdFx0aWYgKGNoZWNrKFsweDA4XSwge29mZnNldDogc3RhcnQgKyAxLCBtYXNrOiBbMHgwOF19KSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICdhYWMnLFxuXHRcdFx0XHRcdFx0bWltZTogJ2F1ZGlvL2FhYydcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTXVzdCBiZSAoQURUUykgTVBFRy00XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnYWFjJyxcblx0XHRcdFx0XHRtaW1lOiAnYXVkaW8vYWFjJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNUEVHIDEgb3IgMiBMYXllciAzIGhlYWRlclxuXHRcdFx0Ly8gQ2hlY2sgZm9yIE1QRUcgbGF5ZXIgM1xuXHRcdFx0aWYgKGNoZWNrKFsweDAyXSwge29mZnNldDogc3RhcnQgKyAxLCBtYXNrOiBbMHgwNl19KSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGV4dDogJ21wMycsXG5cdFx0XHRcdFx0bWltZTogJ2F1ZGlvL21wZWcnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGZvciBNUEVHIGxheWVyIDJcblx0XHRcdGlmIChjaGVjayhbMHgwNF0sIHtvZmZzZXQ6IHN0YXJ0ICsgMSwgbWFzazogWzB4MDZdfSkpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdtcDInLFxuXHRcdFx0XHRcdG1pbWU6ICdhdWRpby9tcGVnJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgTVBFRyBsYXllciAxXG5cdFx0XHRpZiAoY2hlY2soWzB4MDZdLCB7b2Zmc2V0OiBzdGFydCArIDEsIG1hc2s6IFsweDA2XX0pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnbXAxJyxcblx0XHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuY29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW0gPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHQvLyBVc2luZyBgZXZhbGAgdG8gd29yayBhcm91bmQgaXNzdWVzIHdoZW4gYnVuZGxpbmcgd2l0aCBXZWJwYWNrXG5cdGNvbnN0IHN0cmVhbSA9IGV2YWwoJ3JlcXVpcmUnKSgnc3RyZWFtJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXG5cdHJlYWRhYmxlU3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG5cdHJlYWRhYmxlU3RyZWFtLm9uY2UoJ3JlYWRhYmxlJywgYXN5bmMgKCkgPT4ge1xuXHRcdC8vIFNldCB1cCBvdXRwdXQgc3RyZWFtXG5cdFx0Y29uc3QgcGFzcyA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKTtcblx0XHRsZXQgb3V0cHV0U3RyZWFtO1xuXHRcdGlmIChzdHJlYW0ucGlwZWxpbmUpIHtcblx0XHRcdG91dHB1dFN0cmVhbSA9IHN0cmVhbS5waXBlbGluZShyZWFkYWJsZVN0cmVhbSwgcGFzcywgKCkgPT4ge1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dFN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtLnBpcGUocGFzcyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCB0aGUgaW5wdXQgc3RyZWFtIGFuZCBkZXRlY3QgdGhlIGZpbGV0eXBlXG5cdFx0Y29uc3QgY2h1bmsgPSByZWFkYWJsZVN0cmVhbS5yZWFkKG1pbmltdW1CeXRlcykgfHwgcmVhZGFibGVTdHJlYW0ucmVhZCgpIHx8IEJ1ZmZlci5hbGxvYygwKTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgZmlsZVR5cGUgPSBhd2FpdCBmcm9tQnVmZmVyKGNodW5rKTtcblx0XHRcdHBhc3MuZmlsZVR5cGUgPSBmaWxlVHlwZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHR9XG5cblx0XHRyZXNvbHZlKG91dHB1dFN0cmVhbSk7XG5cdH0pO1xufSk7XG5cbmNvbnN0IGZpbGVUeXBlID0ge1xuXHRmcm9tU3RyZWFtLFxuXHRmcm9tVG9rZW5pemVyLFxuXHRmcm9tQnVmZmVyLFxuXHRzdHJlYW1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlVHlwZSwgJ2V4dGVuc2lvbnMnLCB7XG5cdGdldCgpIHtcblx0XHRyZXR1cm4gbmV3IFNldChzdXBwb3J0ZWQuZXh0ZW5zaW9ucyk7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsZVR5cGUsICdtaW1lVHlwZXMnLCB7XG5cdGdldCgpIHtcblx0XHRyZXR1cm4gbmV3IFNldChzdXBwb3J0ZWQubWltZVR5cGVzKTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsZVR5cGU7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/file-type/core.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/file-type/supported.js":
/*!*************************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/file-type/supported.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n\textensions: [\n\t\t'jpg',\n\t\t'png',\n\t\t'apng',\n\t\t'gif',\n\t\t'webp',\n\t\t'flif',\n\t\t'cr2',\n\t\t'cr3',\n\t\t'orf',\n\t\t'arw',\n\t\t'dng',\n\t\t'nef',\n\t\t'rw2',\n\t\t'raf',\n\t\t'tif',\n\t\t'bmp',\n\t\t'icns',\n\t\t'jxr',\n\t\t'psd',\n\t\t'indd',\n\t\t'zip',\n\t\t'tar',\n\t\t'rar',\n\t\t'gz',\n\t\t'bz2',\n\t\t'7z',\n\t\t'dmg',\n\t\t'mp4',\n\t\t'mid',\n\t\t'mkv',\n\t\t'webm',\n\t\t'mov',\n\t\t'avi',\n\t\t'mpg',\n\t\t'mp2',\n\t\t'mp3',\n\t\t'm4a',\n\t\t'oga',\n\t\t'ogg',\n\t\t'ogv',\n\t\t'opus',\n\t\t'flac',\n\t\t'wav',\n\t\t'spx',\n\t\t'amr',\n\t\t'pdf',\n\t\t'epub',\n\t\t'exe',\n\t\t'swf',\n\t\t'rtf',\n\t\t'wasm',\n\t\t'woff',\n\t\t'woff2',\n\t\t'eot',\n\t\t'ttf',\n\t\t'otf',\n\t\t'ico',\n\t\t'flv',\n\t\t'ps',\n\t\t'xz',\n\t\t'sqlite',\n\t\t'nes',\n\t\t'crx',\n\t\t'xpi',\n\t\t'cab',\n\t\t'deb',\n\t\t'ar',\n\t\t'rpm',\n\t\t'Z',\n\t\t'lz',\n\t\t'cfb',\n\t\t'mxf',\n\t\t'mts',\n\t\t'blend',\n\t\t'bpg',\n\t\t'docx',\n\t\t'pptx',\n\t\t'xlsx',\n\t\t'3gp',\n\t\t'3g2',\n\t\t'jp2',\n\t\t'jpm',\n\t\t'jpx',\n\t\t'mj2',\n\t\t'aif',\n\t\t'qcp',\n\t\t'odt',\n\t\t'ods',\n\t\t'odp',\n\t\t'xml',\n\t\t'mobi',\n\t\t'heic',\n\t\t'cur',\n\t\t'ktx',\n\t\t'ape',\n\t\t'wv',\n\t\t'wmv',\n\t\t'wma',\n\t\t'dcm',\n\t\t'ics',\n\t\t'glb',\n\t\t'pcap',\n\t\t'dsf',\n\t\t'lnk',\n\t\t'alias',\n\t\t'voc',\n\t\t'ac3',\n\t\t'm4v',\n\t\t'm4p',\n\t\t'm4b',\n\t\t'f4v',\n\t\t'f4p',\n\t\t'f4b',\n\t\t'f4a',\n\t\t'mie',\n\t\t'asf',\n\t\t'ogm',\n\t\t'ogx',\n\t\t'mpc',\n\t\t'arrow',\n\t\t'shp',\n\t\t'aac',\n\t\t'mp1',\n\t\t'it',\n\t\t's3m',\n\t\t'xm',\n\t\t'ai',\n\t\t'skp',\n\t\t'avif',\n\t\t'eps',\n\t\t'lzh',\n\t\t'pgp',\n\t\t'asar'\n\t],\n\tmimeTypes: [\n\t\t'image/jpeg',\n\t\t'image/png',\n\t\t'image/gif',\n\t\t'image/webp',\n\t\t'image/flif',\n\t\t'image/x-canon-cr2',\n\t\t'image/x-canon-cr3',\n\t\t'image/tiff',\n\t\t'image/bmp',\n\t\t'image/vnd.ms-photo',\n\t\t'image/vnd.adobe.photoshop',\n\t\t'application/x-indesign',\n\t\t'application/epub+zip',\n\t\t'application/x-xpinstall',\n\t\t'application/vnd.oasis.opendocument.text',\n\t\t'application/vnd.oasis.opendocument.spreadsheet',\n\t\t'application/vnd.oasis.opendocument.presentation',\n\t\t'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\t\t'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n\t\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\t'application/zip',\n\t\t'application/x-tar',\n\t\t'application/x-rar-compressed',\n\t\t'application/gzip',\n\t\t'application/x-bzip2',\n\t\t'application/x-7z-compressed',\n\t\t'application/x-apple-diskimage',\n\t\t'application/x-apache-arrow',\n\t\t'video/mp4',\n\t\t'audio/midi',\n\t\t'video/x-matroska',\n\t\t'video/webm',\n\t\t'video/quicktime',\n\t\t'video/vnd.avi',\n\t\t'audio/vnd.wave',\n\t\t'audio/qcelp',\n\t\t'audio/x-ms-wma',\n\t\t'video/x-ms-asf',\n\t\t'application/vnd.ms-asf',\n\t\t'video/mpeg',\n\t\t'video/3gpp',\n\t\t'audio/mpeg',\n\t\t'audio/mp4', // RFC 4337\n\t\t'audio/opus',\n\t\t'video/ogg',\n\t\t'audio/ogg',\n\t\t'application/ogg',\n\t\t'audio/x-flac',\n\t\t'audio/ape',\n\t\t'audio/wavpack',\n\t\t'audio/amr',\n\t\t'application/pdf',\n\t\t'application/x-msdownload',\n\t\t'application/x-shockwave-flash',\n\t\t'application/rtf',\n\t\t'application/wasm',\n\t\t'font/woff',\n\t\t'font/woff2',\n\t\t'application/vnd.ms-fontobject',\n\t\t'font/ttf',\n\t\t'font/otf',\n\t\t'image/x-icon',\n\t\t'video/x-flv',\n\t\t'application/postscript',\n\t\t'application/eps',\n\t\t'application/x-xz',\n\t\t'application/x-sqlite3',\n\t\t'application/x-nintendo-nes-rom',\n\t\t'application/x-google-chrome-extension',\n\t\t'application/vnd.ms-cab-compressed',\n\t\t'application/x-deb',\n\t\t'application/x-unix-archive',\n\t\t'application/x-rpm',\n\t\t'application/x-compress',\n\t\t'application/x-lzip',\n\t\t'application/x-cfb',\n\t\t'application/x-mie',\n\t\t'application/mxf',\n\t\t'video/mp2t',\n\t\t'application/x-blender',\n\t\t'image/bpg',\n\t\t'image/jp2',\n\t\t'image/jpx',\n\t\t'image/jpm',\n\t\t'image/mj2',\n\t\t'audio/aiff',\n\t\t'application/xml',\n\t\t'application/x-mobipocket-ebook',\n\t\t'image/heif',\n\t\t'image/heif-sequence',\n\t\t'image/heic',\n\t\t'image/heic-sequence',\n\t\t'image/icns',\n\t\t'image/ktx',\n\t\t'application/dicom',\n\t\t'audio/x-musepack',\n\t\t'text/calendar',\n\t\t'model/gltf-binary',\n\t\t'application/vnd.tcpdump.pcap',\n\t\t'audio/x-dsf', // Non-standard\n\t\t'application/x.ms.shortcut', // Invented by us\n\t\t'application/x.apple.alias', // Invented by us\n\t\t'audio/x-voc',\n\t\t'audio/vnd.dolby.dd-raw',\n\t\t'audio/x-m4a',\n\t\t'image/apng',\n\t\t'image/x-olympus-orf',\n\t\t'image/x-sony-arw',\n\t\t'image/x-adobe-dng',\n\t\t'image/x-nikon-nef',\n\t\t'image/x-panasonic-rw2',\n\t\t'image/x-fujifilm-raf',\n\t\t'video/x-m4v',\n\t\t'video/3gpp2',\n\t\t'application/x-esri-shape',\n\t\t'audio/aac',\n\t\t'audio/x-it',\n\t\t'audio/x-s3m',\n\t\t'audio/x-xm',\n\t\t'video/MP1S',\n\t\t'video/MP2P',\n\t\t'application/vnd.sketchup.skp',\n\t\t'image/avif',\n\t\t'application/x-lzh-compressed',\n\t\t'application/pgp-encrypted',\n\t\t'application/x-asar'\n\t]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2ZpbGUtdHlwZS9zdXBwb3J0ZWQuanM/ODEwNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9ub2RlX21vZHVsZXMvZmlsZS10eXBlL3N1cHBvcnRlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGV4dGVuc2lvbnM6IFtcblx0XHQnanBnJyxcblx0XHQncG5nJyxcblx0XHQnYXBuZycsXG5cdFx0J2dpZicsXG5cdFx0J3dlYnAnLFxuXHRcdCdmbGlmJyxcblx0XHQnY3IyJyxcblx0XHQnY3IzJyxcblx0XHQnb3JmJyxcblx0XHQnYXJ3Jyxcblx0XHQnZG5nJyxcblx0XHQnbmVmJyxcblx0XHQncncyJyxcblx0XHQncmFmJyxcblx0XHQndGlmJyxcblx0XHQnYm1wJyxcblx0XHQnaWNucycsXG5cdFx0J2p4cicsXG5cdFx0J3BzZCcsXG5cdFx0J2luZGQnLFxuXHRcdCd6aXAnLFxuXHRcdCd0YXInLFxuXHRcdCdyYXInLFxuXHRcdCdneicsXG5cdFx0J2J6MicsXG5cdFx0Jzd6Jyxcblx0XHQnZG1nJyxcblx0XHQnbXA0Jyxcblx0XHQnbWlkJyxcblx0XHQnbWt2Jyxcblx0XHQnd2VibScsXG5cdFx0J21vdicsXG5cdFx0J2F2aScsXG5cdFx0J21wZycsXG5cdFx0J21wMicsXG5cdFx0J21wMycsXG5cdFx0J200YScsXG5cdFx0J29nYScsXG5cdFx0J29nZycsXG5cdFx0J29ndicsXG5cdFx0J29wdXMnLFxuXHRcdCdmbGFjJyxcblx0XHQnd2F2Jyxcblx0XHQnc3B4Jyxcblx0XHQnYW1yJyxcblx0XHQncGRmJyxcblx0XHQnZXB1YicsXG5cdFx0J2V4ZScsXG5cdFx0J3N3ZicsXG5cdFx0J3J0ZicsXG5cdFx0J3dhc20nLFxuXHRcdCd3b2ZmJyxcblx0XHQnd29mZjInLFxuXHRcdCdlb3QnLFxuXHRcdCd0dGYnLFxuXHRcdCdvdGYnLFxuXHRcdCdpY28nLFxuXHRcdCdmbHYnLFxuXHRcdCdwcycsXG5cdFx0J3h6Jyxcblx0XHQnc3FsaXRlJyxcblx0XHQnbmVzJyxcblx0XHQnY3J4Jyxcblx0XHQneHBpJyxcblx0XHQnY2FiJyxcblx0XHQnZGViJyxcblx0XHQnYXInLFxuXHRcdCdycG0nLFxuXHRcdCdaJyxcblx0XHQnbHonLFxuXHRcdCdjZmInLFxuXHRcdCdteGYnLFxuXHRcdCdtdHMnLFxuXHRcdCdibGVuZCcsXG5cdFx0J2JwZycsXG5cdFx0J2RvY3gnLFxuXHRcdCdwcHR4Jyxcblx0XHQneGxzeCcsXG5cdFx0JzNncCcsXG5cdFx0JzNnMicsXG5cdFx0J2pwMicsXG5cdFx0J2pwbScsXG5cdFx0J2pweCcsXG5cdFx0J21qMicsXG5cdFx0J2FpZicsXG5cdFx0J3FjcCcsXG5cdFx0J29kdCcsXG5cdFx0J29kcycsXG5cdFx0J29kcCcsXG5cdFx0J3htbCcsXG5cdFx0J21vYmknLFxuXHRcdCdoZWljJyxcblx0XHQnY3VyJyxcblx0XHQna3R4Jyxcblx0XHQnYXBlJyxcblx0XHQnd3YnLFxuXHRcdCd3bXYnLFxuXHRcdCd3bWEnLFxuXHRcdCdkY20nLFxuXHRcdCdpY3MnLFxuXHRcdCdnbGInLFxuXHRcdCdwY2FwJyxcblx0XHQnZHNmJyxcblx0XHQnbG5rJyxcblx0XHQnYWxpYXMnLFxuXHRcdCd2b2MnLFxuXHRcdCdhYzMnLFxuXHRcdCdtNHYnLFxuXHRcdCdtNHAnLFxuXHRcdCdtNGInLFxuXHRcdCdmNHYnLFxuXHRcdCdmNHAnLFxuXHRcdCdmNGInLFxuXHRcdCdmNGEnLFxuXHRcdCdtaWUnLFxuXHRcdCdhc2YnLFxuXHRcdCdvZ20nLFxuXHRcdCdvZ3gnLFxuXHRcdCdtcGMnLFxuXHRcdCdhcnJvdycsXG5cdFx0J3NocCcsXG5cdFx0J2FhYycsXG5cdFx0J21wMScsXG5cdFx0J2l0Jyxcblx0XHQnczNtJyxcblx0XHQneG0nLFxuXHRcdCdhaScsXG5cdFx0J3NrcCcsXG5cdFx0J2F2aWYnLFxuXHRcdCdlcHMnLFxuXHRcdCdsemgnLFxuXHRcdCdwZ3AnLFxuXHRcdCdhc2FyJ1xuXHRdLFxuXHRtaW1lVHlwZXM6IFtcblx0XHQnaW1hZ2UvanBlZycsXG5cdFx0J2ltYWdlL3BuZycsXG5cdFx0J2ltYWdlL2dpZicsXG5cdFx0J2ltYWdlL3dlYnAnLFxuXHRcdCdpbWFnZS9mbGlmJyxcblx0XHQnaW1hZ2UveC1jYW5vbi1jcjInLFxuXHRcdCdpbWFnZS94LWNhbm9uLWNyMycsXG5cdFx0J2ltYWdlL3RpZmYnLFxuXHRcdCdpbWFnZS9ibXAnLFxuXHRcdCdpbWFnZS92bmQubXMtcGhvdG8nLFxuXHRcdCdpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wJyxcblx0XHQnYXBwbGljYXRpb24veC1pbmRlc2lnbicsXG5cdFx0J2FwcGxpY2F0aW9uL2VwdWIremlwJyxcblx0XHQnYXBwbGljYXRpb24veC14cGluc3RhbGwnLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0Jyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb24nLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCcsXG5cdFx0J2FwcGxpY2F0aW9uL3ppcCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtdGFyJyxcblx0XHQnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCcsXG5cdFx0J2FwcGxpY2F0aW9uL2d6aXAnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcblx0XHQnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcblx0XHQnYXBwbGljYXRpb24veC1hcHBsZS1kaXNraW1hZ2UnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWFwYWNoZS1hcnJvdycsXG5cdFx0J3ZpZGVvL21wNCcsXG5cdFx0J2F1ZGlvL21pZGknLFxuXHRcdCd2aWRlby94LW1hdHJvc2thJyxcblx0XHQndmlkZW8vd2VibScsXG5cdFx0J3ZpZGVvL3F1aWNrdGltZScsXG5cdFx0J3ZpZGVvL3ZuZC5hdmknLFxuXHRcdCdhdWRpby92bmQud2F2ZScsXG5cdFx0J2F1ZGlvL3FjZWxwJyxcblx0XHQnYXVkaW8veC1tcy13bWEnLFxuXHRcdCd2aWRlby94LW1zLWFzZicsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5tcy1hc2YnLFxuXHRcdCd2aWRlby9tcGVnJyxcblx0XHQndmlkZW8vM2dwcCcsXG5cdFx0J2F1ZGlvL21wZWcnLFxuXHRcdCdhdWRpby9tcDQnLCAvLyBSRkMgNDMzN1xuXHRcdCdhdWRpby9vcHVzJyxcblx0XHQndmlkZW8vb2dnJyxcblx0XHQnYXVkaW8vb2dnJyxcblx0XHQnYXBwbGljYXRpb24vb2dnJyxcblx0XHQnYXVkaW8veC1mbGFjJyxcblx0XHQnYXVkaW8vYXBlJyxcblx0XHQnYXVkaW8vd2F2cGFjaycsXG5cdFx0J2F1ZGlvL2FtcicsXG5cdFx0J2FwcGxpY2F0aW9uL3BkZicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJyxcblx0XHQnYXBwbGljYXRpb24vcnRmJyxcblx0XHQnYXBwbGljYXRpb24vd2FzbScsXG5cdFx0J2ZvbnQvd29mZicsXG5cdFx0J2ZvbnQvd29mZjInLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG5cdFx0J2ZvbnQvdHRmJyxcblx0XHQnZm9udC9vdGYnLFxuXHRcdCdpbWFnZS94LWljb24nLFxuXHRcdCd2aWRlby94LWZsdicsXG5cdFx0J2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuXHRcdCdhcHBsaWNhdGlvbi9lcHMnLFxuXHRcdCdhcHBsaWNhdGlvbi94LXh6Jyxcblx0XHQnYXBwbGljYXRpb24veC1zcWxpdGUzJyxcblx0XHQnYXBwbGljYXRpb24veC1uaW50ZW5kby1uZXMtcm9tJyxcblx0XHQnYXBwbGljYXRpb24veC1nb29nbGUtY2hyb21lLWV4dGVuc2lvbicsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5tcy1jYWItY29tcHJlc3NlZCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtZGViJyxcblx0XHQnYXBwbGljYXRpb24veC11bml4LWFyY2hpdmUnLFxuXHRcdCdhcHBsaWNhdGlvbi94LXJwbScsXG5cdFx0J2FwcGxpY2F0aW9uL3gtY29tcHJlc3MnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWx6aXAnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWNmYicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtbWllJyxcblx0XHQnYXBwbGljYXRpb24vbXhmJyxcblx0XHQndmlkZW8vbXAydCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtYmxlbmRlcicsXG5cdFx0J2ltYWdlL2JwZycsXG5cdFx0J2ltYWdlL2pwMicsXG5cdFx0J2ltYWdlL2pweCcsXG5cdFx0J2ltYWdlL2pwbScsXG5cdFx0J2ltYWdlL21qMicsXG5cdFx0J2F1ZGlvL2FpZmYnLFxuXHRcdCdhcHBsaWNhdGlvbi94bWwnLFxuXHRcdCdhcHBsaWNhdGlvbi94LW1vYmlwb2NrZXQtZWJvb2snLFxuXHRcdCdpbWFnZS9oZWlmJyxcblx0XHQnaW1hZ2UvaGVpZi1zZXF1ZW5jZScsXG5cdFx0J2ltYWdlL2hlaWMnLFxuXHRcdCdpbWFnZS9oZWljLXNlcXVlbmNlJyxcblx0XHQnaW1hZ2UvaWNucycsXG5cdFx0J2ltYWdlL2t0eCcsXG5cdFx0J2FwcGxpY2F0aW9uL2RpY29tJyxcblx0XHQnYXVkaW8veC1tdXNlcGFjaycsXG5cdFx0J3RleHQvY2FsZW5kYXInLFxuXHRcdCdtb2RlbC9nbHRmLWJpbmFyeScsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC50Y3BkdW1wLnBjYXAnLFxuXHRcdCdhdWRpby94LWRzZicsIC8vIE5vbi1zdGFuZGFyZFxuXHRcdCdhcHBsaWNhdGlvbi94Lm1zLnNob3J0Y3V0JywgLy8gSW52ZW50ZWQgYnkgdXNcblx0XHQnYXBwbGljYXRpb24veC5hcHBsZS5hbGlhcycsIC8vIEludmVudGVkIGJ5IHVzXG5cdFx0J2F1ZGlvL3gtdm9jJyxcblx0XHQnYXVkaW8vdm5kLmRvbGJ5LmRkLXJhdycsXG5cdFx0J2F1ZGlvL3gtbTRhJyxcblx0XHQnaW1hZ2UvYXBuZycsXG5cdFx0J2ltYWdlL3gtb2x5bXB1cy1vcmYnLFxuXHRcdCdpbWFnZS94LXNvbnktYXJ3Jyxcblx0XHQnaW1hZ2UveC1hZG9iZS1kbmcnLFxuXHRcdCdpbWFnZS94LW5pa29uLW5lZicsXG5cdFx0J2ltYWdlL3gtcGFuYXNvbmljLXJ3MicsXG5cdFx0J2ltYWdlL3gtZnVqaWZpbG0tcmFmJyxcblx0XHQndmlkZW8veC1tNHYnLFxuXHRcdCd2aWRlby8zZ3BwMicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtZXNyaS1zaGFwZScsXG5cdFx0J2F1ZGlvL2FhYycsXG5cdFx0J2F1ZGlvL3gtaXQnLFxuXHRcdCdhdWRpby94LXMzbScsXG5cdFx0J2F1ZGlvL3gteG0nLFxuXHRcdCd2aWRlby9NUDFTJyxcblx0XHQndmlkZW8vTVAyUCcsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5za2V0Y2h1cC5za3AnLFxuXHRcdCdpbWFnZS9hdmlmJyxcblx0XHQnYXBwbGljYXRpb24veC1semgtY29tcHJlc3NlZCcsXG5cdFx0J2FwcGxpY2F0aW9uL3BncC1lbmNyeXB0ZWQnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWFzYXInXG5cdF1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/file-type/supported.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/file-type/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/file-type/util.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexports.tarHeaderChecksumMatches = (buffer, offset = 0) => {\n\tconst readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let i = offset; i < offset + 148; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\tfor (let i = offset + 156; i < offset + 512; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\treturn readSum === sum;\n};\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexports.uint32SyncSafeToken = {\n\tget: (buffer, offset) => {\n\t\treturn (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);\n\t},\n\tlen: 4\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL2ZpbGUtdHlwZS91dGlsLmpzP2FhNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZixRQUFRLE9BQU87QUFDZixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQixxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7O0FBRUEsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9ub2RlX21vZHVsZXMvZmlsZS10eXBlL3V0aWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZyA9PiBbLi4uc3RyaW5nXS5tYXAoY2hhcmFjdGVyID0+IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApKTtcblxuLyoqXG5DaGVja3Mgd2hldGhlciB0aGUgVEFSIGNoZWNrc3VtIGlzIHZhbGlkLlxuXG5AcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gVGhlIFRBUiBoZWFkZXIgYFtvZmZzZXQgLi4uIG9mZnNldCArIDUxMl1gLlxuQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRBUiBoZWFkZXIgb2Zmc2V0LlxuQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgVEFSIGNoZWNrc3VtIGlzIHZhbGlkLCBvdGhlcndpc2UgYGZhbHNlYC5cbiovXG5leHBvcnRzLnRhckhlYWRlckNoZWNrc3VtTWF0Y2hlcyA9IChidWZmZXIsIG9mZnNldCA9IDApID0+IHtcblx0Y29uc3QgcmVhZFN1bSA9IHBhcnNlSW50KGJ1ZmZlci50b1N0cmluZygndXRmOCcsIDE0OCwgMTU0KS5yZXBsYWNlKC9cXDAuKiQvLCAnJykudHJpbSgpLCA4KTsgLy8gUmVhZCBzdW0gaW4gaGVhZGVyXG5cdGlmIChpc05hTihyZWFkU3VtKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBzdW0gPSA4ICogMHgyMDsgLy8gSW5pdGlhbGl6ZSBzaWduZWQgYml0IHN1bVxuXG5cdGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyAxNDg7IGkrKykge1xuXHRcdHN1bSArPSBidWZmZXJbaV07XG5cdH1cblxuXHRmb3IgKGxldCBpID0gb2Zmc2V0ICsgMTU2OyBpIDwgb2Zmc2V0ICsgNTEyOyBpKyspIHtcblx0XHRzdW0gKz0gYnVmZmVyW2ldO1xuXHR9XG5cblx0cmV0dXJuIHJlYWRTdW0gPT09IHN1bTtcbn07XG5cbi8qKlxuSUQzIFVJTlQzMiBzeW5jLXNhZmUgdG9rZW5pemVyIHRva2VuLlxuMjggYml0cyAocmVwcmVzZW50aW5nIHVwIHRvIDI1Nk1CKSBpbnRlZ2VyLCB0aGUgbXNiIGlzIDAgdG8gYXZvaWQgXCJmYWxzZSBzeW5jc2lnbmFsc1wiLlxuKi9cbmV4cG9ydHMudWludDMyU3luY1NhZmVUb2tlbiA9IHtcblx0Z2V0OiAoYnVmZmVyLCBvZmZzZXQpID0+IHtcblx0XHRyZXR1cm4gKGJ1ZmZlcltvZmZzZXQgKyAzXSAmIDB4N0YpIHwgKChidWZmZXJbb2Zmc2V0ICsgMl0pIDw8IDcpIHwgKChidWZmZXJbb2Zmc2V0ICsgMV0pIDw8IDE0KSB8ICgoYnVmZmVyW29mZnNldF0pIDw8IDIxKTtcblx0fSxcblx0bGVuOiA0XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/file-type/util.js\n");

/***/ }),

/***/ "./node_modules/music-metadata/node_modules/ms/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/ms/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzE1NzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/music-metadata/node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/assert/assert.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/assert/assert.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/node-libs-browser/node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanM/ZWViOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx5RUFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/assert/assert.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz8xYzM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanM/MTVmMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanM/OGZmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcz9lZWQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLHlHQUFvQjs7QUFFL0M7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDRGQUFVOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RCwyQkFBMkIsbURBQW1EO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/util/util.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/peek-readable/lib/EndOfFileStream.js":
/*!***********************************************************!*\
  !*** ./node_modules/peek-readable/lib/EndOfFileStream.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultMessages = 'End-Of-Stream';\n/**\n * Thrown on read operation of the end of file or stream has been reached\n */\nclass EndOfStreamError extends Error {\n    constructor() {\n        super(exports.defaultMessages);\n    }\n}\nexports.EndOfStreamError = EndOfStreamError;\n//# sourceMappingURL=EndOfFileStream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGVlay1yZWFkYWJsZS9saWIvRW5kT2ZGaWxlU3RyZWFtLmpzP2YzNWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3BlZWstcmVhZGFibGUvbGliL0VuZE9mRmlsZVN0cmVhbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0TWVzc2FnZXMgPSAnRW5kLU9mLVN0cmVhbSc7XG4vKipcbiAqIFRocm93biBvbiByZWFkIG9wZXJhdGlvbiBvZiB0aGUgZW5kIG9mIGZpbGUgb3Igc3RyZWFtIGhhcyBiZWVuIHJlYWNoZWRcbiAqL1xuY2xhc3MgRW5kT2ZTdHJlYW1FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZXhwb3J0cy5kZWZhdWx0TWVzc2FnZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRW5kT2ZTdHJlYW1FcnJvciA9IEVuZE9mU3RyZWFtRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbmRPZkZpbGVTdHJlYW0uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/peek-readable/lib/EndOfFileStream.js\n");

/***/ }),

/***/ "./node_modules/peek-readable/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/peek-readable/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst EndOfFileStream_1 = __webpack_require__(/*! ./EndOfFileStream */ \"./node_modules/peek-readable/lib/EndOfFileStream.js\");\nvar EndOfFileStream_2 = __webpack_require__(/*! ./EndOfFileStream */ \"./node_modules/peek-readable/lib/EndOfFileStream.js\");\nexports.EndOfStreamError = EndOfFileStream_2.EndOfStreamError;\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n    constructor(s) {\n        this.s = s;\n        this.endOfStream = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n        if (!s.read || !s.once) {\n            throw new Error('Expected an instance of stream.Readable');\n        }\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n        this.s.once('error', err => this.reject(err));\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\n    }\n    /**\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n     * @param buffer - Buffer to store data read from stream in\n     * @param offset - Offset buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes peeked\n     */\n    async peek(buffer, offset, length) {\n        const bytesRead = await this.read(buffer, offset, length);\n        this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target buffer to store data read from stream in\n     * @param offset - Offset of target buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async read(buffer, offset, length) {\n        if (length === 0) {\n            return 0;\n        }\n        if (this.peekQueue.length === 0 && this.endOfStream) {\n            throw new EndOfFileStream_1.EndOfStreamError();\n        }\n        let remaining = length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            const lenCopy = Math.min(peekData.length, remaining);\n            peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.slice(lenCopy));\n            }\n        }\n        // continue reading from stream if required\n        while (remaining > 0 && !this.endOfStream) {\n            const reqLen = Math.min(remaining, maxStreamReadSize);\n            const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n            bytesRead += chunkLen;\n            if (chunkLen < reqLen)\n                break;\n            remaining -= chunkLen;\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer Buffer to store data read from stream in\n     * @param offset Offset buffer\n     * @param length Number of bytes to read\n     * @returns {any}\n     */\n    async _read(buffer, offset, length) {\n        assert.ok(!this.request, 'Concurrent read operation?');\n        const readBuffer = this.s.read(length);\n        if (readBuffer) {\n            readBuffer.copy(buffer, offset);\n            return readBuffer.length;\n        }\n        else {\n            this.request = {\n                buffer,\n                offset,\n                length,\n                deferred: new Deferred()\n            };\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n            return this.request.deferred.promise.then(n => {\n                this.request = null;\n                return n;\n            }, err => {\n                this.request = null;\n                throw err;\n            });\n        }\n    }\n    tryRead() {\n        const readBuffer = this.s.read(this.request.length);\n        if (readBuffer) {\n            readBuffer.copy(this.request.buffer, this.request.offset);\n            this.request.deferred.resolve(readBuffer.length);\n        }\n        else {\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n        }\n    }\n    reject(err) {\n        this.endOfStream = true;\n        if (this.request) {\n            this.request.deferred.reject(err);\n            this.request = null;\n        }\n    }\n}\nexports.StreamReader = StreamReader;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGVlay1yZWFkYWJsZS9saWIvaW5kZXguanM/MjBmOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGVBQWUsbUJBQU8sQ0FBQyw4RUFBUTtBQUMvQiwwQkFBMEIsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDckQsd0JBQXdCLG1CQUFPLENBQUMsOEVBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3BlZWstcmVhZGFibGUvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgRW5kT2ZGaWxlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9FbmRPZkZpbGVTdHJlYW1cIik7XG52YXIgRW5kT2ZGaWxlU3RyZWFtXzIgPSByZXF1aXJlKFwiLi9FbmRPZkZpbGVTdHJlYW1cIik7XG5leHBvcnRzLkVuZE9mU3RyZWFtRXJyb3IgPSBFbmRPZkZpbGVTdHJlYW1fMi5FbmRPZlN0cmVhbUVycm9yO1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IG1heFN0cmVhbVJlYWRTaXplID0gMSAqIDEwMjQgKiAxMDI0OyAvLyBNYXhpbXVtIHJlcXVlc3QgbGVuZ3RoIG9uIHJlYWQtc3RyZWFtIG9wZXJhdGlvblxuY2xhc3MgU3RyZWFtUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuZW5kT2ZTdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIHBlZWtlZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVla1F1ZXVlID0gW107XG4gICAgICAgIGlmICghcy5yZWFkIHx8ICFzLm9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2Ygc3RyZWFtLlJlYWRhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zLm9uY2UoJ2VuZCcsICgpID0+IHRoaXMucmVqZWN0KG5ldyBFbmRPZkZpbGVTdHJlYW1fMS5FbmRPZlN0cmVhbUVycm9yKCkpKTtcbiAgICAgICAgdGhpcy5zLm9uY2UoJ2Vycm9yJywgZXJyID0+IHRoaXMucmVqZWN0KGVycikpO1xuICAgICAgICB0aGlzLnMub25jZSgnY2xvc2UnLCAoKSA9PiB0aGlzLnJlamVjdChuZXcgRXJyb3IoJ1N0cmVhbSBjbG9zZWQnKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFoZWFkIChwZWVrKSBmcm9tIHN0cmVhbS4gU3Vic2VxdWVudCByZWFkIG9yIHBlZWtzIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGRhdGFcbiAgICAgKiBAcGFyYW0gYnVmZmVyIC0gQnVmZmVyIHRvIHN0b3JlIGRhdGEgcmVhZCBmcm9tIHN0cmVhbSBpblxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgYnVmZmVyXG4gICAgICogQHBhcmFtIGxlbmd0aCAtIE51bWJlciBvZiBieXRlcyB0byByZWFkXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHBlZWtlZFxuICAgICAqL1xuICAgIGFzeW5jIHBlZWsoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBieXRlc1JlYWQgPSBhd2FpdCB0aGlzLnJlYWQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucGVla1F1ZXVlLnB1c2goYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXNSZWFkKSk7IC8vIFB1dCByZWFkIGRhdGEgYmFjayB0byBwZWVrIGJ1ZmZlclxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGNodW5rIGZyb20gc3RyZWFtXG4gICAgICogQHBhcmFtIGJ1ZmZlciAtIFRhcmdldCBidWZmZXIgdG8gc3RvcmUgZGF0YSByZWFkIGZyb20gc3RyZWFtIGluXG4gICAgICogQHBhcmFtIG9mZnNldCAtIE9mZnNldCBvZiB0YXJnZXQgYnVmZmVyXG4gICAgICogQHBhcmFtIGxlbmd0aCAtIE51bWJlciBvZiBieXRlcyB0byByZWFkXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAgICAgKi9cbiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVla1F1ZXVlLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmVuZE9mU3RyZWFtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW5kT2ZGaWxlU3RyZWFtXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBsZW5ndGg7XG4gICAgICAgIGxldCBieXRlc1JlYWQgPSAwO1xuICAgICAgICAvLyBjb25zdW1lIHBlZWtlZCBkYXRhIGZpcnN0XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWtRdWV1ZS5sZW5ndGggPiAwICYmIHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBlZWtEYXRhID0gdGhpcy5wZWVrUXVldWUucG9wKCk7IC8vIEZyb250IG9mIHF1ZXVlXG4gICAgICAgICAgICBjb25zdCBsZW5Db3B5ID0gTWF0aC5taW4ocGVla0RhdGEubGVuZ3RoLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgcGVla0RhdGEuY29weShidWZmZXIsIG9mZnNldCArIGJ5dGVzUmVhZCwgMCwgbGVuQ29weSk7XG4gICAgICAgICAgICBieXRlc1JlYWQgKz0gbGVuQ29weTtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBsZW5Db3B5O1xuICAgICAgICAgICAgaWYgKGxlbkNvcHkgPCBwZWVrRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1haW5kZXIgYmFjayB0byBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMucGVla1F1ZXVlLnB1c2gocGVla0RhdGEuc2xpY2UobGVuQ29weSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnRpbnVlIHJlYWRpbmcgZnJvbSBzdHJlYW0gaWYgcmVxdWlyZWRcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZyA+IDAgJiYgIXRoaXMuZW5kT2ZTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcUxlbiA9IE1hdGgubWluKHJlbWFpbmluZywgbWF4U3RyZWFtUmVhZFNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmtMZW4gPSBhd2FpdCB0aGlzLl9yZWFkKGJ1ZmZlciwgb2Zmc2V0ICsgYnl0ZXNSZWFkLCByZXFMZW4pO1xuICAgICAgICAgICAgYnl0ZXNSZWFkICs9IGNodW5rTGVuO1xuICAgICAgICAgICAgaWYgKGNodW5rTGVuIDwgcmVxTGVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmVtYWluaW5nIC09IGNodW5rTGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgY2h1bmsgZnJvbSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gYnVmZmVyIEJ1ZmZlciB0byBzdG9yZSBkYXRhIHJlYWQgZnJvbSBzdHJlYW0gaW5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBidWZmZXJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBhc3luYyBfcmVhZChidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydC5vayghdGhpcy5yZXF1ZXN0LCAnQ29uY3VycmVudCByZWFkIG9wZXJhdGlvbj8nKTtcbiAgICAgICAgY29uc3QgcmVhZEJ1ZmZlciA9IHRoaXMucy5yZWFkKGxlbmd0aCk7XG4gICAgICAgIGlmIChyZWFkQnVmZmVyKSB7XG4gICAgICAgICAgICByZWFkQnVmZmVyLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRCdWZmZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkOiBuZXcgRGVmZXJyZWQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucy5vbmNlKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC5kZWZlcnJlZC5wcm9taXNlLnRoZW4obiA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlSZWFkKCkge1xuICAgICAgICBjb25zdCByZWFkQnVmZmVyID0gdGhpcy5zLnJlYWQodGhpcy5yZXF1ZXN0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChyZWFkQnVmZmVyKSB7XG4gICAgICAgICAgICByZWFkQnVmZmVyLmNvcHkodGhpcy5yZXF1ZXN0LmJ1ZmZlciwgdGhpcy5yZXF1ZXN0Lm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuZGVmZXJyZWQucmVzb2x2ZShyZWFkQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnMub25jZSgncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWFkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWplY3QoZXJyKSB7XG4gICAgICAgIHRoaXMuZW5kT2ZTdHJlYW0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW1SZWFkZXIgPSBTdHJlYW1SZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/peek-readable/lib/index.js\n");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanM/OTY2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process-nextick-args/index.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzPzA5NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMscUZBQXlCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/duplex-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcz9iMTlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDBFQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2REFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsa0ZBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxrRkFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzPzc4MGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQXFCOztBQUU3QztBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZEQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 0);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzP2FkNzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdEQUFTO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsd0dBQTJCO0FBQ2hEOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxxRkFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZEQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsYUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHdHQUErQjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQyxrR0FBNEI7QUFDdEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNkVBQTZFO0FBQ3RKOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsOEVBQWtCOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDBGQUEwRjs7QUFFM0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLDRFQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFrQjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtHQUFrRztBQUNsRyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcz8yN2JmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFdkM7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2REFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzP2RjMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDBFQUFzQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsNkRBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDaEQ7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHFGQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLGtHQUE0Qjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsOEVBQWtCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 1);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanM/NWUxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixhQUFhLG1CQUFPLENBQUMscUZBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGFBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/BufferList.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanM/NDY4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzPzQyOWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsK0NBQVEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/node_modules/safe-buffer/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/readable-stream/node_modules/safe-buffer/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcz9hOGYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZFQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzP2MyYWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/passthrough.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanM/ZTM3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBMkI7QUFDOUQ7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHlGQUEyQjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsMkZBQTRCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLCtGQUE4QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/readable-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcz9kMTdiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFZIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/transform.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanM/MmM2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/writable-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-web-to-node-stream/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-web-to-node-stream/lib/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\");\n/**\n * Converts a Web-API stream into Node stream.Readable class\n * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams\n * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams\n */\nclass ReadableWebToNodeStream extends stream_1.Readable {\n    /**\n     *\n     * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n     */\n    constructor(stream) {\n        super();\n        this.bytesRead = 0;\n        this.released = false;\n        this.reader = stream.getReader();\n    }\n    /**\n     * Implementation of readable._read(size).\n     * When readable._read() is called, if data is available from the resource,\n     * the implementation should begin pushing that data into the read queue\n     * https://nodejs.org/api/stream.html#stream_readable_read_size_1\n     */\n    async _read() {\n        // Should start pushing data into the queue\n        // Read data from the underlying Web-API-readable-stream\n        if (this.released) {\n            this.push(null); // Signal EOF\n            return;\n        }\n        this.pendingRead = this.reader.read();\n        const data = await this.pendingRead;\n        // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()\n        delete this.pendingRead;\n        if (data.done || this.released) {\n            this.push(null); // Signal EOF\n        }\n        else {\n            this.bytesRead += data.value.length;\n            this.push(data.value); // Push new data to the queue\n        }\n    }\n    /**\n     * If there is no unresolved read call to Web-API Readable​Stream immediately returns;\n     * otherwise will wait until the read is resolved.\n     */\n    async waitForReadToComplete() {\n        if (this.pendingRead) {\n            await this.pendingRead;\n        }\n    }\n    /**\n     * Close wrapper\n     */\n    async close() {\n        await this.syncAndRelease();\n    }\n    async syncAndRelease() {\n        this.released = true;\n        await this.waitForReadToComplete();\n        await this.reader.releaseLock();\n    }\n}\nexports.ReadableWebToNodeStream = ReadableWebToNodeStream;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtd2ViLXRvLW5vZGUtc3RyZWFtL2xpYi9pbmRleC5qcz81Y2YwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsaUJBQWlCLG1CQUFPLENBQUMseURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS13ZWItdG8tbm9kZS1zdHJlYW0vbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4vKipcbiAqIENvbnZlcnRzIGEgV2ViLUFQSSBzdHJlYW0gaW50byBOb2RlIHN0cmVhbS5SZWFkYWJsZSBjbGFzc1xuICogTm9kZSBzdHJlYW0gcmVhZGFibGU6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3N0cmVhbXNcbiAqIFdlYiBBUEkgcmVhZGFibGUtc3RyZWFtOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW1cbiAqIE5vZGUgcmVhZGFibGUgc3RyZWFtOiBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9zdHJlYW1zXG4gKi9cbmNsYXNzIFJlYWRhYmxlV2ViVG9Ob2RlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmVhbSBSZWFkYWJsZeKAi1N0cmVhbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgcmVhZGFibGUuX3JlYWQoc2l6ZSkuXG4gICAgICogV2hlbiByZWFkYWJsZS5fcmVhZCgpIGlzIGNhbGxlZCwgaWYgZGF0YSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgcmVzb3VyY2UsXG4gICAgICogdGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZWdpbiBwdXNoaW5nIHRoYXQgZGF0YSBpbnRvIHRoZSByZWFkIHF1ZXVlXG4gICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcmVhZF9zaXplXzFcbiAgICAgKi9cbiAgICBhc3luYyBfcmVhZCgpIHtcbiAgICAgICAgLy8gU2hvdWxkIHN0YXJ0IHB1c2hpbmcgZGF0YSBpbnRvIHRoZSBxdWV1ZVxuICAgICAgICAvLyBSZWFkIGRhdGEgZnJvbSB0aGUgdW5kZXJseWluZyBXZWItQVBJLXJlYWRhYmxlLXN0cmVhbVxuICAgICAgICBpZiAodGhpcy5yZWxlYXNlZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpOyAvLyBTaWduYWwgRU9GXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVhZCA9IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucGVuZGluZ1JlYWQ7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBwcm9taXNlIGJlZm9yZSBwdXNoaW5nIHB1c2hpbmcgbmV3IGRhdGEgdG8gdGhlIHF1ZXVlIGFuZCBhbGxvdyBzZXF1ZW50aWFsIGNhbGxzIHRvIF9yZWFkKClcbiAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlYWQ7XG4gICAgICAgIGlmIChkYXRhLmRvbmUgfHwgdGhpcy5yZWxlYXNlZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpOyAvLyBTaWduYWwgRU9GXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzUmVhZCArPSBkYXRhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucHVzaChkYXRhLnZhbHVlKTsgLy8gUHVzaCBuZXcgZGF0YSB0byB0aGUgcXVldWVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBubyB1bnJlc29sdmVkIHJlYWQgY2FsbCB0byBXZWItQVBJIFJlYWRhYmxl4oCLU3RyZWFtIGltbWVkaWF0ZWx5IHJldHVybnM7XG4gICAgICogb3RoZXJ3aXNlIHdpbGwgd2FpdCB1bnRpbCB0aGUgcmVhZCBpcyByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yUmVhZFRvQ29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWFkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBlbmRpbmdSZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHdyYXBwZXJcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zeW5jQW5kUmVsZWFzZSgpO1xuICAgIH1cbiAgICBhc3luYyBzeW5jQW5kUmVsZWFzZSgpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvclJlYWRUb0NvbXBsZXRlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVdlYlRvTm9kZVN0cmVhbSA9IFJlYWRhYmxlV2ViVG9Ob2RlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-web-to-node-stream/lib/index.js\n");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanM/ODcwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZFQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanM/ZDQ4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQywrQ0FBUTtBQUN6QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUZBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFnQzs7QUFFN0Q7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stream-browserify/index.js\n");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzPzdkNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0Msc0NBQXNDO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/string_decoder/lib/string_decoder.js\n");

/***/ }),

/***/ "./node_modules/strtok3/lib/AbstractTokenizer.js":
/*!*******************************************************!*\
  !*** ./node_modules/strtok3/lib/AbstractTokenizer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractTokenizer = void 0;\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"./node_modules/peek-readable/lib/index.js\");\n/**\n * Core tokenizer\n */\nclass AbstractTokenizer {\n    constructor(fileInfo) {\n        /**\n         * Tokenizer-stream position\n         */\n        this.position = 0;\n        this.numBuffer = Buffer.alloc(10);\n        this.fileInfo = fileInfo ? fileInfo : {};\n    }\n    /**\n     * Read a token from the tokenizer-stream\n     * @param token - The token to read\n     * @param position - If provided, the desired position in the tokenizer-stream\n     * @returns Promise with token data\n     */\n    async readToken(token, position) {\n        const buffer = Buffer.alloc(token.len);\n        const len = await this.readBuffer(buffer, { position });\n        if (len < token.len)\n            throw new peek_readable_1.EndOfStreamError();\n        return token.get(buffer, 0);\n    }\n    /**\n     * Peek a token from the tokenizer-stream.\n     * @param token - Token to peek from the tokenizer-stream.\n     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.\n     * @returns Promise with token data\n     */\n    async peekToken(token, position = this.position) {\n        const buffer = Buffer.alloc(token.len);\n        const len = await this.peekBuffer(buffer, { position });\n        if (len < token.len)\n            throw new peek_readable_1.EndOfStreamError();\n        return token.get(buffer, 0);\n    }\n    /**\n     * Read a numeric token from the stream\n     * @param token - Numeric token\n     * @returns Promise with number\n     */\n    async readNumber(token) {\n        const len = await this.readBuffer(this.numBuffer, { length: token.len });\n        if (len < token.len)\n            throw new peek_readable_1.EndOfStreamError();\n        return token.get(this.numBuffer, 0);\n    }\n    /**\n     * Read a numeric token from the stream\n     * @param token - Numeric token\n     * @returns Promise with number\n     */\n    async peekNumber(token) {\n        const len = await this.peekBuffer(this.numBuffer, { length: token.len });\n        if (len < token.len)\n            throw new peek_readable_1.EndOfStreamError();\n        return token.get(this.numBuffer, 0);\n    }\n    async close() {\n        // empty\n    }\n}\nexports.AbstractTokenizer = AbstractTokenizer;\n//# sourceMappingURL=AbstractTokenizer.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvQWJzdHJhY3RUb2tlbml6ZXIuanM/YTA0NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsZ0VBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9CQUFvQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvQWJzdHJhY3RUb2tlbml6ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RUb2tlbml6ZXIgPSB2b2lkIDA7XG5jb25zdCBwZWVrX3JlYWRhYmxlXzEgPSByZXF1aXJlKFwicGVlay1yZWFkYWJsZVwiKTtcbi8qKlxuICogQ29yZSB0b2tlbml6ZXJcbiAqL1xuY2xhc3MgQWJzdHJhY3RUb2tlbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVJbmZvKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2tlbml6ZXItc3RyZWFtIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5udW1CdWZmZXIgPSBCdWZmZXIuYWxsb2MoMTApO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gZmlsZUluZm8gPyBmaWxlSW5mbyA6IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgdG9rZW4gZnJvbSB0aGUgdG9rZW5pemVyLXN0cmVhbVxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRoZSB0b2tlbiB0byByZWFkXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gSWYgcHJvdmlkZWQsIHRoZSBkZXNpcmVkIHBvc2l0aW9uIGluIHRoZSB0b2tlbml6ZXItc3RyZWFtXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRva2VuIGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyByZWFkVG9rZW4odG9rZW4sIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0b2tlbi5sZW4pO1xuICAgICAgICBjb25zdCBsZW4gPSBhd2FpdCB0aGlzLnJlYWRCdWZmZXIoYnVmZmVyLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICBpZiAobGVuIDwgdG9rZW4ubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgIHJldHVybiB0b2tlbi5nZXQoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVlayBhIHRva2VuIGZyb20gdGhlIHRva2VuaXplci1zdHJlYW0uXG4gICAgICogQHBhcmFtIHRva2VuIC0gVG9rZW4gdG8gcGVlayBmcm9tIHRoZSB0b2tlbml6ZXItc3RyZWFtLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIE9mZnNldCB3aGVyZSB0byBiZWdpbiByZWFkaW5nIHdpdGhpbiB0aGUgZmlsZS4gSWYgcG9zaXRpb24gaXMgbnVsbCwgZGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0b2tlbiBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgcGVla1Rva2VuKHRva2VuLCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHRva2VuLmxlbik7XG4gICAgICAgIGNvbnN0IGxlbiA9IGF3YWl0IHRoaXMucGVla0J1ZmZlcihidWZmZXIsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIGlmIChsZW4gPCB0b2tlbi5sZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuLmdldChidWZmZXIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgbnVtZXJpYyB0b2tlbiBmcm9tIHRoZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBOdW1lcmljIHRva2VuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIG51bWJlclxuICAgICAqL1xuICAgIGFzeW5jIHJlYWROdW1iZXIodG9rZW4pIHtcbiAgICAgICAgY29uc3QgbGVuID0gYXdhaXQgdGhpcy5yZWFkQnVmZmVyKHRoaXMubnVtQnVmZmVyLCB7IGxlbmd0aDogdG9rZW4ubGVuIH0pO1xuICAgICAgICBpZiAobGVuIDwgdG9rZW4ubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgIHJldHVybiB0b2tlbi5nZXQodGhpcy5udW1CdWZmZXIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgbnVtZXJpYyB0b2tlbiBmcm9tIHRoZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBOdW1lcmljIHRva2VuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIG51bWJlclxuICAgICAqL1xuICAgIGFzeW5jIHBlZWtOdW1iZXIodG9rZW4pIHtcbiAgICAgICAgY29uc3QgbGVuID0gYXdhaXQgdGhpcy5wZWVrQnVmZmVyKHRoaXMubnVtQnVmZmVyLCB7IGxlbmd0aDogdG9rZW4ubGVuIH0pO1xuICAgICAgICBpZiAobGVuIDwgdG9rZW4ubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgIHJldHVybiB0b2tlbi5nZXQodGhpcy5udW1CdWZmZXIsIDApO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gZW1wdHlcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0VG9rZW5pemVyID0gQWJzdHJhY3RUb2tlbml6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdFRva2VuaXplci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/strtok3/lib/AbstractTokenizer.js\n");

/***/ }),

/***/ "./node_modules/strtok3/lib/BufferTokenizer.js":
/*!*****************************************************!*\
  !*** ./node_modules/strtok3/lib/BufferTokenizer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BufferTokenizer = void 0;\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"./node_modules/peek-readable/lib/index.js\");\nclass BufferTokenizer {\n    /**\n     * Construct BufferTokenizer\n     * @param buffer - Buffer to tokenize\n     * @param fileInfo - Pass additional file information to the tokenizer\n     */\n    constructor(buffer, fileInfo) {\n        this.buffer = buffer;\n        this.position = 0;\n        this.fileInfo = fileInfo ? fileInfo : {};\n        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : buffer.length;\n    }\n    /**\n     * Read buffer from tokenizer\n     * @param buffer\n     * @param options - Read behaviour options\n     * @returns {Promise<number>}\n     */\n    async readBuffer(buffer, options) {\n        if (options && options.position) {\n            if (options.position < this.position) {\n                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n            }\n            this.position = options.position;\n        }\n        return this.peekBuffer(buffer, options).then(bytesRead => {\n            this.position += bytesRead;\n            return bytesRead;\n        });\n    }\n    /**\n     * Peek (read ahead) buffer from tokenizer\n     * @param buffer\n     * @param options - Read behaviour options\n     * @returns {Promise<number>}\n     */\n    async peekBuffer(buffer, options) {\n        let offset = 0;\n        let length = buffer.length;\n        let position = this.position;\n        if (options) {\n            if (options.position) {\n                if (options.position < this.position) {\n                    throw new Error('`options.position` can be less than `tokenizer.position`');\n                }\n                position = options.position;\n            }\n            if (Number.isInteger(options.length)) {\n                length = options.length;\n            }\n            else {\n                length -= options.offset || 0;\n            }\n            if (options.offset) {\n                offset = options.offset;\n            }\n        }\n        if (length === 0) {\n            return Promise.resolve(0);\n        }\n        position = position || this.position;\n        if (!length) {\n            length = buffer.length;\n        }\n        const bytes2read = Math.min(this.buffer.length - position, length);\n        if ((!options || !options.mayBeLess) && bytes2read < length) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        else {\n            this.buffer.copy(buffer, offset, position, position + bytes2read);\n            return bytes2read;\n        }\n    }\n    async readToken(token, position) {\n        this.position = position || this.position;\n        try {\n            const tv = this.peekToken(token, this.position);\n            this.position += token.len;\n            return tv;\n        }\n        catch (err) {\n            this.position += this.buffer.length - position;\n            throw err;\n        }\n    }\n    async peekToken(token, position = this.position) {\n        if (this.buffer.length - position < token.len) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        return token.get(this.buffer, position);\n    }\n    async readNumber(token) {\n        return this.readToken(token);\n    }\n    async peekNumber(token) {\n        return this.peekToken(token);\n    }\n    /**\n     * @return actual number of bytes ignored\n     */\n    async ignore(length) {\n        const bytesIgnored = Math.min(this.buffer.length - this.position, length);\n        this.position += bytesIgnored;\n        return bytesIgnored;\n    }\n    async close() {\n        // empty\n    }\n}\nexports.BufferTokenizer = BufferTokenizer;\n//# sourceMappingURL=BufferTokenizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvQnVmZmVyVG9rZW5pemVyLmpzPzM3N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLGdFQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHJ0b2szL2xpYi9CdWZmZXJUb2tlbml6ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnVmZmVyVG9rZW5pemVyID0gdm9pZCAwO1xuY29uc3QgcGVla19yZWFkYWJsZV8xID0gcmVxdWlyZShcInBlZWstcmVhZGFibGVcIik7XG5jbGFzcyBCdWZmZXJUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBCdWZmZXJUb2tlbml6ZXJcbiAgICAgKiBAcGFyYW0gYnVmZmVyIC0gQnVmZmVyIHRvIHRva2VuaXplXG4gICAgICogQHBhcmFtIGZpbGVJbmZvIC0gUGFzcyBhZGRpdGlvbmFsIGZpbGUgaW5mb3JtYXRpb24gdG8gdGhlIHRva2VuaXplclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgZmlsZUluZm8pIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gZmlsZUluZm8gPyBmaWxlSW5mbyA6IHt9O1xuICAgICAgICB0aGlzLmZpbGVJbmZvLnNpemUgPSB0aGlzLmZpbGVJbmZvLnNpemUgPyB0aGlzLmZpbGVJbmZvLnNpemUgOiBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBmcm9tIHRva2VuaXplclxuICAgICAqIEBwYXJhbSBidWZmZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlYWQgYmVoYXZpb3VyIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRCdWZmZXIoYnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uIDwgdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucG9zaXRpb25gIG11c3QgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIGB0b2tlbml6ZXIucG9zaXRpb25gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wZWVrQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucykudGhlbihieXRlc1JlYWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVlayAocmVhZCBhaGVhZCkgYnVmZmVyIGZyb20gdG9rZW5pemVyXG4gICAgICogQHBhcmFtIGJ1ZmZlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVhZCBiZWhhdmlvdXIgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgYXN5bmMgcGVla0J1ZmZlcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA8IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgb3B0aW9ucy5wb3NpdGlvbmAgY2FuIGJlIGxlc3MgdGhhbiBgdG9rZW5pemVyLnBvc2l0aW9uYCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzMnJlYWQgPSBNYXRoLm1pbih0aGlzLmJ1ZmZlci5sZW5ndGggLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5tYXlCZUxlc3MpICYmIGJ5dGVzMnJlYWQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwZWVrX3JlYWRhYmxlXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuY29weShidWZmZXIsIG9mZnNldCwgcG9zaXRpb24sIHBvc2l0aW9uICsgYnl0ZXMycmVhZCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXMycmVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkVG9rZW4odG9rZW4sIHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHYgPSB0aGlzLnBlZWtUb2tlbih0b2tlbiwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHRva2VuLmxlbjtcbiAgICAgICAgICAgIHJldHVybiB0djtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBlZWtUb2tlbih0b2tlbiwgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSBwb3NpdGlvbiA8IHRva2VuLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuLmdldCh0aGlzLmJ1ZmZlciwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZWFkTnVtYmVyKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbih0b2tlbik7XG4gICAgfVxuICAgIGFzeW5jIHBlZWtOdW1iZXIodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVla1Rva2VuKHRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIGlnbm9yZWRcbiAgICAgKi9cbiAgICBhc3luYyBpZ25vcmUobGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzSWdub3JlZCA9IE1hdGgubWluKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMucG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXNJZ25vcmVkO1xuICAgICAgICByZXR1cm4gYnl0ZXNJZ25vcmVkO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gZW1wdHlcbiAgICB9XG59XG5leHBvcnRzLkJ1ZmZlclRva2VuaXplciA9IEJ1ZmZlclRva2VuaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclRva2VuaXplci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/strtok3/lib/BufferTokenizer.js\n");

/***/ }),

/***/ "./node_modules/strtok3/lib/ReadStreamTokenizer.js":
/*!*********************************************************!*\
  !*** ./node_modules/strtok3/lib/ReadStreamTokenizer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadStreamTokenizer = void 0;\nconst AbstractTokenizer_1 = __webpack_require__(/*! ./AbstractTokenizer */ \"./node_modules/strtok3/lib/AbstractTokenizer.js\");\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"./node_modules/peek-readable/lib/index.js\");\n// import * as _debug from 'debug';\n// const debug = _debug('strtok3:ReadStreamTokenizer');\nconst maxBufferSize = 256000;\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\n    constructor(stream, fileInfo) {\n        super(fileInfo);\n        this.streamReader = new peek_readable_1.StreamReader(stream);\n    }\n    /**\n     * Get file information, an HTTP-client may implement this doing a HEAD request\n     * @return Promise with file information\n     */\n    async getFileInfo() {\n        return this.fileInfo;\n    }\n    /**\n     * Read buffer from tokenizer\n     * @param buffer - Target buffer to fill with data read from the tokenizer-stream\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes read\n     */\n    async readBuffer(buffer, options) {\n        // const _offset = position ? position : this.position;\n        // debug(`readBuffer ${_offset}...${_offset + length - 1}`);\n        let offset = 0;\n        let length = buffer.length;\n        if (options) {\n            if (Number.isInteger(options.length)) {\n                length = options.length;\n            }\n            else {\n                length -= options.offset || 0;\n            }\n            if (options.position) {\n                const skipBytes = options.position - this.position;\n                if (skipBytes > 0) {\n                    await this.ignore(skipBytes);\n                    return this.readBuffer(buffer, options);\n                }\n                else if (skipBytes < 0) {\n                    throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n                }\n            }\n            if (options.offset) {\n                offset = options.offset;\n            }\n        }\n        if (length === 0) {\n            return 0;\n        }\n        const bytesRead = await this.streamReader.read(buffer, offset, length);\n        this.position += bytesRead;\n        if ((!options || !options.mayBeLess) && bytesRead < length) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    /**\n     * Peek (read ahead) buffer from tokenizer\n     * @param buffer - Target buffer to write the data read to\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes peeked\n     */\n    async peekBuffer(buffer, options) {\n        // const _offset = position ? position : this.position;\n        // debug(`peek ${_offset}...${_offset + length - 1}`);\n        let offset = 0;\n        let bytesRead;\n        let length = buffer.length;\n        if (options) {\n            if (options.offset) {\n                offset = options.offset;\n            }\n            if (Number.isInteger(options.length)) {\n                length = options.length;\n            }\n            else {\n                length -= options.offset || 0;\n            }\n            if (options.position) {\n                const skipBytes = options.position - this.position;\n                if (skipBytes > 0) {\n                    const skipBuffer = Buffer.alloc(length + skipBytes);\n                    bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: options.mayBeLess });\n                    skipBuffer.copy(buffer, offset, skipBytes);\n                    return bytesRead - skipBytes;\n                }\n                else if (skipBytes < 0) {\n                    throw new Error('Cannot peek from a negative offset in a stream');\n                }\n            }\n        }\n        try {\n            bytesRead = await this.streamReader.peek(buffer, offset, length);\n        }\n        catch (err) {\n            if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\n                return 0;\n            }\n            throw err;\n        }\n        if ((!options || !options.mayBeLess) && bytesRead < length) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    async ignore(length) {\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\n        const bufSize = Math.min(maxBufferSize, length);\n        const buf = Buffer.alloc(bufSize);\n        let totBytesRead = 0;\n        while (totBytesRead < length) {\n            const remaining = length - totBytesRead;\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\n            if (bytesRead < 0) {\n                return bytesRead;\n            }\n            totBytesRead += bytesRead;\n        }\n        return totBytesRead;\n    }\n}\nexports.ReadStreamTokenizer = ReadStreamTokenizer;\n//# sourceMappingURL=ReadStreamTokenizer.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvUmVhZFN0cmVhbVRva2VuaXplci5qcz8xZTQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyw0RUFBcUI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsZ0VBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRLEtBQUsscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxLQUFLLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLCtCQUErQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsS0FBSywyQkFBMkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvUmVhZFN0cmVhbVRva2VuaXplci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkU3RyZWFtVG9rZW5pemVyID0gdm9pZCAwO1xuY29uc3QgQWJzdHJhY3RUb2tlbml6ZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0VG9rZW5pemVyXCIpO1xuY29uc3QgcGVla19yZWFkYWJsZV8xID0gcmVxdWlyZShcInBlZWstcmVhZGFibGVcIik7XG4vLyBpbXBvcnQgKiBhcyBfZGVidWcgZnJvbSAnZGVidWcnO1xuLy8gY29uc3QgZGVidWcgPSBfZGVidWcoJ3N0cnRvazM6UmVhZFN0cmVhbVRva2VuaXplcicpO1xuY29uc3QgbWF4QnVmZmVyU2l6ZSA9IDI1NjAwMDtcbmNsYXNzIFJlYWRTdHJlYW1Ub2tlbml6ZXIgZXh0ZW5kcyBBYnN0cmFjdFRva2VuaXplcl8xLkFic3RyYWN0VG9rZW5pemVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGZpbGVJbmZvKSB7XG4gICAgICAgIHN1cGVyKGZpbGVJbmZvKTtcbiAgICAgICAgdGhpcy5zdHJlYW1SZWFkZXIgPSBuZXcgcGVla19yZWFkYWJsZV8xLlN0cmVhbVJlYWRlcihzdHJlYW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBpbmZvcm1hdGlvbiwgYW4gSFRUUC1jbGllbnQgbWF5IGltcGxlbWVudCB0aGlzIGRvaW5nIGEgSEVBRCByZXF1ZXN0XG4gICAgICogQHJldHVybiBQcm9taXNlIHdpdGggZmlsZSBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlSW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgZnJvbSB0b2tlbml6ZXJcbiAgICAgKiBAcGFyYW0gYnVmZmVyIC0gVGFyZ2V0IGJ1ZmZlciB0byBmaWxsIHdpdGggZGF0YSByZWFkIGZyb20gdGhlIHRva2VuaXplci1zdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlYWQgYmVoYXZpb3VyIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAgICAgKi9cbiAgICBhc3luYyByZWFkQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBjb25zdCBfb2Zmc2V0ID0gcG9zaXRpb24gPyBwb3NpdGlvbiA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIC8vIGRlYnVnKGByZWFkQnVmZmVyICR7X29mZnNldH0uLi4ke19vZmZzZXQgKyBsZW5ndGggLSAxfWApO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwQnl0ZXMgPSBvcHRpb25zLnBvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcEJ5dGVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmlnbm9yZShza2lwQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNraXBCeXRlcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgb3B0aW9ucy5wb3NpdGlvbmAgbXVzdCBiZSBlcXVhbCBvciBncmVhdGVyIHRoYW4gYHRva2VuaXplci5wb3NpdGlvbmAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlc1JlYWQgPSBhd2FpdCB0aGlzLnN0cmVhbVJlYWRlci5yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5tYXlCZUxlc3MpICYmIGJ5dGVzUmVhZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVlayAocmVhZCBhaGVhZCkgYnVmZmVyIGZyb20gdG9rZW5pemVyXG4gICAgICogQHBhcmFtIGJ1ZmZlciAtIFRhcmdldCBidWZmZXIgdG8gd3JpdGUgdGhlIGRhdGEgcmVhZCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVhZCBiZWhhdmlvdXIgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBudW1iZXIgb2YgYnl0ZXMgcGVla2VkXG4gICAgICovXG4gICAgYXN5bmMgcGVla0J1ZmZlcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29uc3QgX29mZnNldCA9IHBvc2l0aW9uID8gcG9zaXRpb24gOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAvLyBkZWJ1ZyhgcGVlayAke19vZmZzZXR9Li4uJHtfb2Zmc2V0ICsgbGVuZ3RoIC0gMX1gKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBieXRlc1JlYWQ7XG4gICAgICAgIGxldCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwQnl0ZXMgPSBvcHRpb25zLnBvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcEJ5dGVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lwQnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbmd0aCArIHNraXBCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMucGVla0J1ZmZlcihza2lwQnVmZmVyLCB7IG1heUJlTGVzczogb3B0aW9ucy5tYXlCZUxlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBCdWZmZXIuY29weShidWZmZXIsIG9mZnNldCwgc2tpcEJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZCAtIHNraXBCeXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2tpcEJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZWVrIGZyb20gYSBuZWdhdGl2ZSBvZmZzZXQgaW4gYSBzdHJlYW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMuc3RyZWFtUmVhZGVyLnBlZWsoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXlCZUxlc3MgJiYgZXJyIGluc3RhbmNlb2YgcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLm1heUJlTGVzcykgJiYgYnl0ZXNSZWFkIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgIH1cbiAgICBhc3luYyBpZ25vcmUobGVuZ3RoKSB7XG4gICAgICAgIC8vIGRlYnVnKGBpZ25vcmUgJHt0aGlzLnBvc2l0aW9ufS4uLiR7dGhpcy5wb3NpdGlvbiArIGxlbmd0aCAtIDF9YCk7XG4gICAgICAgIGNvbnN0IGJ1ZlNpemUgPSBNYXRoLm1pbihtYXhCdWZmZXJTaXplLCBsZW5ndGgpO1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoYnVmU2l6ZSk7XG4gICAgICAgIGxldCB0b3RCeXRlc1JlYWQgPSAwO1xuICAgICAgICB3aGlsZSAodG90Qnl0ZXNSZWFkIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBsZW5ndGggLSB0b3RCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBieXRlc1JlYWQgPSBhd2FpdCB0aGlzLnJlYWRCdWZmZXIoYnVmLCB7IGxlbmd0aDogTWF0aC5taW4oYnVmU2l6ZSwgcmVtYWluaW5nKSB9KTtcbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdEJ5dGVzUmVhZCArPSBieXRlc1JlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdEJ5dGVzUmVhZDtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRTdHJlYW1Ub2tlbml6ZXIgPSBSZWFkU3RyZWFtVG9rZW5pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhZFN0cmVhbVRva2VuaXplci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/strtok3/lib/ReadStreamTokenizer.js\n");

/***/ }),

/***/ "./node_modules/strtok3/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/strtok3/lib/core.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromBuffer = exports.fromStream = void 0;\nconst ReadStreamTokenizer_1 = __webpack_require__(/*! ./ReadStreamTokenizer */ \"./node_modules/strtok3/lib/ReadStreamTokenizer.js\");\nconst BufferTokenizer_1 = __webpack_require__(/*! ./BufferTokenizer */ \"./node_modules/strtok3/lib/BufferTokenizer.js\");\nvar peek_readable_1 = __webpack_require__(/*! peek-readable */ \"./node_modules/peek-readable/lib/index.js\");\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return peek_readable_1.EndOfStreamError; } });\n/**\n * Construct ReadStreamTokenizer from given Stream.\n * Will set fileSize, if provided given Stream has set the .path property/\n * @param stream - Read from Node.js Stream.Readable\n * @param fileInfo - Pass the file information, like size and MIME-type of the correspnding stream.\n * @returns ReadStreamTokenizer\n */\nfunction fromStream(stream, fileInfo) {\n    fileInfo = fileInfo ? fileInfo : {};\n    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);\n}\nexports.fromStream = fromStream;\n/**\n * Construct ReadStreamTokenizer from given Buffer.\n * @param buffer - Buffer to tokenize\n * @param fileInfo - Pass additional file information to the tokenizer\n * @returns BufferTokenizer\n */\nfunction fromBuffer(buffer, fileInfo) {\n    return new BufferTokenizer_1.BufferTokenizer(buffer, fileInfo);\n}\nexports.fromBuffer = fromBuffer;\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvY29yZS5qcz8yMWMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyxnRkFBdUI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsd0VBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLGdFQUFlO0FBQzdDLG9EQUFvRCxxQ0FBcUMseUNBQXlDLEVBQUUsRUFBRTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0cnRvazMvbGliL2NvcmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IFJlYWRTdHJlYW1Ub2tlbml6ZXJfMSA9IHJlcXVpcmUoXCIuL1JlYWRTdHJlYW1Ub2tlbml6ZXJcIik7XG5jb25zdCBCdWZmZXJUb2tlbml6ZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclRva2VuaXplclwiKTtcbnZhciBwZWVrX3JlYWRhYmxlXzEgPSByZXF1aXJlKFwicGVlay1yZWFkYWJsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuZE9mU3RyZWFtRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yOyB9IH0pO1xuLyoqXG4gKiBDb25zdHJ1Y3QgUmVhZFN0cmVhbVRva2VuaXplciBmcm9tIGdpdmVuIFN0cmVhbS5cbiAqIFdpbGwgc2V0IGZpbGVTaXplLCBpZiBwcm92aWRlZCBnaXZlbiBTdHJlYW0gaGFzIHNldCB0aGUgLnBhdGggcHJvcGVydHkvXG4gKiBAcGFyYW0gc3RyZWFtIC0gUmVhZCBmcm9tIE5vZGUuanMgU3RyZWFtLlJlYWRhYmxlXG4gKiBAcGFyYW0gZmlsZUluZm8gLSBQYXNzIHRoZSBmaWxlIGluZm9ybWF0aW9uLCBsaWtlIHNpemUgYW5kIE1JTUUtdHlwZSBvZiB0aGUgY29ycmVzcG5kaW5nIHN0cmVhbS5cbiAqIEByZXR1cm5zIFJlYWRTdHJlYW1Ub2tlbml6ZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVN0cmVhbShzdHJlYW0sIGZpbGVJbmZvKSB7XG4gICAgZmlsZUluZm8gPSBmaWxlSW5mbyA/IGZpbGVJbmZvIDoge307XG4gICAgcmV0dXJuIG5ldyBSZWFkU3RyZWFtVG9rZW5pemVyXzEuUmVhZFN0cmVhbVRva2VuaXplcihzdHJlYW0sIGZpbGVJbmZvKTtcbn1cbmV4cG9ydHMuZnJvbVN0cmVhbSA9IGZyb21TdHJlYW07XG4vKipcbiAqIENvbnN0cnVjdCBSZWFkU3RyZWFtVG9rZW5pemVyIGZyb20gZ2l2ZW4gQnVmZmVyLlxuICogQHBhcmFtIGJ1ZmZlciAtIEJ1ZmZlciB0byB0b2tlbml6ZVxuICogQHBhcmFtIGZpbGVJbmZvIC0gUGFzcyBhZGRpdGlvbmFsIGZpbGUgaW5mb3JtYXRpb24gdG8gdGhlIHRva2VuaXplclxuICogQHJldHVybnMgQnVmZmVyVG9rZW5pemVyXG4gKi9cbmZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyLCBmaWxlSW5mbykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyVG9rZW5pemVyXzEuQnVmZmVyVG9rZW5pemVyKGJ1ZmZlciwgZmlsZUluZm8pO1xufVxuZXhwb3J0cy5mcm9tQnVmZmVyID0gZnJvbUJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/strtok3/lib/core.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLGlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/token-types/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/token-types/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n// Primitive types\n/**\n * 8-bit unsigned integer\n */\nexports.UINT8 = {\n    len: 1,\n    get(buf, off) {\n        return buf.readUInt8(off);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUInt8(v, off);\n    }\n};\n/**\n * 16-bit unsigned integer, Little Endian byte order\n */\nexports.UINT16_LE = {\n    len: 2,\n    get(buf, off) {\n        return buf.readUInt16LE(off);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUInt16LE(v, off);\n    }\n};\n/**\n * 16-bit unsigned integer, Big Endian byte order\n */\nexports.UINT16_BE = {\n    len: 2,\n    get(buf, off) {\n        return buf.readUInt16BE(off);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUInt16BE(v, off);\n    }\n};\n/**\n * 24-bit unsigned integer, Little Endian byte order\n */\nexports.UINT24_LE = {\n    len: 3,\n    get(buf, off) {\n        return buf.readUIntLE(off, 3);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUIntLE(v, off, 3);\n    }\n};\n/**\n * 24-bit unsigned integer, Big Endian byte order\n */\nexports.UINT24_BE = {\n    len: 3,\n    get(buf, off) {\n        return buf.readUIntBE(off, 3);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUIntBE(v, off, 3);\n    }\n};\n/**\n * 32-bit unsigned integer, Little Endian byte order\n */\nexports.UINT32_LE = {\n    len: 4,\n    get(buf, off) {\n        return buf.readUInt32LE(off);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeUInt32LE(v, o);\n    }\n};\n/**\n * 32-bit unsigned integer, Big Endian byte order\n */\nexports.UINT32_BE = {\n    len: 4,\n    get(buf, off) {\n        return buf.readUInt32BE(off);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffffff);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeUInt32BE(v, off);\n    }\n};\n/**\n * 8-bit signed integer\n */\nexports.INT8 = {\n    len: 1,\n    get(buf, off) {\n        return buf.readInt8(off);\n    },\n    put(buf, off, v) {\n        assert.equal(typeof off, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -128 && v <= 127);\n        assert.ok(off >= 0);\n        assert.ok(this.len <= buf.length);\n        return buf.writeInt8(v, off);\n    }\n};\n/**\n * 16-bit signed integer, Big Endian byte order\n */\nexports.INT16_BE = {\n    len: 2,\n    get(buf, off) {\n        return buf.readInt16BE(off);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -32768 && v <= 32767);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeInt16BE(v, o);\n    }\n};\n/**\n * 16-bit signed integer, Little Endian byte order\n */\nexports.INT16_LE = {\n    len: 2,\n    get(buf, off) {\n        return buf.readInt16LE(off);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -32768 && v <= 32767);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeInt16LE(v, o);\n    }\n};\n/**\n * 24-bit signed integer, Little Endian byte order\n */\nexports.INT24_LE = {\n    len: 3,\n    get(buf, off) {\n        return buf.readIntLE(off, 3);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -0x800000 && v <= 0x7fffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeIntLE(v, o, 3);\n    }\n};\n/**\n * 24-bit signed integer, Big Endian byte order\n */\nexports.INT24_BE = {\n    len: 3,\n    get(buf, off) {\n        return buf.readIntBE(off, 3);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -0x800000 && v <= 0x7fffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeIntBE(v, o, 3);\n    }\n};\n/**\n * 32-bit signed integer, Big Endian byte order\n */\nexports.INT32_BE = {\n    len: 4,\n    get(buf, off) {\n        return buf.readInt32BE(off);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -2147483648 && v <= 2147483647);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeInt32BE(v, o);\n    }\n};\n/**\n * 32-bit signed integer, Big Endian byte order\n */\nexports.INT32_LE = {\n    len: 4,\n    get(buf, off) {\n        return buf.readInt32LE(off);\n    },\n    put(b, o, v) {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -2147483648 && v <= 2147483647);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n        return b.writeInt32LE(v, o);\n    }\n};\n/**\n * 64-bit unsigned integer, Little Endian byte order\n */\nexports.UINT64_LE = {\n    len: 8,\n    get(buf, off) {\n        return readUIntLE(buf, off, this.len);\n    },\n    put(b, o, v) {\n        return writeUIntLE(b, v, o, this.len);\n    }\n};\n/**\n * 64-bit signed integer, Little Endian byte order\n */\nexports.INT64_LE = {\n    len: 8,\n    get(buf, off) {\n        return readIntLE(buf, off, this.len);\n    },\n    put(b, off, v) {\n        return writeIntLE(b, v, off, this.len);\n    }\n};\n/**\n * 64-bit unsigned integer, Big Endian byte order\n */\nexports.UINT64_BE = {\n    len: 8,\n    get(b, off) {\n        return readUIntBE(b, off, this.len);\n    },\n    put(b, o, v) {\n        return writeUIntBE(b, v, o, this.len);\n    }\n};\n/**\n * 64-bit signed integer, Big Endian byte order\n */\nexports.INT64_BE = {\n    len: 8,\n    get(b, off) {\n        return readIntBE(b, off, this.len);\n    },\n    put(b, off, v) {\n        return writeIntBE(b, v, off, this.len);\n    }\n};\n/**\n * IEEE 754 16-bit (half precision) float, big endian\n */\nexports.Float16_BE = {\n    len: 2,\n    get(b, off) {\n        return ieee754.read(b, off, false, 10, this.len);\n    },\n    put(b, off, v) {\n        return ieee754.write(b, v, off, false, 10, this.len);\n    }\n};\n/**\n * IEEE 754 16-bit (half precision) float, little endian\n */\nexports.Float16_LE = {\n    len: 2,\n    get(b, off) {\n        return ieee754.read(b, off, true, 10, this.len);\n    },\n    put(b, off, v) {\n        return ieee754.write(b, v, off, true, 10, this.len);\n    }\n};\n/**\n * IEEE 754 32-bit (single precision) float, big endian\n */\nexports.Float32_BE = {\n    len: 4,\n    get(b, off) {\n        return b.readFloatBE(off);\n    },\n    put(b, off, v) {\n        return b.writeFloatBE(v, off);\n    }\n};\n/**\n * IEEE 754 32-bit (single precision) float, little endian\n */\nexports.Float32_LE = {\n    len: 4,\n    get(b, off) {\n        return b.readFloatLE(off);\n    },\n    put(b, off, v) {\n        return b.writeFloatLE(v, off);\n    }\n};\n/**\n * IEEE 754 64-bit (double precision) float, big endian\n */\nexports.Float64_BE = {\n    len: 8,\n    get(b, off) {\n        return b.readDoubleBE(off);\n    },\n    put(b, off, v) {\n        return b.writeDoubleBE(v, off);\n    }\n};\n/**\n * IEEE 754 64-bit (double precision) float, little endian\n */\nexports.Float64_LE = {\n    len: 8,\n    get(b, off) {\n        return b.readDoubleLE(off);\n    },\n    put(b, off, v) {\n        return b.writeDoubleLE(v, off);\n    }\n};\n/**\n * IEEE 754 80-bit (extended precision) float, big endian\n */\nexports.Float80_BE = {\n    len: 10,\n    get(b, off) {\n        return ieee754.read(b, off, false, 63, this.len);\n    },\n    put(b, off, v) {\n        return ieee754.write(b, v, off, false, 63, this.len);\n    }\n};\n/**\n * IEEE 754 80-bit (extended precision) float, little endian\n */\nexports.Float80_LE = {\n    len: 10,\n    get(b, off) {\n        return ieee754.read(b, off, true, 63, this.len);\n    },\n    put(b, off, v) {\n        return ieee754.write(b, v, off, true, 63, this.len);\n    }\n};\n/**\n * Ignore a given number of bytes\n */\nclass IgnoreType {\n    /**\n     * @param len number of bytes to ignore\n     */\n    constructor(len) {\n        this.len = len;\n    }\n    // ToDo: don't read, but skip data\n    get(buf, off) {\n    }\n}\nexports.IgnoreType = IgnoreType;\nclass BufferType {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return buf.slice(off, off + this.len);\n    }\n}\nexports.BufferType = BufferType;\n/**\n * Consume a fixed number of bytes from the stream and return a string with a specified encoding.\n */\nclass StringType {\n    constructor(len, encoding) {\n        this.len = len;\n        this.encoding = encoding;\n    }\n    get(buf, off) {\n        return buf.toString(this.encoding, off, off + this.len);\n    }\n}\nexports.StringType = StringType;\n/**\n * ANSI Latin 1 String\n * Using windows-1252 / ISO 8859-1 decoding\n */\nclass AnsiStringType {\n    constructor(len) {\n        this.len = len;\n    }\n    static decode(buffer, off, until) {\n        let str = '';\n        for (let i = off; i < until; ++i) {\n            str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));\n        }\n        return str;\n    }\n    static inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    static codePointToString(cp) {\n        if (cp <= 0xFFFF) {\n            return String.fromCharCode(cp);\n        }\n        else {\n            cp -= 0x10000;\n            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n        }\n    }\n    static singleByteDecoder(bite) {\n        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {\n            return bite;\n        }\n        const codePoint = AnsiStringType.windows1252[bite - 0x80];\n        if (codePoint === null) {\n            throw Error('invaliding encoding');\n        }\n        return codePoint;\n    }\n    get(buf, off = 0) {\n        return AnsiStringType.decode(buf, off, off + this.len);\n    }\n}\nexports.AnsiStringType = AnsiStringType;\nAnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,\n    8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,\n    8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n    169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,\n    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,\n    201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,\n    217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,\n    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\n    248, 249, 250, 251, 252, 253, 254, 255];\n/**\n * Best effort approach to read up to 64 bit unsigned integer, little endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction readUIntLE(buf, offset, byteLength) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let val = buf[offset];\n    let mul = 1;\n    let i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += buf[offset + i] * mul;\n    }\n    return val;\n}\n/**\n * Best effort approach to write up to 64 bit unsigned integer, little endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction writeUIntLE(buf, value, offset, byteLength) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let mul = 1;\n    let i = 0;\n    buf[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        buf[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n}\n/**\n * Best effort approach to read 64 but signed integer, little endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction readIntLE(buf, offset, byteLength) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let val = buf[offset];\n    let mul = 1;\n    let i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += buf[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n}\n/**\n * Best effort approach to write 64 but signed integer, little endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction writeIntLE(buf, value, offset, byteLength) {\n    value = +value;\n    offset = offset >>> 0;\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    buf[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && buf[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        buf[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n}\nexports.writeIntLE = writeIntLE;\n/**\n * Best effort approach to read up to 64 bit unsigned integer, big endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction readUIntBE(buf, offset, byteLength) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let val = buf[offset + --byteLength];\n    let mul = 1;\n    while (byteLength > 0 && (mul *= 0x100)) {\n        val += buf[offset + --byteLength] * mul;\n    }\n    return val;\n}\nexports.readUIntBE = readUIntBE;\n/**\n * Best effort approach to write up to 64 bit unsigned integer, big endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction writeUIntBE(buf, value, offset, byteLength) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let i = byteLength - 1;\n    let mul = 1;\n    buf[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        buf[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n}\nexports.writeUIntBE = writeUIntBE;\n/**\n * Best effort approach to read 64 but signed integer, big endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction readIntBE(buf, offset, byteLength) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    let i = byteLength;\n    let mul = 1;\n    let val = buf[offset + --i];\n    while (i > 0 && (mul *= 0x100)) {\n        val += buf[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n}\nexports.readIntBE = readIntBE;\n/**\n * Best effort approach to write 64 but signed integer, big endian.\n * Note that JavasScript is limited to 2^53 - 1 bit.\n */\nfunction writeIntBE(buf, value, offset, byteLength) {\n    value = +value;\n    offset = offset >>> 0;\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    buf[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && buf[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        buf[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n}\nexports.writeIntBE = writeIntBE;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9rZW4tdHlwZXMvbGliL2luZGV4LmpzPzZmNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxlQUFlLG1CQUFPLENBQUMsOEVBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsZ0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9rZW4tdHlwZXMvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoXCJpZWVlNzU0XCIpO1xuLy8gUHJpbWl0aXZlIHR5cGVzXG4vKipcbiAqIDgtYml0IHVuc2lnbmVkIGludGVnZXJcbiAqL1xuZXhwb3J0cy5VSU5UOCA9IHtcbiAgICBsZW46IDEsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQ4KG9mZik7XG4gICAgfSxcbiAgICBwdXQoYnVmLCBvZmYsIHYpIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvZmYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiB2LCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5vayh2ID49IDAgJiYgdiA8PSAweGZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZiA+PSAwKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMubGVuIDw9IGJ1Zi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmLndyaXRlVUludDgodiwgb2ZmKTtcbiAgICB9XG59O1xuLyoqXG4gKiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDE2X0xFID0ge1xuICAgIGxlbjogMixcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2TEUob2ZmKTtcbiAgICB9LFxuICAgIHB1dChidWYsIG9mZiwgdikge1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG9mZiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gMCAmJiB2IDw9IDB4ZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmYgPj0gMCk7XG4gICAgICAgIGFzc2VydC5vayh0aGlzLmxlbiA8PSBidWYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1Zi53cml0ZVVJbnQxNkxFKHYsIG9mZik7XG4gICAgfVxufTtcbi8qKlxuICogMTYtYml0IHVuc2lnbmVkIGludGVnZXIsIEJpZyBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQxNl9CRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKG9mZik7XG4gICAgfSxcbiAgICBwdXQoYnVmLCBvZmYsIHYpIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvZmYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiB2LCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5vayh2ID49IDAgJiYgdiA8PSAweGZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2ZmID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYnVmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWYud3JpdGVVSW50MTZCRSh2LCBvZmYpO1xuICAgIH1cbn07XG4vKipcbiAqIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLCBMaXR0bGUgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5VSU5UMjRfTEUgPSB7XG4gICAgbGVuOiAzLFxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50TEUob2ZmLCAzKTtcbiAgICB9LFxuICAgIHB1dChidWYsIG9mZiwgdikge1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG9mZiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gMCAmJiB2IDw9IDB4ZmZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZiA+PSAwKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMubGVuIDw9IGJ1Zi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmLndyaXRlVUludExFKHYsIG9mZiwgMyk7XG4gICAgfVxufTtcbi8qKlxuICogMjQtYml0IHVuc2lnbmVkIGludGVnZXIsIEJpZyBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQyNF9CRSA9IHtcbiAgICBsZW46IDMsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnRCRShvZmYsIDMpO1xuICAgIH0sXG4gICAgcHV0KGJ1Ziwgb2ZmLCB2KSB7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2Ygb2ZmLCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgdiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQub2sodiA+PSAwICYmIHYgPD0gMHhmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2ZmID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYnVmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWYud3JpdGVVSW50QkUodiwgb2ZmLCAzKTtcbiAgICB9XG59O1xuLyoqXG4gKiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDMyX0xFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyTEUob2ZmKTtcbiAgICB9LFxuICAgIHB1dChiLCBvLCB2KSB7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgbywgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gMCAmJiB2IDw9IDB4ZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sobyA+PSAwKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMubGVuIDw9IGIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGIud3JpdGVVSW50MzJMRSh2LCBvKTtcbiAgICB9XG59O1xuLyoqXG4gKiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDMyX0JFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyQkUob2ZmKTtcbiAgICB9LFxuICAgIHB1dChidWYsIG9mZiwgdikge1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG9mZiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gMCAmJiB2IDw9IDB4ZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2ZmID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYnVmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWYud3JpdGVVSW50MzJCRSh2LCBvZmYpO1xuICAgIH1cbn07XG4vKipcbiAqIDgtYml0IHNpZ25lZCBpbnRlZ2VyXG4gKi9cbmV4cG9ydHMuSU5UOCA9IHtcbiAgICBsZW46IDEsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZEludDgob2ZmKTtcbiAgICB9LFxuICAgIHB1dChidWYsIG9mZiwgdikge1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG9mZiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gLTEyOCAmJiB2IDw9IDEyNyk7XG4gICAgICAgIGFzc2VydC5vayhvZmYgPj0gMCk7XG4gICAgICAgIGFzc2VydC5vayh0aGlzLmxlbiA8PSBidWYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1Zi53cml0ZUludDgodiwgb2ZmKTtcbiAgICB9XG59O1xuLyoqXG4gKiAxNi1iaXQgc2lnbmVkIGludGVnZXIsIEJpZyBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLklOVDE2X0JFID0ge1xuICAgIGxlbjogMixcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkSW50MTZCRShvZmYpO1xuICAgIH0sXG4gICAgcHV0KGIsIG8sIHYpIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvLCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgdiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQub2sodiA+PSAtMzI3NjggJiYgdiA8PSAzMjc2Nyk7XG4gICAgICAgIGFzc2VydC5vayhvID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYi53cml0ZUludDE2QkUodiwgbyk7XG4gICAgfVxufTtcbi8qKlxuICogMTYtYml0IHNpZ25lZCBpbnRlZ2VyLCBMaXR0bGUgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQxNl9MRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZEludDE2TEUob2ZmKTtcbiAgICB9LFxuICAgIHB1dChiLCBvLCB2KSB7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgbywgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpO1xuICAgICAgICBhc3NlcnQub2sobyA+PSAwKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMubGVuIDw9IGIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGIud3JpdGVJbnQxNkxFKHYsIG8pO1xuICAgIH1cbn07XG4vKipcbiAqIDI0LWJpdCBzaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMjRfTEUgPSB7XG4gICAgbGVuOiAzLFxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRJbnRMRShvZmYsIDMpO1xuICAgIH0sXG4gICAgcHV0KGIsIG8sIHYpIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvLCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgdiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQub2sodiA+PSAtMHg4MDAwMDAgJiYgdiA8PSAweDdmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYi53cml0ZUludExFKHYsIG8sIDMpO1xuICAgIH1cbn07XG4vKipcbiAqIDI0LWJpdCBzaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMjRfQkUgPSB7XG4gICAgbGVuOiAzLFxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRJbnRCRShvZmYsIDMpO1xuICAgIH0sXG4gICAgcHV0KGIsIG8sIHYpIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvLCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgdiwgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQub2sodiA+PSAtMHg4MDAwMDAgJiYgdiA8PSAweDdmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYi53cml0ZUludEJFKHYsIG8sIDMpO1xuICAgIH1cbn07XG4vKipcbiAqIDMyLWJpdCBzaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMzJfQkUgPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRJbnQzMkJFKG9mZik7XG4gICAgfSxcbiAgICBwdXQoYiwgbywgdikge1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG8sICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiB2LCAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydC5vayh2ID49IC0yMTQ3NDgzNjQ4ICYmIHYgPD0gMjE0NzQ4MzY0Nyk7XG4gICAgICAgIGFzc2VydC5vayhvID49IDApO1xuICAgICAgICBhc3NlcnQub2sodGhpcy5sZW4gPD0gYi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYi53cml0ZUludDMyQkUodiwgbyk7XG4gICAgfVxufTtcbi8qKlxuICogMzItYml0IHNpZ25lZCBpbnRlZ2VyLCBCaWcgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQzMl9MRSA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZEludDMyTEUob2ZmKTtcbiAgICB9LFxuICAgIHB1dChiLCBvLCB2KSB7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgbywgJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHYsICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0Lm9rKHYgPj0gLTIxNDc0ODM2NDggJiYgdiA8PSAyMTQ3NDgzNjQ3KTtcbiAgICAgICAgYXNzZXJ0Lm9rKG8gPj0gMCk7XG4gICAgICAgIGFzc2VydC5vayh0aGlzLmxlbiA8PSBiLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBiLndyaXRlSW50MzJMRSh2LCBvKTtcbiAgICB9XG59O1xuLyoqXG4gKiA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDY0X0xFID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRVSW50TEUoYnVmLCBvZmYsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChiLCBvLCB2KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVVJbnRMRShiLCB2LCBvLCB0aGlzLmxlbik7XG4gICAgfVxufTtcbi8qKlxuICogNjQtYml0IHNpZ25lZCBpbnRlZ2VyLCBMaXR0bGUgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQ2NF9MRSA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiByZWFkSW50TEUoYnVmLCBvZmYsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChiLCBvZmYsIHYpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlSW50TEUoYiwgdiwgb2ZmLCB0aGlzLmxlbik7XG4gICAgfVxufTtcbi8qKlxuICogNjQtYml0IHVuc2lnbmVkIGludGVnZXIsIEJpZyBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQ2NF9CRSA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGIsIG9mZikge1xuICAgICAgICByZXR1cm4gcmVhZFVJbnRCRShiLCBvZmYsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChiLCBvLCB2KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVVJbnRCRShiLCB2LCBvLCB0aGlzLmxlbik7XG4gICAgfVxufTtcbi8qKlxuICogNjQtYml0IHNpZ25lZCBpbnRlZ2VyLCBCaWcgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQ2NF9CRSA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGIsIG9mZikge1xuICAgICAgICByZXR1cm4gcmVhZEludEJFKGIsIG9mZiwgdGhpcy5sZW4pO1xuICAgIH0sXG4gICAgcHV0KGIsIG9mZiwgdikge1xuICAgICAgICByZXR1cm4gd3JpdGVJbnRCRShiLCB2LCBvZmYsIHRoaXMubGVuKTtcbiAgICB9XG59O1xuLyoqXG4gKiBJRUVFIDc1NCAxNi1iaXQgKGhhbGYgcHJlY2lzaW9uKSBmbG9hdCwgYmlnIGVuZGlhblxuICovXG5leHBvcnRzLkZsb2F0MTZfQkUgPSB7XG4gICAgbGVuOiAyLFxuICAgIGdldChiLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZChiLCBvZmYsIGZhbHNlLCAxMCwgdGhpcy5sZW4pO1xuICAgIH0sXG4gICAgcHV0KGIsIG9mZiwgdikge1xuICAgICAgICByZXR1cm4gaWVlZTc1NC53cml0ZShiLCB2LCBvZmYsIGZhbHNlLCAxMCwgdGhpcy5sZW4pO1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDE2LWJpdCAoaGFsZiBwcmVjaXNpb24pIGZsb2F0LCBsaXR0bGUgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQxNl9MRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGIsIG9mZikge1xuICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKGIsIG9mZiwgdHJ1ZSwgMTAsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChiLCBvZmYsIHYpIHtcbiAgICAgICAgcmV0dXJuIGllZWU3NTQud3JpdGUoYiwgdiwgb2ZmLCB0cnVlLCAxMCwgdGhpcy5sZW4pO1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDMyLWJpdCAoc2luZ2xlIHByZWNpc2lvbikgZmxvYXQsIGJpZyBlbmRpYW5cbiAqL1xuZXhwb3J0cy5GbG9hdDMyX0JFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYiwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRGbG9hdEJFKG9mZik7XG4gICAgfSxcbiAgICBwdXQoYiwgb2ZmLCB2KSB7XG4gICAgICAgIHJldHVybiBiLndyaXRlRmxvYXRCRSh2LCBvZmYpO1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDMyLWJpdCAoc2luZ2xlIHByZWNpc2lvbikgZmxvYXQsIGxpdHRsZSBlbmRpYW5cbiAqL1xuZXhwb3J0cy5GbG9hdDMyX0xFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYiwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRGbG9hdExFKG9mZik7XG4gICAgfSxcbiAgICBwdXQoYiwgb2ZmLCB2KSB7XG4gICAgICAgIHJldHVybiBiLndyaXRlRmxvYXRMRSh2LCBvZmYpO1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDY0LWJpdCAoZG91YmxlIHByZWNpc2lvbikgZmxvYXQsIGJpZyBlbmRpYW5cbiAqL1xuZXhwb3J0cy5GbG9hdDY0X0JFID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYiwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWREb3VibGVCRShvZmYpO1xuICAgIH0sXG4gICAgcHV0KGIsIG9mZiwgdikge1xuICAgICAgICByZXR1cm4gYi53cml0ZURvdWJsZUJFKHYsIG9mZik7XG4gICAgfVxufTtcbi8qKlxuICogSUVFRSA3NTQgNjQtYml0IChkb3VibGUgcHJlY2lzaW9uKSBmbG9hdCwgbGl0dGxlIGVuZGlhblxuICovXG5leHBvcnRzLkZsb2F0NjRfTEUgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldChiLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZERvdWJsZUxFKG9mZik7XG4gICAgfSxcbiAgICBwdXQoYiwgb2ZmLCB2KSB7XG4gICAgICAgIHJldHVybiBiLndyaXRlRG91YmxlTEUodiwgb2ZmKTtcbiAgICB9XG59O1xuLyoqXG4gKiBJRUVFIDc1NCA4MC1iaXQgKGV4dGVuZGVkIHByZWNpc2lvbikgZmxvYXQsIGJpZyBlbmRpYW5cbiAqL1xuZXhwb3J0cy5GbG9hdDgwX0JFID0ge1xuICAgIGxlbjogMTAsXG4gICAgZ2V0KGIsIG9mZikge1xuICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKGIsIG9mZiwgZmFsc2UsIDYzLCB0aGlzLmxlbik7XG4gICAgfSxcbiAgICBwdXQoYiwgb2ZmLCB2KSB7XG4gICAgICAgIHJldHVybiBpZWVlNzU0LndyaXRlKGIsIHYsIG9mZiwgZmFsc2UsIDYzLCB0aGlzLmxlbik7XG4gICAgfVxufTtcbi8qKlxuICogSUVFRSA3NTQgODAtYml0IChleHRlbmRlZCBwcmVjaXNpb24pIGZsb2F0LCBsaXR0bGUgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQ4MF9MRSA9IHtcbiAgICBsZW46IDEwLFxuICAgIGdldChiLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZChiLCBvZmYsIHRydWUsIDYzLCB0aGlzLmxlbik7XG4gICAgfSxcbiAgICBwdXQoYiwgb2ZmLCB2KSB7XG4gICAgICAgIHJldHVybiBpZWVlNzU0LndyaXRlKGIsIHYsIG9mZiwgdHJ1ZSwgNjMsIHRoaXMubGVuKTtcbiAgICB9XG59O1xuLyoqXG4gKiBJZ25vcmUgYSBnaXZlbiBudW1iZXIgb2YgYnl0ZXNcbiAqL1xuY2xhc3MgSWdub3JlVHlwZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxlbiBudW1iZXIgb2YgYnl0ZXMgdG8gaWdub3JlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICAvLyBUb0RvOiBkb24ndCByZWFkLCBidXQgc2tpcCBkYXRhXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgfVxufVxuZXhwb3J0cy5JZ25vcmVUeXBlID0gSWdub3JlVHlwZTtcbmNsYXNzIEJ1ZmZlclR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBidWYuc2xpY2Uob2ZmLCBvZmYgKyB0aGlzLmxlbik7XG4gICAgfVxufVxuZXhwb3J0cy5CdWZmZXJUeXBlID0gQnVmZmVyVHlwZTtcbi8qKlxuICogQ29uc3VtZSBhIGZpeGVkIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBzdHJlYW0gYW5kIHJldHVybiBhIHN0cmluZyB3aXRoIGEgc3BlY2lmaWVkIGVuY29kaW5nLlxuICovXG5jbGFzcyBTdHJpbmdUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4sIGVuY29kaW5nKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIG9mZiwgb2ZmICsgdGhpcy5sZW4pO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nVHlwZSA9IFN0cmluZ1R5cGU7XG4vKipcbiAqIEFOU0kgTGF0aW4gMSBTdHJpbmdcbiAqIFVzaW5nIHdpbmRvd3MtMTI1MiAvIElTTyA4ODU5LTEgZGVjb2RpbmdcbiAqL1xuY2xhc3MgQW5zaVN0cmluZ1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShidWZmZXIsIG9mZiwgdW50aWwpIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgdW50aWw7ICsraSkge1xuICAgICAgICAgICAgc3RyICs9IEFuc2lTdHJpbmdUeXBlLmNvZGVQb2ludFRvU3RyaW5nKEFuc2lTdHJpbmdUeXBlLnNpbmdsZUJ5dGVEZWNvZGVyKGJ1ZmZlcltpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHN0YXRpYyBpblJhbmdlKGEsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBtaW4gPD0gYSAmJiBhIDw9IG1heDtcbiAgICB9XG4gICAgc3RhdGljIGNvZGVQb2ludFRvU3RyaW5nKGNwKSB7XG4gICAgICAgIGlmIChjcCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNwIC09IDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY3AgPj4gMTApICsgMHhEODAwLCAoY3AgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBzaW5nbGVCeXRlRGVjb2RlcihiaXRlKSB7XG4gICAgICAgIGlmIChBbnNpU3RyaW5nVHlwZS5pblJhbmdlKGJpdGUsIDB4MDAsIDB4N0YpKSB7XG4gICAgICAgICAgICByZXR1cm4gYml0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBBbnNpU3RyaW5nVHlwZS53aW5kb3dzMTI1MltiaXRlIC0gMHg4MF07XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnZhbGlkaW5nIGVuY29kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmID0gMCkge1xuICAgICAgICByZXR1cm4gQW5zaVN0cmluZ1R5cGUuZGVjb2RlKGJ1Ziwgb2ZmLCBvZmYgKyB0aGlzLmxlbik7XG4gICAgfVxufVxuZXhwb3J0cy5BbnNpU3RyaW5nVHlwZSA9IEFuc2lTdHJpbmdUeXBlO1xuQW5zaVN0cmluZ1R5cGUud2luZG93czEyNTIgPSBbODM2NCwgMTI5LCA4MjE4LCA0MDIsIDgyMjIsIDgyMzAsIDgyMjQsIDgyMjUsIDcxMCwgODI0MCwgMzUyLFxuICAgIDgyNDksIDMzOCwgMTQxLCAzODEsIDE0MywgMTQ0LCA4MjE2LCA4MjE3LCA4MjIwLCA4MjIxLCA4MjI2LCA4MjExLCA4MjEyLCA3MzIsXG4gICAgODQ4MiwgMzUzLCA4MjUwLCAzMzksIDE1NywgMzgyLCAzNzYsIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsXG4gICAgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LFxuICAgIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCxcbiAgICAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsXG4gICAgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLFxuICAgIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsXG4gICAgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTVdO1xuLyoqXG4gKiBCZXN0IGVmZm9ydCBhcHByb2FjaCB0byByZWFkIHVwIHRvIDY0IGJpdCB1bnNpZ25lZCBpbnRlZ2VyLCBsaXR0bGUgZW5kaWFuLlxuICogTm90ZSB0aGF0IEphdmFzU2NyaXB0IGlzIGxpbWl0ZWQgdG8gMl41MyAtIDEgYml0LlxuICovXG5mdW5jdGlvbiByZWFkVUludExFKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuICAgIGxldCB2YWwgPSBidWZbb2Zmc2V0XTtcbiAgICBsZXQgbXVsID0gMTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgICAgdmFsICs9IGJ1ZltvZmZzZXQgKyBpXSAqIG11bDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQmVzdCBlZmZvcnQgYXBwcm9hY2ggdG8gd3JpdGUgdXAgdG8gNjQgYml0IHVuc2lnbmVkIGludGVnZXIsIGxpdHRsZSBlbmRpYW4uXG4gKiBOb3RlIHRoYXQgSmF2YXNTY3JpcHQgaXMgbGltaXRlZCB0byAyXjUzIC0gMSBiaXQuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVUludExFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcbiAgICBsZXQgbXVsID0gMTtcbiAgICBsZXQgaSA9IDA7XG4gICAgYnVmW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufVxuLyoqXG4gKiBCZXN0IGVmZm9ydCBhcHByb2FjaCB0byByZWFkIDY0IGJ1dCBzaWduZWQgaW50ZWdlciwgbGl0dGxlIGVuZGlhbi5cbiAqIE5vdGUgdGhhdCBKYXZhc1NjcmlwdCBpcyBsaW1pdGVkIHRvIDJeNTMgLSAxIGJpdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEludExFKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuICAgIGxldCB2YWwgPSBidWZbb2Zmc2V0XTtcbiAgICBsZXQgbXVsID0gMTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgICAgdmFsICs9IGJ1ZltvZmZzZXQgKyBpXSAqIG11bDtcbiAgICB9XG4gICAgbXVsICo9IDB4ODA7XG4gICAgaWYgKHZhbCA+PSBtdWwpXG4gICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQmVzdCBlZmZvcnQgYXBwcm9hY2ggdG8gd3JpdGUgNjQgYnV0IHNpZ25lZCBpbnRlZ2VyLCBsaXR0bGUgZW5kaWFuLlxuICogTm90ZSB0aGF0IEphdmFzU2NyaXB0IGlzIGxpbWl0ZWQgdG8gMl41MyAtIDEgYml0LlxuICovXG5mdW5jdGlvbiB3cml0ZUludExFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG11bCA9IDE7XG4gICAgbGV0IHN1YiA9IDA7XG4gICAgYnVmW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgYnVmW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgc3ViID0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufVxuZXhwb3J0cy53cml0ZUludExFID0gd3JpdGVJbnRMRTtcbi8qKlxuICogQmVzdCBlZmZvcnQgYXBwcm9hY2ggdG8gcmVhZCB1cCB0byA2NCBiaXQgdW5zaWduZWQgaW50ZWdlciwgYmlnIGVuZGlhbi5cbiAqIE5vdGUgdGhhdCBKYXZhc1NjcmlwdCBpcyBsaW1pdGVkIHRvIDJeNTMgLSAxIGJpdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFVJbnRCRShidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcbiAgICBsZXQgdmFsID0gYnVmW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gICAgbGV0IG11bCA9IDE7XG4gICAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICAgIHZhbCArPSBidWZbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydHMucmVhZFVJbnRCRSA9IHJlYWRVSW50QkU7XG4vKipcbiAqIEJlc3QgZWZmb3J0IGFwcHJvYWNoIHRvIHdyaXRlIHVwIHRvIDY0IGJpdCB1bnNpZ25lZCBpbnRlZ2VyLCBiaWcgZW5kaWFuLlxuICogTm90ZSB0aGF0IEphdmFzU2NyaXB0IGlzIGxpbWl0ZWQgdG8gMl41MyAtIDEgYml0LlxuICovXG5mdW5jdGlvbiB3cml0ZVVJbnRCRShidWYsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDA7XG4gICAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgICBsZXQgbXVsID0gMTtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMud3JpdGVVSW50QkUgPSB3cml0ZVVJbnRCRTtcbi8qKlxuICogQmVzdCBlZmZvcnQgYXBwcm9hY2ggdG8gcmVhZCA2NCBidXQgc2lnbmVkIGludGVnZXIsIGJpZyBlbmRpYW4uXG4gKiBOb3RlIHRoYXQgSmF2YXNTY3JpcHQgaXMgbGltaXRlZCB0byAyXjUzIC0gMSBiaXQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRJbnRCRShidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcbiAgICBsZXQgaSA9IGJ5dGVMZW5ndGg7XG4gICAgbGV0IG11bCA9IDE7XG4gICAgbGV0IHZhbCA9IGJ1ZltvZmZzZXQgKyAtLWldO1xuICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgICB2YWwgKz0gYnVmW29mZnNldCArIC0taV0gKiBtdWw7XG4gICAgfVxuICAgIG11bCAqPSAweDgwO1xuICAgIGlmICh2YWwgPj0gbXVsKVxuICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnRzLnJlYWRJbnRCRSA9IHJlYWRJbnRCRTtcbi8qKlxuICogQmVzdCBlZmZvcnQgYXBwcm9hY2ggdG8gd3JpdGUgNjQgYnV0IHNpZ25lZCBpbnRlZ2VyLCBiaWcgZW5kaWFuLlxuICogTm90ZSB0aGF0IEphdmFzU2NyaXB0IGlzIGxpbWl0ZWQgdG8gMl41MyAtIDEgYml0LlxuICovXG5mdW5jdGlvbiB3cml0ZUludEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICAgIGxldCBtdWwgPSAxO1xuICAgIGxldCBzdWIgPSAwO1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgYnVmW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgICAgICAgc3ViID0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufVxuZXhwb3J0cy53cml0ZUludEJFID0gd3JpdGVJbnRCRTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/token-types/lib/index.js\n");

/***/ }),

/***/ "./node_modules/typedarray-to-buffer/index.js":
/*!****************************************************!*\
  !*** ./node_modules/typedarray-to-buffer/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nvar isTypedArray = __webpack_require__(/*! is-typedarray */ \"./node_modules/is-typedarray/index.js\").strict\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanM/MDQ5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLDREQUFlOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnZlcnQgYSB0eXBlZCBhcnJheSB0byBhIEJ1ZmZlciB3aXRob3V0IGEgY29weVxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIHR5cGVkYXJyYXktdG8tYnVmZmVyYFxuICovXG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZGFycmF5Jykuc3RyaWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZWRhcnJheVRvQnVmZmVyIChhcnIpIHtcbiAgaWYgKGlzVHlwZWRBcnJheShhcnIpKSB7XG4gICAgLy8gVG8gYXZvaWQgYSBjb3B5LCB1c2UgdGhlIHR5cGVkIGFycmF5J3MgdW5kZXJseWluZyBBcnJheUJ1ZmZlciB0byBiYWNrIG5ldyBCdWZmZXJcbiAgICB2YXIgYnVmID0gQnVmZmVyLmZyb20oYXJyLmJ1ZmZlcilcbiAgICBpZiAoYXJyLmJ5dGVMZW5ndGggIT09IGFyci5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgLy8gUmVzcGVjdCB0aGUgXCJ2aWV3XCIsIGkuZS4gYnl0ZU9mZnNldCBhbmQgYnl0ZUxlbmd0aCwgd2l0aG91dCBkb2luZyBhIGNvcHlcbiAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVPZmZzZXQgKyBhcnIuYnl0ZUxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9IGVsc2Uge1xuICAgIC8vIFBhc3MgdGhyb3VnaCBhbGwgb3RoZXIgdHlwZXMgdG8gYEJ1ZmZlci5mcm9tYFxuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/typedarray-to-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcz9iN2QxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/util-deprecate/browser.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/NWI3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/MWQyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ })

/******/ });